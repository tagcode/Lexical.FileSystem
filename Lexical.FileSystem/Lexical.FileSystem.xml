<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Lexical.FileSystem</name>
    </assembly>
    <members>
        <member name="T:Lexical.FileSystem.EmbeddedFileSystem">
            <summary>
            File System that represents embedded resources of an <see cref="T:System.Reflection.Assembly"/>.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.EmbeddedFileSystem.Assembly">
            <summary>
            Associated Assembly
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.EmbeddedFileSystem.entries">
            <summary>
            Snapshot of entries.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.EmbeddedFileSystem.Entries">
            <summary>
            Lazy construction of entries.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.EmbeddedFileSystem.entryMap">
            <summary>
            Snapshot of entries as map
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.EmbeddedFileSystem.EntryMap">
            <summary>
            Lazy construction of entries as map.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.EmbeddedFileSystem.CaseSensitivity">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.EmbeddedFileSystem.EmptyDirectoryName">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.EmbeddedFileSystem.CanBrowse">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.EmbeddedFileSystem.CanGetEntry">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.EmbeddedFileSystem.CanOpen">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.EmbeddedFileSystem.CanRead">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.EmbeddedFileSystem.CanWrite">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.EmbeddedFileSystem.CanCreateFile">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.EmbeddedFileSystem.CanObserve">
            <inheritdoc/>
        </member>
        <member name="F:Lexical.FileSystem.EmbeddedFileSystem.rootEntry">
            <summary>
            Root entry
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.EmbeddedFileSystem.#ctor(System.Reflection.Assembly)">
            <summary>
            Create embedded 
            </summary>
            <param name="assembly"></param>
        </member>
        <member name="M:Lexical.FileSystem.EmbeddedFileSystem.CreateEntries">
            <summary>
            Create a snapshot of entries.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.EmbeddedFileSystem.Browse(System.String,Lexical.FileSystem.IOption)">
            <summary>
            Browse a list of embedded resources.
            
            For example:
                "assembly.res1"
                "assembly.res2"
            </summary>
            <param name="path"></param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.EmbeddedFileSystem.GetEntry(System.String,Lexical.FileSystem.IOption)">
            <summary>
            Get entry of a single file or directory.
            </summary>
            <param name="path">path to a directory or to a single file, "" is root, separator is "/"</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns>entry, or null if entry is not found</returns>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support exists</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters.</exception>
            <exception cref="T:System.InvalidOperationException">If <paramref name="path"/> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc.</exception>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="M:Lexical.FileSystem.EmbeddedFileSystem.Open(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,Lexical.FileSystem.IOption)">
            <summary>
            Open embedded resource for reading.
            </summary>
            <param name="path"></param>
            <param name="fileMode"></param>
            <param name="fileAccess"></param>
            <param name="fileShare"></param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.EmbeddedFileSystem.AddDisposeAction(System.Action{Lexical.FileSystem.EmbeddedFileSystem})">
            <summary>
            Invoke <paramref name="disposeAction"/> on the dispose of the object.
            
            If parent object is disposed or being disposed, the disposable will be disposed immedialy.
            </summary>
            <param name="disposeAction"></param>
            <returns>self</returns>
        </member>
        <member name="M:Lexical.FileSystem.EmbeddedFileSystem.AddDisposeAction(System.Action{System.Object},System.Object)">
            <summary>
            Invoke <paramref name="disposeAction"/> on the dispose of the object.
            
            If parent object is disposed or being disposed, the disposable will be disposed immedialy.
            </summary>
            <param name="disposeAction"></param>
            <param name="state"></param>
            <returns>self</returns>
        </member>
        <member name="M:Lexical.FileSystem.EmbeddedFileSystem.AddDisposable(System.Object)">
            <summary>
            Add <paramref name="disposable"/> to list of objects to be disposed along with the system.
            </summary>
            <param name="disposable"></param>
            <returns>filesystem</returns>
        </member>
        <member name="M:Lexical.FileSystem.EmbeddedFileSystem.AddDisposables(System.Collections.IEnumerable)">
            <summary>
            Add <paramref name="disposables"/> to list of objects to be disposed along with the system.
            </summary>
            <param name="disposables"></param>
            <returns>filesystem</returns>
        </member>
        <member name="M:Lexical.FileSystem.EmbeddedFileSystem.RemoveDisposable(System.Object)">
            <summary>
            Remove <paramref name="disposable"/> from dispose list.
            </summary>
            <param name="disposable"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.EmbeddedFileSystem.RemoveDisposables(System.Collections.IEnumerable)">
            <summary>
            Remove <paramref name="disposables"/> from dispose list.
            </summary>
            <param name="disposables"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.EmbeddedFileSystem.ToString">
            <summary>
            Print info
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.EmbeddedFileSystem.Observe(System.String,System.IObserver{Lexical.FileSystem.IEvent},System.Object,Lexical.FileSystem.IEventDispatcher)">
            <inheritdoc/>
        </member>
        <member name="T:Lexical.FileSystem.FileEntry">
            <summary>
            File entry.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.FileEntry.IsFile">
            <summary>
            Tests if entry represents a file.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.FileEntry.Length">
            <summary>
            File length. -1 if is length is unknown.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.FileEntry.PhysicalPath">
            <summary>
            (optional) Physical (OS) path to the file.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.FileEntry.#ctor(Lexical.FileSystem.IFileSystem,System.String,System.String,System.DateTimeOffset,System.DateTimeOffset,System.Int64,System.String)">
            <summary>
            Create entry without file attributes.
            </summary>
            <param name="filesystem"></param>
            <param name="path"></param>
            <param name="name"></param>
            <param name="lastModified"></param>
            <param name="lastAccess"></param>
            <param name="length"></param>
            <param name="physicalPath"></param>
        </member>
        <member name="T:Lexical.FileSystem.FileEntry.AndOption">
            <summary>Entry with custom option.</summary>
        </member>
        <member name="P:Lexical.FileSystem.FileEntry.AndOption.Options">
            <summary>Options that describe features and capabilities in that apply to this entry.</summary>
        </member>
        <member name="M:Lexical.FileSystem.FileEntry.AndOption.#ctor(Lexical.FileSystem.IFileSystem,System.String,System.String,System.DateTimeOffset,System.DateTimeOffset,System.Int64,Lexical.FileSystem.IOption,System.String)">
            <summary>Create entry with custom option</summary>
        </member>
        <member name="T:Lexical.FileSystem.FileEntry.WithAttributes">
            <summary>Entry with file attributes.</summary>
        </member>
        <member name="P:Lexical.FileSystem.FileEntry.WithAttributes.HasFileAttributes">
            <summary>
            Has file attributes
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.FileEntry.WithAttributes.FileAttributes">
            <summary>
            File attributes
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.FileEntry.WithAttributes.#ctor(Lexical.FileSystem.IFileSystem,System.String,System.String,System.DateTimeOffset,System.DateTimeOffset,System.Int64,System.IO.FileAttributes,System.String)">
            <summary>Create entry with custom option</summary>
        </member>
        <member name="T:Lexical.FileSystem.FileEntry.WithAttributes.AndOption">
            <summary>Entry with custom option.</summary>
        </member>
        <member name="P:Lexical.FileSystem.FileEntry.WithAttributes.AndOption.Options">
            <summary>Options that describe features and capabilities in that apply to this entry.</summary>
        </member>
        <member name="M:Lexical.FileSystem.FileEntry.WithAttributes.AndOption.#ctor(Lexical.FileSystem.IFileSystem,System.String,System.String,System.DateTimeOffset,System.DateTimeOffset,System.Int64,System.IO.FileAttributes,Lexical.FileSystem.IOption,System.String)">
            <summary>Create entry with custom option</summary>
        </member>
        <member name="T:Lexical.FileSystem.DirectoryAndFileEntry">
            <summary>
            File entry.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.DirectoryAndFileEntry.IsDirectory">
            <summary>
            Test if is a directory
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.DirectoryAndFileEntry.#ctor(Lexical.FileSystem.IFileSystem,System.String,System.String,System.DateTimeOffset,System.DateTimeOffset,System.Int64,System.String)">
            <summary>
            Create entry without file attributes.
            </summary>
            <param name="filesystem"></param>
            <param name="path"></param>
            <param name="name"></param>
            <param name="lastModified"></param>
            <param name="lastAccess"></param>
            <param name="length"></param>
            <param name="physicalPath"></param>
        </member>
        <member name="T:Lexical.FileSystem.DirectoryAndFileEntry.AndOption">
            <summary>Entry with custom option.</summary>
        </member>
        <member name="P:Lexical.FileSystem.DirectoryAndFileEntry.AndOption.Options">
            <summary>Options that describe features and capabilities in that apply to this entry.</summary>
        </member>
        <member name="M:Lexical.FileSystem.DirectoryAndFileEntry.AndOption.#ctor(Lexical.FileSystem.IFileSystem,System.String,System.String,System.DateTimeOffset,System.DateTimeOffset,System.Int64,Lexical.FileSystem.IOption,System.String)">
            <summary>Create entry with custom option</summary>
        </member>
        <member name="T:Lexical.FileSystem.DirectoryAndFileEntry.WithAttributes">
            <summary>Entry with file attributes.</summary>
        </member>
        <member name="P:Lexical.FileSystem.DirectoryAndFileEntry.WithAttributes.HasFileAttributes">
            <summary>
            Has file attributes
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.DirectoryAndFileEntry.WithAttributes.FileAttributes">
            <summary>
            File attributes
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.DirectoryAndFileEntry.WithAttributes.#ctor(Lexical.FileSystem.IFileSystem,System.String,System.String,System.DateTimeOffset,System.DateTimeOffset,System.Int64,System.IO.FileAttributes,System.String)">
            <summary>Create entry with custom option</summary>
        </member>
        <member name="T:Lexical.FileSystem.DirectoryAndFileEntry.WithAttributes.AndOption">
            <summary>Entry with custom option.</summary>
        </member>
        <member name="P:Lexical.FileSystem.DirectoryAndFileEntry.WithAttributes.AndOption.Options">
            <summary>Options that describe features and capabilities in that apply to this entry.</summary>
        </member>
        <member name="M:Lexical.FileSystem.DirectoryAndFileEntry.WithAttributes.AndOption.#ctor(Lexical.FileSystem.IFileSystem,System.String,System.String,System.DateTimeOffset,System.DateTimeOffset,System.Int64,System.IO.FileAttributes,Lexical.FileSystem.IOption,System.String)">
            <summary>Create entry with custom option</summary>
        </member>
        <member name="T:Lexical.FileSystem.DirectoryEntry">
            <summary>
            Directory entry.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.DirectoryEntry.IsDirectory">
            <summary>
            Tests if entry represents a directory.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.DirectoryEntry.PhysicalPath">
            <summary>
            (optional) Physical path
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.DirectoryEntry.#ctor(Lexical.FileSystem.IFileSystem,System.String,System.String,System.DateTimeOffset,System.DateTimeOffset,System.String)">
            <summary>
            Create entry
            </summary>
            <param name="filesystem"></param>
            <param name="path"></param>
            <param name="name"></param>
            <param name="lastModified"></param>
            <param name="lastAccess"></param>
            <param name="physicalPath"></param>
        </member>
        <member name="T:Lexical.FileSystem.DirectoryEntry.AndOption">
            <summary>Directory with custom option.</summary>
        </member>
        <member name="P:Lexical.FileSystem.DirectoryEntry.AndOption.Options">
            <summary>Options that describe features and capabilities in that apply to this entry.</summary>
        </member>
        <member name="M:Lexical.FileSystem.DirectoryEntry.AndOption.#ctor(Lexical.FileSystem.IFileSystem,System.String,System.String,System.DateTimeOffset,System.DateTimeOffset,System.String,Lexical.FileSystem.IOption)">
            <summary>Create entry with custom option</summary>
        </member>
        <member name="T:Lexical.FileSystem.DirectoryEntry.WithAttributes">
            <summary>Entry with file attributes.</summary>
        </member>
        <member name="P:Lexical.FileSystem.DirectoryEntry.WithAttributes.HasFileAttributes">
            <summary>
            Has file attributes
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.DirectoryEntry.WithAttributes.FileAttributes">
            <summary>
            File attributes
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.DirectoryEntry.WithAttributes.#ctor(Lexical.FileSystem.IFileSystem,System.String,System.String,System.DateTimeOffset,System.DateTimeOffset,System.IO.FileAttributes,System.String)">
            <summary>Create entry with custom option</summary>
        </member>
        <member name="T:Lexical.FileSystem.DirectoryEntry.WithAttributes.AndOption">
            <summary>Entry with custom option.</summary>
        </member>
        <member name="P:Lexical.FileSystem.DirectoryEntry.WithAttributes.AndOption.Options">
            <summary>Options that describe features and capabilities in that apply to this entry.</summary>
        </member>
        <member name="M:Lexical.FileSystem.DirectoryEntry.WithAttributes.AndOption.#ctor(Lexical.FileSystem.IFileSystem,System.String,System.String,System.DateTimeOffset,System.DateTimeOffset,System.IO.FileAttributes,Lexical.FileSystem.IOption,System.String)">
            <summary>Create entry with custom option</summary>
        </member>
        <member name="T:Lexical.FileSystem.DriveEntry">
            <summary>
            Drive entry.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.DriveEntry.IsDirectory">
            <summary>
            Tests if entry represents a directory.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.DriveEntry.IsDrive">
            <summary>
            Tests if entry represents a drive.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.DriveEntry.DriveType">
            <summary>
            Drive type.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.DriveEntry.DriveFreeSpace">
            <summary>
            Free space, -1L if unknown.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.DriveEntry.DriveSize">
            <summary>
            Total size of drive or volume. -1L if unkown.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.DriveEntry.DriveLabel">
            <summary>
            Label, or null if unknown.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.DriveEntry.DriveFormat">
            <summary>
            File system format.
            
            Examples:
            <list type="bullet">
                <item>NTFS</item>
                <item>FAT32</item>
            </list>
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.DriveEntry.PhysicalPath">
            <summary>
            (optional) Physical path
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.DriveEntry.#ctor(Lexical.FileSystem.IFileSystem,System.String,System.String,System.DateTimeOffset,System.DateTimeOffset,System.IO.DriveType,System.Int64,System.Int64,System.String,System.String,System.Boolean,System.String)">
            <summary>
            Create entry
            </summary>
            <param name="filesystem"></param>
            <param name="path"></param>
            <param name="name"></param>
            <param name="lastModified"></param>
            <param name="lastAccess"></param>
            <param name="driveType"></param>
            <param name="driveFreeSpace"></param>
            <param name="driveSize"></param>
            <param name="driveLabel"></param>
            <param name="driveFormat"></param>
            <param name="isDirectory">Does entry represent a directory (is entry ready, mounted and readable)</param>
            <param name="physicalPath"></param>
        </member>
        <member name="T:Lexical.FileSystem.DriveEntry.AndOption">
            <summary>Entry with custom option.</summary>
        </member>
        <member name="P:Lexical.FileSystem.DriveEntry.AndOption.Options">
            <summary>Options that describe features and capabilities in that apply to this entry.</summary>
        </member>
        <member name="M:Lexical.FileSystem.DriveEntry.AndOption.#ctor(Lexical.FileSystem.IFileSystem,System.String,System.String,System.DateTimeOffset,System.DateTimeOffset,System.IO.DriveType,System.Int64,System.Int64,System.String,System.String,System.Boolean,Lexical.FileSystem.IOption,System.String)">
            <summary>Create entry with custom option</summary>
        </member>
        <member name="T:Lexical.FileSystem.MountEntry">
            <summary>
            Mount or decoration entry.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.MountEntry.IsMountPoint">
            <summary>
            Tests if entry represents a mount root.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.MountEntry.Mounts">
            <summary>
            Mounts
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.MountEntry.#ctor(Lexical.FileSystem.IFileSystem,System.String,System.String,System.DateTimeOffset,System.DateTimeOffset,System.String,Lexical.FileSystem.FileSystemAssignment[])">
            <summary>
            Create entry
            </summary>
            <param name="filesystem"></param>
            <param name="path"></param>
            <param name="name"></param>
            <param name="lastModified"></param>
            <param name="lastAccess"></param>
            <param name="physicalPath"></param>
            <param name="mounts"></param>
        </member>
        <member name="T:Lexical.FileSystem.MountEntry.AndOption">
            <summary>Entry with custom option.</summary>
        </member>
        <member name="P:Lexical.FileSystem.MountEntry.AndOption.Options">
            <summary>Options that describe features and capabilities in that apply to this entry.</summary>
        </member>
        <member name="M:Lexical.FileSystem.MountEntry.AndOption.#ctor(Lexical.FileSystem.IFileSystem,System.String,System.String,System.DateTimeOffset,System.DateTimeOffset,System.String,Lexical.FileSystem.FileSystemAssignment[],Lexical.FileSystem.IOption)">
            <summary>Create entry with custom option</summary>
        </member>
        <member name="T:Lexical.FileSystem.MountEntry.WithAttributes">
            <summary>Entry with file attributes.</summary>
        </member>
        <member name="P:Lexical.FileSystem.MountEntry.WithAttributes.HasFileAttributes">
            <summary>
            Has file attributes
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.MountEntry.WithAttributes.FileAttributes">
            <summary>
            File attributes
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.MountEntry.WithAttributes.#ctor(Lexical.FileSystem.IFileSystem,System.String,System.String,System.DateTimeOffset,System.DateTimeOffset,System.String,Lexical.FileSystem.FileSystemAssignment[],System.IO.FileAttributes)">
            <summary>Create entry with custom option</summary>
        </member>
        <member name="T:Lexical.FileSystem.MountEntry.WithAttributes.AndOption">
            <summary>Entry with custom option.</summary>
        </member>
        <member name="P:Lexical.FileSystem.MountEntry.WithAttributes.AndOption.Options">
            <summary>Options that describe features and capabilities in that apply to this entry.</summary>
        </member>
        <member name="M:Lexical.FileSystem.MountEntry.WithAttributes.AndOption.#ctor(Lexical.FileSystem.IFileSystem,System.String,System.String,System.DateTimeOffset,System.DateTimeOffset,System.String,Lexical.FileSystem.FileSystemAssignment[],System.IO.FileAttributes,Lexical.FileSystem.IOption)">
            <summary>Create entry with custom option</summary>
        </member>
        <member name="T:Lexical.FileSystem.EntryBase">
            <summary>
            Base implementation for <see cref="T:Lexical.FileSystem.IEvent"/> classes. Entry is a snapshot at the time of creation.
            
            See sub-classes:
            <list type="bullet">
                <item><see cref="T:Lexical.FileSystem.FileEntry"/></item>
                <item><see cref="T:Lexical.FileSystem.DirectoryEntry"/></item>
                <item><see cref="T:Lexical.FileSystem.DriveEntry"/></item>
                <item><see cref="T:Lexical.FileSystem.Decoration.EntryDecoration"/></item>
            </list>
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.EntryBase.FileSystem">
            <summary>
            (optional) Associated file system.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.EntryBase.Path">
            <summary>
            Path that is relative to the <see cref="T:Lexical.FileSystem.IFileSystem"/>.
            Separator is "/".
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.EntryBase.Name">
            <summary>
            Entry name in its parent context.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.EntryBase.LastModified">
            <summary>
            Date time of last modification.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.EntryBase.LastAccess">
            <summary>
            Last access time of entry. If Unknown returns <see cref="F:System.DateTimeOffset.MinValue"/>.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.EntryBase.#ctor(Lexical.FileSystem.IFileSystem,System.String,System.String,System.DateTimeOffset,System.DateTimeOffset)">
            <summary>
            Create entry
            </summary>
            <param name="filesystem"></param>
            <param name="path"></param>
            <param name="name"></param>
            <param name="lastModified"></param>
            <param name="lastAccess"></param>
        </member>
        <member name="M:Lexical.FileSystem.EntryBase.ToString">
            <summary>
            Print info.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Lexical.FileSystem.Decoration.EntryDecoration">
            <summary>
            Abstract base class for decorated entry.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.EntryDecoration.DecorateFileSystem(Lexical.FileSystem.IEntry,Lexical.FileSystem.IFileSystem)">
            <summary>
            Decorate filesystem.
            </summary>
            <param name="entry"></param>
            <param name="newFileSystem"></param>
            <returns>decorated entry</returns>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.EntryDecoration.DecorateFileSystemAndPath(Lexical.FileSystem.IEntry,Lexical.FileSystem.IFileSystem,System.String)">
            <summary>
            Decorate filesystem and path.
            </summary>
            <param name="entry"></param>
            <param name="newFileSystem"></param>
            <param name="newPath"></param>
            <returns>decorated entry</returns>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.EntryDecoration.DecorateFileSystemPathAndOptionModifier(Lexical.FileSystem.IEntry,Lexical.FileSystem.IFileSystem,System.String,Lexical.FileSystem.IOption)">
            <summary>
            Decorate filesystem and path, and add option modifier.
            </summary>
            <param name="entry"></param>
            <param name="newFileSystem"></param>
            <param name="newPath"></param>
            <param name="optionModifier">(optional) option that will be applied to original option with intersection</param>
            <returns>decorated entry</returns>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.EntryDecoration.Original">
            <summary>
            Original entry that is being decorated.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.EntryDecoration.FileSystem">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.EntryDecoration.Path">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.EntryDecoration.Name">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.EntryDecoration.LastModified">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.EntryDecoration.LastAccess">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.EntryDecoration.IsFile">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.EntryDecoration.Length">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.EntryDecoration.IsDirectory">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.EntryDecoration.Options">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.EntryDecoration.IsDrive">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.EntryDecoration.IsMountPoint">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.EntryDecoration.Mounts">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.EntryDecoration.DriveType">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.EntryDecoration.DriveFreeSpace">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.EntryDecoration.DriveSize">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.EntryDecoration.DriveLabel">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.EntryDecoration.DriveFormat">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.EntryDecoration.HasFileAttributes">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.EntryDecoration.FileAttributes">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.EntryDecoration.PhysicalPath">
            <inheritdoc/>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.EntryDecoration.#ctor(Lexical.FileSystem.IEntry)">
            <summary>
            Create decorated entry.
            </summary>
            <param name="original"></param>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.EntryDecoration.ToString">
            <summary>Print info</summary>
            <returns>path</returns>
        </member>
        <member name="T:Lexical.FileSystem.Decoration.EntryDecoration.NewFileSystem">
            <summary>
            New overriding filesystem.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.EntryDecoration.NewFileSystem.newFileSystem">
            <summary>New overriding filesystem.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.EntryDecoration.NewFileSystem.FileSystem">
            <summary>New overriding filesystem.</summary>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.EntryDecoration.NewFileSystem.#ctor(Lexical.FileSystem.IEntry,Lexical.FileSystem.IFileSystem)">
            <summary>
            Create decoration with <paramref name="newFileSystem"/>.
            </summary>
            <param name="original"></param>
            <param name="newFileSystem"></param>
        </member>
        <member name="T:Lexical.FileSystem.Decoration.EntryDecoration.NewFileSystemAndPath">
            <summary>
            New overriding filesystem and Path
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.EntryDecoration.NewFileSystemAndPath.newFileSystem">
            <summary>New overriding filesystem.</summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.EntryDecoration.NewFileSystemAndPath.newPath">
            <summary>New overriding path.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.EntryDecoration.NewFileSystemAndPath.FileSystem">
            <summary>New overriding filesystem.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.EntryDecoration.NewFileSystemAndPath.Path">
            <summary>New path.</summary>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.EntryDecoration.NewFileSystemAndPath.#ctor(Lexical.FileSystem.IEntry,Lexical.FileSystem.IFileSystem,System.String)">
            <summary>
            Create decoration with <paramref name="newFileSystem"/>.
            </summary>
            <param name="original"></param>
            <param name="newFileSystem"></param>
            <param name="newPath"></param>
        </member>
        <member name="T:Lexical.FileSystem.Decoration.EntryDecoration.NewFileSystemPathAndOptionModifier">
            <summary>
            New overriding filesystem, Path and Option modifier
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.EntryDecoration.NewFileSystemPathAndOptionModifier.newFileSystem">
            <summary>New overriding filesystem.</summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.EntryDecoration.NewFileSystemPathAndOptionModifier.newPath">
            <summary>New overriding path.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.EntryDecoration.NewFileSystemPathAndOptionModifier.FileSystem">
            <summary>New overriding filesystem.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.EntryDecoration.NewFileSystemPathAndOptionModifier.Path">
            <summary>New path.</summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.EntryDecoration.NewFileSystemPathAndOptionModifier.optionModifier">
            <summary>(optional) Option that will be intersected lazily with original options.</summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.EntryDecoration.NewFileSystemPathAndOptionModifier.optionIntersection">
            <summary>Lazily construction intersection of <see cref="F:Lexical.FileSystem.Decoration.EntryDecoration.NewFileSystemPathAndOptionModifier.optionModifier"/> and <see cref="P:Lexical.FileSystem.Decoration.EntryDecoration.Original"/>.Option()</summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.EntryDecoration.NewFileSystemPathAndOptionModifier.Options">
            <summary>Intersection of <see cref="P:Lexical.FileSystem.Decoration.EntryDecoration.Original"/>.Option() and <see cref="F:Lexical.FileSystem.Decoration.EntryDecoration.NewFileSystemPathAndOptionModifier.optionModifier"/></summary>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.EntryDecoration.NewFileSystemPathAndOptionModifier.#ctor(Lexical.FileSystem.IEntry,Lexical.FileSystem.IFileSystem,System.String,Lexical.FileSystem.IOption)">
            <summary>
            Create decoration with <paramref name="newFileSystem"/>.
            </summary>
            <param name="original"></param>
            <param name="newFileSystem"></param>
            <param name="newPath"></param>
            <param name="optionModifier">(optional) option that will be applied to original option with intersection</param>
        </member>
        <member name="T:Lexical.FileSystem.Decoration.DoubleEntryDecoration">
            <summary>
            Decoration that uses two <see cref="T:Lexical.FileSystem.IEntry"/> instances: a and b. 
            
            Returns values from a if available, and if not then uses a fallback value from b.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.DoubleEntryDecoration.A">
            <summary>Entry to decorate.</summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.DoubleEntryDecoration.B">
            <summary>Entry to decorate, fallback values..</summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.DoubleEntryDecoration.Original">
            <summary>Original entry that is being decorated.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.DoubleEntryDecoration.FileSystem">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.DoubleEntryDecoration.Path">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.DoubleEntryDecoration.Name">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.DoubleEntryDecoration.LastModified">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.DoubleEntryDecoration.LastAccess">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.DoubleEntryDecoration.IsFile">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.DoubleEntryDecoration.Length">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.DoubleEntryDecoration.IsDirectory">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.DoubleEntryDecoration.Options">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.DoubleEntryDecoration.IsDrive">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.DoubleEntryDecoration.IsMountPoint">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.DoubleEntryDecoration.Mounts">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.DoubleEntryDecoration.DriveType">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.DoubleEntryDecoration.DriveFreeSpace">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.DoubleEntryDecoration.DriveSize">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.DoubleEntryDecoration.DriveLabel">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.DoubleEntryDecoration.DriveFormat">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.DoubleEntryDecoration.HasFileAttributes">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.DoubleEntryDecoration.FileAttributes">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.DoubleEntryDecoration.PhysicalPath">
            <inheritdoc/>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.DoubleEntryDecoration.#ctor(Lexical.FileSystem.IEntry,Lexical.FileSystem.IEntry)">
            <summary>
            Create decorated entry.
            </summary>
            <param name="a">entry to decoate</param>
            <param name="b">fallback values</param>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.DoubleEntryDecoration.ToString">
            <summary>Print info</summary>
            <returns>path</returns>
        </member>
        <member name="T:Lexical.FileSystem.Decoration.EventDecoration">
            <summary>
            Abstract base class for decorated events.
            
            See sub-classes:
            <list type="bullet">
                <item><see cref="T:Lexical.FileSystem.Decoration.RenameEventDecoration"/></item>
                <item><see cref="T:Lexical.FileSystem.Decoration.CreateEventDecoration"/></item>
                <item><see cref="T:Lexical.FileSystem.Decoration.ChangeEventDecoration"/></item>
                <item><see cref="T:Lexical.FileSystem.Decoration.DeleteEventDecoration"/></item>
                <item><see cref="T:Lexical.FileSystem.Decoration.ErrorEventDecoration"/></item>
            </list>
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.EventDecoration.DecorateObserver(Lexical.FileSystem.IEvent,Lexical.FileSystem.IFileSystemObserver,System.Boolean)">
            <summary>
            Decorate <paramref name="event"/> with <paramref name="newObserver"/>.
            </summary>
            <param name="event"></param>
            <param name="newObserver">overriding observer</param>
            <param name="throwIfUnknown">
                If true, throws exception if <paramref name="event"/> is not recognized. 
                If false, returns <see cref="T:Lexical.FileSystem.Decoration.EventDecoration"/> that has reference to undecorated event, but does not pass the interfaces from the source.
            </param>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">If the interface of <paramref name="event"/> is not supported.</exception>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.EventDecoration.DecorateObserverAndPath(Lexical.FileSystem.IEvent,Lexical.FileSystem.IFileSystemObserver,System.String,System.String,System.Boolean)">
            <summary>
            Decorate <paramref name="event"/> with <paramref name="newObserver"/> and <paramref name="newPath"/>.
            </summary>
            <param name="event"></param>
            <param name="newObserver">overriding observer</param>
            <param name="newPath">overriding path</param>
            <param name="newNewPath">overriding NewPath for <see cref="T:Lexical.FileSystem.IRenameEvent"/> events</param>
            <param name="throwIfUnknown">
                If true, throws exception if <paramref name="event"/> is not recognized. 
                If false, returns <see cref="T:Lexical.FileSystem.Decoration.EventDecoration"/> that has reference to undecorated event, but does not pass the interfaces from the source.
            </param>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">If the interface of <paramref name="event"/> is not supported.</exception>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.EventDecoration.Original">
            <summary>
            original undecorated event.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.EventDecoration.Observer">
            <summary>
            The filesystem observer that sent the event.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.EventDecoration.EventTime">
            <summary>
            The time the event occured, or approximation if not exactly known.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.EventDecoration.Path">
            <summary>
            (optional) Affected entry if applicable.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.EventDecoration.#ctor(Lexical.FileSystem.IEvent)">
            <summary>
            Create event.
            </summary>
            <param name="original">original event to be decorated</param>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.EventDecoration.ToString">
            <summary>
            Print info
            </summary>
            <returns></returns>
        </member>
        <member name="T:Lexical.FileSystem.Decoration.EventDecoration.NewObserver">
            <summary>Decoration with observer override.</summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.EventDecoration.NewObserver.newObserver">
            <summary>New observer value.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.EventDecoration.NewObserver.Observer">
            <summary>New observer value.</summary>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.EventDecoration.NewObserver.#ctor(Lexical.FileSystem.IEvent,Lexical.FileSystem.IFileSystemObserver)">
            <summary>Create decoration with observer override.</summary>
            <param name="original">original event</param>
            <param name="newObserver">observer override</param>
        </member>
        <member name="T:Lexical.FileSystem.Decoration.EventDecoration.NewObserverAndPath">
            <summary>Override observer and path.</summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.EventDecoration.NewObserverAndPath.newPath">
            <summary>New observer value.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.EventDecoration.NewObserverAndPath.Path">
            <summary>New observer value.</summary>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.EventDecoration.NewObserverAndPath.#ctor(Lexical.FileSystem.IEvent,Lexical.FileSystem.IFileSystemObserver,System.String)">
            <summary>Create observer and path decoration.</summary>
        </member>
        <member name="T:Lexical.FileSystem.Decoration.RenameEventDecoration">
            <summary>
            Abstract base class for decorated file renamed event.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.RenameEventDecoration.OldPath">
            <summary>
            The affected file or directory.
            
            Path is relative to the <see cref="T:Lexical.FileSystem.FileSystem"/>'s root.
            
            Directory separator is "/". Root path doesn't use separator.
            
            Example: "dir/file.ext"
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.RenameEventDecoration.NewPath">
            <summary>
            The new file or directory path.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.RenameEventDecoration.#ctor(Lexical.FileSystem.IEvent)">
            <summary>
            Create rename event.
            </summary>
            <param name="original">original event to be decorated</param>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.RenameEventDecoration.ToString">
            <summary>
            Print info
            </summary>
            <returns></returns>
        </member>
        <member name="T:Lexical.FileSystem.Decoration.RenameEventDecoration.NewObserver">
            <summary>Decoration with observer override.</summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.RenameEventDecoration.NewObserver.newObserver">
            <summary>New observer value.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.RenameEventDecoration.NewObserver.Observer">
            <summary>New observer value.</summary>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.RenameEventDecoration.NewObserver.#ctor(Lexical.FileSystem.IEvent,Lexical.FileSystem.IFileSystemObserver)">
            <summary>Create decoration with observer override.</summary>
            <param name="original">original event</param>
            <param name="newObserver">observer override</param>
        </member>
        <member name="T:Lexical.FileSystem.Decoration.RenameEventDecoration.NewObserverAndPath">
            <summary>Override observer and path.</summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.RenameEventDecoration.NewObserverAndPath.newOldPath">
            <summary>New observer value.</summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.RenameEventDecoration.NewObserverAndPath.newNewPath">
            <summary>New observer value.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.RenameEventDecoration.NewObserverAndPath.Path">
            <summary>New observer value.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.RenameEventDecoration.NewObserverAndPath.OldPath">
            <summary>New observer value.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.RenameEventDecoration.NewObserverAndPath.NewPath">
            <summary>New observer value.</summary>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.RenameEventDecoration.NewObserverAndPath.#ctor(Lexical.FileSystem.IEvent,Lexical.FileSystem.IFileSystemObserver,System.String,System.String)">
            <summary>Create observer and path decoration.</summary>
        </member>
        <member name="T:Lexical.FileSystem.Decoration.CreateEventDecoration">
            <summary>
            Abstract base class for decorated file created event.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.CreateEventDecoration.#ctor(Lexical.FileSystem.IEvent)">
            <summary>
            Create create event.
            </summary>
            <param name="original"></param>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.CreateEventDecoration.ToString">
            <summary>Print info</summary>
            <returns>Info</returns>
        </member>
        <member name="T:Lexical.FileSystem.Decoration.CreateEventDecoration.NewObserver">
            <summary>Decoration with observer override.</summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.CreateEventDecoration.NewObserver.newObserver">
            <summary>New observer value.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.CreateEventDecoration.NewObserver.Observer">
            <summary>New observer value.</summary>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.CreateEventDecoration.NewObserver.#ctor(Lexical.FileSystem.IEvent,Lexical.FileSystem.IFileSystemObserver)">
            <summary>Create decoration with observer override.</summary>
            <param name="original">original event</param>
            <param name="newObserver">observer override</param>
        </member>
        <member name="T:Lexical.FileSystem.Decoration.CreateEventDecoration.NewObserverAndPath">
            <summary>Override observer and path.</summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.CreateEventDecoration.NewObserverAndPath.newPath">
            <summary>New observer value.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.CreateEventDecoration.NewObserverAndPath.Path">
            <summary>New observer value.</summary>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.CreateEventDecoration.NewObserverAndPath.#ctor(Lexical.FileSystem.IEvent,Lexical.FileSystem.IFileSystemObserver,System.String)">
            <summary>Create observer and path decoration.</summary>
        </member>
        <member name="T:Lexical.FileSystem.Decoration.ChangeEventDecoration">
            <summary>
            File contents changed event
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.ChangeEventDecoration.#ctor(Lexical.FileSystem.IEvent)">
            <summary>
            Create change event.
            </summary>
            <param name="original"></param>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.ChangeEventDecoration.ToString">
            <summary>Print info</summary>
            <returns>Info</returns>
        </member>
        <member name="T:Lexical.FileSystem.Decoration.ChangeEventDecoration.NewObserver">
            <summary>Decoration with observer override.</summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.ChangeEventDecoration.NewObserver.newObserver">
            <summary>New observer value.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.ChangeEventDecoration.NewObserver.Observer">
            <summary>New observer value.</summary>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.ChangeEventDecoration.NewObserver.#ctor(Lexical.FileSystem.IEvent,Lexical.FileSystem.IFileSystemObserver)">
            <summary>Create decoration with observer override.</summary>
            <param name="original">original event</param>
            <param name="newObserver">observer override</param>
        </member>
        <member name="T:Lexical.FileSystem.Decoration.ChangeEventDecoration.NewObserverAndPath">
            <summary>Override observer and path.</summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.ChangeEventDecoration.NewObserverAndPath.newPath">
            <summary>New observer value.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.ChangeEventDecoration.NewObserverAndPath.Path">
            <summary>New observer value.</summary>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.ChangeEventDecoration.NewObserverAndPath.#ctor(Lexical.FileSystem.IEvent,Lexical.FileSystem.IFileSystemObserver,System.String)">
            <summary>Create observer and path decoration.</summary>
        </member>
        <member name="T:Lexical.FileSystem.Decoration.DeleteEventDecoration">
            <summary>
            Abstract base class for decorated file deleted event.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.DeleteEventDecoration.#ctor(Lexical.FileSystem.IEvent)">
            <summary>
            Create delete event.
            </summary>
            <param name="original"></param>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.DeleteEventDecoration.ToString">
            <summary>Print info</summary>
            <returns>Info</returns>
        </member>
        <member name="T:Lexical.FileSystem.Decoration.DeleteEventDecoration.NewObserver">
            <summary>Decoration with observer override.</summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.DeleteEventDecoration.NewObserver.newObserver">
            <summary>New observer value.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.DeleteEventDecoration.NewObserver.Observer">
            <summary>New observer value.</summary>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.DeleteEventDecoration.NewObserver.#ctor(Lexical.FileSystem.IEvent,Lexical.FileSystem.IFileSystemObserver)">
            <summary>Create decoration with observer override.</summary>
            <param name="original">original event</param>
            <param name="newObserver">observer override</param>
        </member>
        <member name="T:Lexical.FileSystem.Decoration.DeleteEventDecoration.NewObserverAndPath">
            <summary>Override observer and path.</summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.DeleteEventDecoration.NewObserverAndPath.newPath">
            <summary>New observer value.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.DeleteEventDecoration.NewObserverAndPath.Path">
            <summary>New observer value.</summary>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.DeleteEventDecoration.NewObserverAndPath.#ctor(Lexical.FileSystem.IEvent,Lexical.FileSystem.IFileSystemObserver,System.String)">
            <summary>Create observer and path decoration.</summary>
        </member>
        <member name="T:Lexical.FileSystem.Decoration.ErrorEventDecoration">
            <summary>
            Abstract base class for decorated error event.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.ErrorEventDecoration.Error">
            <summary>
            Error
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.ErrorEventDecoration.#ctor(Lexical.FileSystem.IEvent)">
            <summary>
            Create delete event.
            </summary>
            <param name="original"></param>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.ErrorEventDecoration.ToString">
            <summary>Print info</summary>
            <returns>Info</returns>
        </member>
        <member name="T:Lexical.FileSystem.Decoration.ErrorEventDecoration.NewObserver">
            <summary>Decoration with observer override.</summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.ErrorEventDecoration.NewObserver.newObserver">
            <summary>New observer value.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.ErrorEventDecoration.NewObserver.Observer">
            <summary>New observer value.</summary>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.ErrorEventDecoration.NewObserver.#ctor(Lexical.FileSystem.IEvent,Lexical.FileSystem.IFileSystemObserver)">
            <summary>Create decoration with observer override.</summary>
            <param name="original">original event</param>
            <param name="newObserver">observer override</param>
        </member>
        <member name="T:Lexical.FileSystem.Decoration.ErrorEventDecoration.NewObserverAndPath">
            <summary>Override observer and path.</summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.ErrorEventDecoration.NewObserverAndPath.newPath">
            <summary>New observer value.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.ErrorEventDecoration.NewObserverAndPath.Path">
            <summary>New observer value.</summary>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.ErrorEventDecoration.NewObserverAndPath.#ctor(Lexical.FileSystem.IEvent,Lexical.FileSystem.IFileSystemObserver,System.String)">
            <summary>Create observer and path decoration.</summary>
        </member>
        <member name="T:Lexical.FileSystem.Decoration.StartEventDecoration">
            <summary>
            Abstract base class for decorated observe started event.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.StartEventDecoration.#ctor(Lexical.FileSystem.IEvent)">
            <summary>
            Start create event.
            </summary>
            <param name="original"></param>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.StartEventDecoration.ToString">
            <summary>Print info</summary>
            <returns>Info</returns>
        </member>
        <member name="T:Lexical.FileSystem.Decoration.StartEventDecoration.NewObserver">
            <summary>Decoration with observer override.</summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.StartEventDecoration.NewObserver.newObserver">
            <summary>New observer value.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.StartEventDecoration.NewObserver.Observer">
            <summary>New observer value.</summary>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.StartEventDecoration.NewObserver.#ctor(Lexical.FileSystem.IEvent,Lexical.FileSystem.IFileSystemObserver)">
            <summary>Create observer decoration.</summary>
        </member>
        <member name="T:Lexical.FileSystem.Decoration.StartEventDecoration.NewObserverAndPath">
            <summary>Override observer and path.</summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.StartEventDecoration.NewObserverAndPath.newPath">
            <summary>New observer value.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.StartEventDecoration.NewObserverAndPath.Path">
            <summary>New observer value.</summary>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.StartEventDecoration.NewObserverAndPath.#ctor(Lexical.FileSystem.IEvent,Lexical.FileSystem.IFileSystemObserver,System.String)">
            <summary>Create observer and path decoration.</summary>
        </member>
        <member name="T:Lexical.FileSystem.Decoration.MountEventDecoration">
            <summary>
            Abstract base class for decorated observe started event.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.MountEventDecoration.Assignments">
            <summary>(new) Assignment configuration at mountpoint</summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.MountEventDecoration.Option">
            <summary>Mount option</summary>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.MountEventDecoration.#ctor(Lexical.FileSystem.IEvent)">
            <summary>
            Start create event.
            </summary>
            <param name="original"></param>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.MountEventDecoration.ToString">
            <summary>Print info</summary>
            <returns>Info</returns>
        </member>
        <member name="T:Lexical.FileSystem.Decoration.MountEventDecoration.NewObserver">
            <summary>Decoration with observer override.</summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.MountEventDecoration.NewObserver.newObserver">
            <summary>New observer value.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.MountEventDecoration.NewObserver.Observer">
            <summary>New observer value.</summary>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.MountEventDecoration.NewObserver.#ctor(Lexical.FileSystem.IEvent,Lexical.FileSystem.IFileSystemObserver)">
            <summary>Create observer decoration.</summary>
        </member>
        <member name="T:Lexical.FileSystem.Decoration.MountEventDecoration.NewObserverAndPath">
            <summary>Override observer and path.</summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.MountEventDecoration.NewObserverAndPath.newPath">
            <summary>New observer value.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.MountEventDecoration.NewObserverAndPath.Path">
            <summary>New observer value.</summary>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.MountEventDecoration.NewObserverAndPath.#ctor(Lexical.FileSystem.IEvent,Lexical.FileSystem.IFileSystemObserver,System.String)">
            <summary>Create observer and path decoration.</summary>
        </member>
        <member name="T:Lexical.FileSystem.Decoration.UnmountEventDecoration">
            <summary>
            Abstract base class for decorated observe started event.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.UnmountEventDecoration.#ctor(Lexical.FileSystem.IEvent)">
            <summary>
            Start create event.
            </summary>
            <param name="original"></param>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.UnmountEventDecoration.ToString">
            <summary>Print info</summary>
            <returns>Info</returns>
        </member>
        <member name="T:Lexical.FileSystem.Decoration.UnmountEventDecoration.NewObserver">
            <summary>Decoration with observer override.</summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.UnmountEventDecoration.NewObserver.newObserver">
            <summary>New observer value.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.UnmountEventDecoration.NewObserver.Observer">
            <summary>New observer value.</summary>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.UnmountEventDecoration.NewObserver.#ctor(Lexical.FileSystem.IEvent,Lexical.FileSystem.IFileSystemObserver)">
            <summary>Create observer decoration.</summary>
        </member>
        <member name="T:Lexical.FileSystem.Decoration.UnmountEventDecoration.NewObserverAndPath">
            <summary>Override observer and path.</summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.UnmountEventDecoration.NewObserverAndPath.newPath">
            <summary>New observer value.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.UnmountEventDecoration.NewObserverAndPath.Path">
            <summary>New observer value.</summary>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.UnmountEventDecoration.NewObserverAndPath.#ctor(Lexical.FileSystem.IEvent,Lexical.FileSystem.IFileSystemObserver,System.String)">
            <summary>Create observer and path decoration.</summary>
        </member>
        <member name="T:Lexical.FileSystem.Decoration.FileProviderSystem">
            <summary>
            File system that reads, observes and browses files from <see cref="T:Microsoft.Extensions.FileProviders.IFileProvider"/> source.
            
            The recommended way to create <see cref="T:Lexical.FileSystem.Decoration.FileSystemProvider"/> is to use
            the extension method in <see cref="M:Lexical.FileSystem.FileProviderExtensions.ToFileSystem(Microsoft.Extensions.FileProviders.IFileProvider,System.Boolean,System.Boolean,System.Boolean)"/>.
            
            WARNING: The Observe implementation browses the subtree of the watched directory path in order to create delta of changes.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.FileProviderSystem.fileProvider">
            <summary>
            Source file provider. This value is nulled on dispose.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.FileProviderSystem.FileProvider">
            <summary>
            Source file provider. This value is nulled on dispose.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.FileProviderSystem.FileProviderDisposable">
            <summary>
            Source file provider casted to <see cref="T:System.IDisposable"/>. Value is null if <see cref="P:Lexical.FileSystem.Decoration.FileProviderSystem.FileProvider"/> doesn't implement <see cref="T:System.IDisposable"/>.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.FileProviderSystem.CanBrowse">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.FileProviderSystem.CanGetEntry">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.FileProviderSystem.CanObserve">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.FileProviderSystem.CanOpen">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.FileProviderSystem.CanRead">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.FileProviderSystem.CanWrite">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.FileProviderSystem.CanCreateFile">
            <inheritdoc/>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.FileProviderSystem.isPhysicalFileProvider">
            <summary>
            <see cref="P:Lexical.FileSystem.Decoration.FileProviderSystem.FileProvider"/> is physical fileprovider.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.FileProviderSystem.rootEntry">
            <summary>
            Root entry. Constructed only for PhysicalFileProvider. For other, is constructed at runtime.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.FileProviderSystem.options">
            <summary>
            Options all
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileProviderSystem.#ctor(Microsoft.Extensions.FileProviders.IFileProvider,Lexical.FileSystem.IOption)">
            <summary>
            Create file provider based file system.
            </summary>
            <param name="sourceFileProvider"></param>
            <param name="option"></param>
        </member>
        <member name="T:Lexical.FileSystem.Decoration.FileProviderSystem.Options">
            <summary>FileProvider options</summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.FileProviderSystem.Options.AllEnabled">
            <summary></summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.FileProviderSystem.Options.CanBrowse">
            <summary></summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.FileProviderSystem.Options.CanGetEntry">
            <summary></summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.FileProviderSystem.Options.CanOpen">
            <summary></summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.FileProviderSystem.Options.CanRead">
            <summary></summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.FileProviderSystem.Options.CanWrite">
            <summary></summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.FileProviderSystem.Options.CanCreateFile">
            <summary></summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.FileProviderSystem.Options.CanObserve">
            <summary></summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.FileProviderSystem.Options.tokens">
            <summary>Tokens</summary>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileProviderSystem.Options.#ctor">
            <summary>Create options</summary>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileProviderSystem.Options.#ctor(System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Create options</summary>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileProviderSystem.Options.Read(Lexical.FileSystem.IOption)">
            <summary>
            Read options from <paramref name="option"/> and return flattened object.
            </summary>
            <param name="option"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileProviderSystem.Options.GetEnumerator">
            <summary>Get enumerator</summary>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileProviderSystem.Options.System#Collections#IEnumerable#GetEnumerator">
            <summary>Get enumerator</summary>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileProviderSystem.Open(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,Lexical.FileSystem.IOption)">
            <summary>
            Open a file for reading. 
            </summary>
            <param name="path">Relative path to file. Directory separator is "/". Root is without preceding "/", e.g. "dir/file.xml"</param>
            <param name="fileMode">determines whether to open or to create the file</param>
            <param name="fileAccess">how to access the file, read, write or read and write</param>
            <param name="fileShare">how the file will be shared by processes</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns>open file stream</returns>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> is an empty string (""), contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support opening files</exception>
            <exception cref="T:System.IO.FileNotFoundException">The file cannot be found, such as when mode is FileMode.Truncate or FileMode.Open, and and the file specified by path does not exist. The file must already exist in these modes.</exception>
            <exception cref="T:System.IO.DirectoryNotFoundException">The specified path is invalid, such as being on an unmapped drive.</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="fileMode"/>, <paramref name="fileAccess"/> or <paramref name="fileShare"/> contains an invalid value.</exception>
            <exception cref="T:System.InvalidOperationException">If <paramref name="path"/> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc.</exception>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileProviderSystem.Browse(System.String,Lexical.FileSystem.IOption)">
            <summary>
            Browse a directory for file and subdirectory entries.
            </summary>
            <param name="path">path to directory, "" is root, separator is "/"</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns>a snapshot of file and directory entries</returns>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support browse</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters.</exception>
            <exception cref="T:System.InvalidOperationException">If <paramref name="path"/> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc.</exception>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileProviderSystem.GetEntry(System.String,Lexical.FileSystem.IOption)">
            <summary>
            Get entry of a single file or directory.
            </summary>
            <param name="path">path to a directory or to a single file, "" is root, separator is "/"</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns>entry, or null if entry is not found</returns>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support exists</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters.</exception>
            <exception cref="T:System.InvalidOperationException">If <paramref name="path"/> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc.</exception>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileProviderSystem.Observe(System.String,System.IObserver{Lexical.FileSystem.IEvent},System.Object,Lexical.FileSystem.IEventDispatcher,Lexical.FileSystem.IOption)">
            <summary>
            Attach an <paramref name="observer"/> on to a single file or directory. 
            Observing a directory will observe the whole subtree.
            
            WARNING: The Observe implementation browses the subtree of the watched directory path in order to create delta of changes.
            </summary>
            <param name="filter">path to file or directory. The directory separator is "/". The root is without preceding slash "", e.g. "dir/dir2"</param>
            <param name="observer"></param>
            <param name="state">(optional) </param>
            <param name="eventDispatcher">(optional) event dispatcher</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns>dispose handle</returns>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="filter"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="filter"/> contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support observe</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters.</exception>
            <exception cref="T:System.InvalidOperationException">If <paramref name="filter"/> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc.</exception>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="T:Lexical.FileSystem.Decoration.FileProviderSystem.FileObserver">
            <summary>
            Single file observer.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.FileProviderSystem.FileObserver.FileProvider">
            <summary>
            Filesystem
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.FileProviderSystem.FileObserver.previousEntry">
            <summary>
            Previous state of the file.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.FileProviderSystem.FileObserver.changeToken">
            <summary>
            Change token
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.FileProviderSystem.FileObserver.watcher">
            <summary>
            Change token callback handle.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.FileProviderSystem.FileObserver.startTime">
            <summary>Time when observing started.</summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.FileProviderSystem.FileObserver.option">
            <summary></summary>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileProviderSystem.FileObserver.ToString">
            <summary>
            Print info
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileProviderSystem.FileObserver.#ctor(Lexical.FileSystem.IFileSystem,System.String,System.IObserver{Lexical.FileSystem.IEvent},System.Object,Lexical.FileSystem.IEventDispatcher,Lexical.FileSystem.IOption)">
            <summary>
            Create observer for one file.
            </summary>
            <param name="filesystem"></param>
            <param name="path"></param>
            <param name="observer"></param>
            <param name="state"></param>
            <param name="eventDispatcher">(optional)</param>
            <param name="option">(optional)</param>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileProviderSystem.FileObserver.OnEvent(System.Object)">
            <summary>
            Forward event
            </summary>
            <param name="sender"></param>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileProviderSystem.FileObserver.InnerDispose(Lexical.FileSystem.Internal.StructList4{System.Exception}@)">
            <summary>
            Dispose observer
            </summary>
        </member>
        <member name="T:Lexical.FileSystem.Decoration.FileProviderSystem.PatternObserver">
            <summary>
            Observer that monitors a range of files with glob pattern.
            
            Since <see cref="T:Microsoft.Extensions.FileProviders.IFileProvider"/> doesn't provide information about what was changed,
            this observer implementation reads a whole snapshot of the whole file provider, in 
            order to determine the changes.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.FileProviderSystem.PatternObserver.FileProvider">
            <summary>
            Filesystem
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.FileProviderSystem.PatternObserver.previousEntries">
            <summary>
            Previous state of file existing.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.FileProviderSystem.PatternObserver.changeToken">
            <summary>
            Change token
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.FileProviderSystem.PatternObserver.watcher">
            <summary>
            Change token handle
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.FileProviderSystem.PatternObserver.previousSnapshot">
            <summary>
            Previous snapshot of detected dirs and files
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.FileProviderSystem.PatternObserver.startTime">
            <summary>Time when observing started.</summary>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileProviderSystem.PatternObserver.#ctor(Lexical.FileSystem.IFileSystem,Lexical.FileSystem.Internal.GlobPatternInfo,System.IObserver{Lexical.FileSystem.IEvent},System.Object,Lexical.FileSystem.IEventDispatcher)">
            <summary>
            Create observer for one file.
            </summary>
            <param name="filesystem"></param>
            <param name="patternInfo"></param>
            <param name="observer"></param>
            <param name="state"></param>
            <param name="eventDispatcher"></param>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileProviderSystem.PatternObserver.ReadSnapshot">
            <summary>
            Read a snapshot of files and folders that match filter.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileProviderSystem.PatternObserver.OnEvent(System.Object)">
            <summary>
            Forward event
            </summary>
            <param name="sender"></param>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileProviderSystem.PatternObserver.InnerDispose(Lexical.FileSystem.Internal.StructList4{System.Exception}@)">
            <summary>
            Dispose observer
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileProviderSystem.AddSourceToBeDisposed">
            <summary>
            Add the source <see cref="T:Microsoft.Extensions.FileProviders.IFileProvider"/> instance to be disposed along with this decoration.
            </summary>
            <returns>self</returns>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileProviderSystem.AddDisposeAction(System.Action{Lexical.FileSystem.Decoration.FileProviderSystem})">
            <summary>
            Invoke <paramref name="disposeAction"/> on the dispose of the object.
            
            If parent object is disposed or being disposed, the disposable will be disposed immedialy.
            </summary>
            <param name="disposeAction"></param>
            <returns>filesystem</returns>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileProviderSystem.AddDisposeAction(System.Action{System.Object},System.Object)">
            <summary>
            Invoke <paramref name="disposeAction"/> on the dispose of the object.
            
            If parent object is disposed or being disposed, the disposable will be disposed immedialy.
            </summary>
            <param name="disposeAction"></param>
            <param name="state"></param>
            <returns>self</returns>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileProviderSystem.AddDisposable(System.Object)">
            <summary>
            Add <paramref name="disposable"/> to list of objects to be disposed along with the system.
            </summary>
            <param name="disposable"></param>
            <returns>filesystem</returns>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileProviderSystem.AddDisposables(System.Collections.IEnumerable)">
            <summary>
            Add <paramref name="disposables"/> to list of objects to be disposed along with the system.
            </summary>
            <param name="disposables"></param>
            <returns>filesystem</returns>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileProviderSystem.RemoveDisposable(System.Object)">
            <summary>
            Remove <paramref name="disposable"/> from dispose list.
            </summary>
            <param name="disposable"></param>
            <returns>filesystem</returns>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileProviderSystem.RemoveDisposables(System.Collections.IEnumerable)">
            <summary>
            Remove <paramref name="disposables"/> from dispose list.
            </summary>
            <param name="disposables"></param>
            <returns>filesystem</returns>
        </member>
        <member name="T:Lexical.FileSystem.Decoration.FileSystemProvider">
            <summary>
            Adapts <see cref="T:Lexical.FileSystem.IFileSystem"/> into <see cref="T:Microsoft.Extensions.FileProviders.IFileProvider"/>.
            
            The recommended way to create <see cref="T:Lexical.FileSystem.Decoration.FileSystemProvider"/> is to use
            the extension method in <see cref="M:Lexical.FileSystem.FileProviderExtensions.ToFileProvider(Lexical.FileSystem.IFileSystem)"/>.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.FileSystemProvider.FileSystem">
            <summary>
            Source filesystem
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.FileSystemProvider.FileSystemDisposable">
            <summary>
            Source filesystem casted to <see cref="T:System.IDisposable"/>. Value is null if <see cref="P:Lexical.FileSystem.Decoration.FileSystemProvider.FileSystem"/> doesn't implement <see cref="T:System.IDisposable"/>.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.FileSystemProvider.token">
            <summary>
            (optional) filesystem implementation specific token, such as session, security token or credential. Used for authorizing or facilitating the action.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.FileSystemProvider.options">
            <summary>
            Options all
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileSystemProvider.#ctor(Lexical.FileSystem.IFileSystem,Lexical.FileSystem.IOption)">
            <summary>
            Create adapter that adapts <paramref name="sourceFilesystem"/> into <see cref="T:Microsoft.Extensions.FileProviders.IFileProvider"/>.
            </summary>
            <param name="sourceFilesystem"></param>
            <param name="option">(optional) decorating options, such as <see cref="T:Lexical.FileSystem.IToken"/></param>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileSystemProvider.GetDirectoryContents(System.String)">
            <summary>
            Get directory contents.
            </summary>
            <param name="subpath"></param>
            <returns>Directory contents</returns>
        </member>
        <member name="T:Lexical.FileSystem.Decoration.FileSystemProvider.DirectoryContents">
            <summary>
            Directory contents
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.FileSystemProvider.DirectoryContents.Entries">
            <summary>
            Snapshot of directory entries
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.FileSystemProvider.DirectoryContents.Exists">
            <summary>
            Directory exists
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileSystemProvider.DirectoryContents.#ctor(Microsoft.Extensions.FileProviders.IFileInfo[])">
            <summary>
            Create directory contents.
            </summary>
            <param name="entries"></param>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileSystemProvider.DirectoryContents.GetEnumerator">
            <summary>
            Enumerate file infos.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileSystemProvider.DirectoryContents.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Enumerate file infos.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileSystemProvider.GetFileInfo(System.String)">
            <summary>
            Locate a file at the given path.
            </summary>
            <param name="subpath">Relative path that identifies the file.</param>
            <returns>The file information. Caller must check Exists property.</returns>
        </member>
        <member name="T:Lexical.FileSystem.Decoration.FileSystemProvider.FileInfo">
            <summary>
            Adapts <see cref="T:Lexical.FileSystem.IEntry"/> to <see cref="T:Microsoft.Extensions.FileProviders.IFileInfo"/>.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.FileSystemProvider.FileInfo.Entry">
            <summary>Entry from filesystem.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.FileSystemProvider.FileInfo.FileSystem">
            <summary>Associated filesystem.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.FileSystemProvider.FileInfo.Exists">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.FileSystemProvider.FileInfo.Length">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.FileSystemProvider.FileInfo.PhysicalPath">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.FileSystemProvider.FileInfo.Name">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.FileSystemProvider.FileInfo.LastModified">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.FileSystemProvider.FileInfo.IsDirectory">
            <inheritdoc/>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.FileSystemProvider.FileInfo.options">
            <summary>
            Enabled features
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.FileSystemProvider.FileInfo.token">
            <summary>
            Token.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileSystemProvider.FileInfo.#ctor(Lexical.FileSystem.IFileSystem,Lexical.FileSystem.IEntry,Lexical.FileSystem.IOption,Lexical.FileSystem.IToken)">
            <summary>
            Create <see cref="T:Microsoft.Extensions.FileProviders.IFileInfo"/> from <paramref name="entry"/>.
            </summary>
            <param name="filesystem"></param>
            <param name="entry"></param>
            <param name="options">(optional) options</param>
            <param name="token">(optional)</param>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileSystemProvider.FileInfo.CreateReadStream">
            <inheritdoc/>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileSystemProvider.Watch(System.String)">
            <summary>
            Enumerate a directory at the given path, if any.
            </summary>
            <param name="filter">Relative path that identifies the directory.</param>
            <returns>Returns the contents of the directory.</returns>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.FileSystemProvider.WatchToken.HasChanged">
            <summary>
            Has there been change.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.FileSystemProvider.WatchToken.ActiveChangeCallbacks">
            <summary>
            Is RegisterChangeCallback supported
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.FileSystemProvider.WatchToken.observerHandle">
            <summary>
            Reference to observer handle
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.FileSystemProvider.WatchToken.callbacks">
            <summary>
            Registered callbacks.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.FileSystemProvider.WatchToken.closed">
            <summary>
            Is closed
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileSystemProvider.WatchToken.System#IObserver{Lexical#FileSystem#IEvent}#OnCompleted">
            <summary>
            File system ends observer.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileSystemProvider.WatchToken.System#IObserver{Lexical#FileSystem#IEvent}#OnError(System.Exception)">
            <summary>
            File system has an internal error
            </summary>
            <param name="error"></param>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileSystemProvider.WatchToken.System#IObserver{Lexical#FileSystem#IEvent}#OnNext(Lexical.FileSystem.IEvent)">
            <summary>
            Process event.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileSystemProvider.WatchToken.CallbackHandle.RunAction">
            <summary>
            Runs the associated action and clears references.
            Action can be ran by only one thread.
            Action is not ran if <see cref="M:Lexical.FileSystem.Decoration.FileSystemProvider.WatchToken.CallbackHandle.Dispose"/> has been called.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileSystemProvider.WatchToken.CallbackHandle.Dispose">
            <summary>
            Dispose handle. This will prevent action being called.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileSystemProvider.AddSourceToBeDisposed">
            <summary>
            Add the source <see cref="T:Lexical.FileSystem.IFileSystem"/> instance to be disposed along with this decoration.
            </summary>
            <returns>self</returns>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileSystemProvider.AddDisposeAction(System.Action{Lexical.FileSystem.Decoration.FileSystemProvider})">
            <summary>
            Invoke <paramref name="disposeAction"/> on the dispose of the object.
            
            If parent object is disposed or being disposed, the disposable will be disposed immedialy.
            </summary>
            <param name="disposeAction"></param>
            <returns>filesystem</returns>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileSystemProvider.AddDisposeAction(System.Action{System.Object},System.Object)">
            <summary>
            Invoke <paramref name="disposeAction"/> on the dispose of the object.
            
            If parent object is disposed or being disposed, the disposable will be disposed immedialy.
            </summary>
            <param name="disposeAction"></param>
            <param name="state"></param>
            <returns>self</returns>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileSystemProvider.AddDisposable(System.Object)">
            <summary>
            Add <paramref name="disposable"/> to list of objects to be disposed along with the system.
            </summary>
            <param name="disposable"></param>
            <returns>self</returns>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileSystemProvider.AddDisposables(System.Collections.IEnumerable)">
            <summary>
            Add <paramref name="disposables"/> to list of objects to be disposed along with the system.
            </summary>
            <param name="disposables"></param>
            <returns>self</returns>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileSystemProvider.RemoveDisposable(System.Object)">
            <summary>
            Remove <paramref name="disposable"/> from dispose list.
            </summary>
            <param name="disposable"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileSystemProvider.RemoveDisposables(System.Collections.IEnumerable)">
            <summary>
            Remove <paramref name="disposables"/> from dispose list.
            </summary>
            <param name="disposables"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileSystemProvider.ToString">
            <summary>
            Print info
            </summary>
            <returns></returns>
        </member>
        <member name="T:Lexical.FileSystem.Decoration.FileSystemDecoration">
            <summary>
            <see cref="T:Lexical.FileSystem.IFileSystem"/> decoration.
            
            Supports following decorating modifications:
            <list type="bullet">
                <item><see cref="T:Lexical.FileSystem.IBrowseOption"/> </item>
                <item><see cref="T:Lexical.FileSystem.IObserveOption"/> </item>
                <item><see cref="T:Lexical.FileSystem.IOpenOption"/> </item>
                <item><see cref="T:Lexical.FileSystem.IDeleteOption"/> </item>
                <item><see cref="T:Lexical.FileSystem.IMoveOption"/> </item>
                <item><see cref="T:Lexical.FileSystem.ICreateDirectoryOption"/> </item>
                <item><see cref="T:Lexical.FileSystem.IMountOption"/> </item>
                <item><see cref="T:Lexical.FileSystem.ISubPathOption"/> </item>
            </list>
            
            See extension methods in <see cref="T:Lexical.FileSystem.FileSystemExtensions"/> to create decorations, or use <see cref="T:Lexical.FileSystem.VirtualFileSystem"/>.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.FileSystemDecoration.components">
            <summary>FileSystem specific components.</summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.FileSystemDecoration.Option">
            <summary>Union of options.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.FileSystemDecoration.Count">
            <summary>Count</summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.FileSystemDecoration.Decorees">
            <summary>The decorated filesystems.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.FileSystemDecoration.DisposableDecorees">
            <summary><see cref="T:Lexical.FileSystem.IFileSystem"/> casted to <see cref="T:System.IDisposable"/>.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.FileSystemDecoration.CaseSensitivity">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.FileSystemDecoration.EmptyDirectoryName">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.FileSystemDecoration.CanBrowse">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.FileSystemDecoration.CanGetEntry">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.FileSystemDecoration.CanObserve">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.FileSystemDecoration.CanOpen">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.FileSystemDecoration.CanRead">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.FileSystemDecoration.CanWrite">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.FileSystemDecoration.CanCreateFile">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.FileSystemDecoration.CanDelete">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.FileSystemDecoration.CanMove">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.FileSystemDecoration.CanCreateDirectory">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.FileSystemDecoration.CanMount">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.FileSystemDecoration.CanUnmount">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.FileSystemDecoration.CanListMountPoints">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.FileSystemDecoration.CanSetFileAttribute">
            <inheritdoc/>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.FileSystemDecoration.rootEntry">
            <summary>
            Root entry
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.FileSystemDecoration.sourceFileSystem">
            <summary>
            The <see cref="T:Lexical.FileSystem.IFileSystem"/> reference that is passed to the decorated
            <see cref="T:Lexical.FileSystem.IEntry"/> instances that this class creates.
            
            Usually it is the <see cref="T:Lexical.FileSystem.Decoration.FileSystemDecoration"/> itself, but if this class
            is used as a component, such as <see cref="T:Lexical.FileSystem.VirtualFileSystem"/> does, then
            returns the parent filesystem.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.FileSystemDecoration.assignments">
            <summary>
            Assignments
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileSystemDecoration.#ctor(Lexical.FileSystem.IFileSystem,System.String,Lexical.FileSystem.FileSystemAssignment[])">
            <summary>
            Create composition of filesystems.
            
            A constructor version that exposes its filesystem at a subpath parentPath. 
            Also allows to configure what filesystem instance is exposed on decorated file entries and events.
            </summary>
            <param name="parentFileSystem">(optional) the <see cref="T:Lexical.FileSystem.IFileSystem"/> reference to use in the decorated <see cref="T:Lexical.FileSystem.IEntry"/> that this class returns</param>
            <param name="parentPath">(optional) path in parent filesyste, use "" if there is no parent filesystem (vfs)</param>
            <param name="assignments"></param>
        </member>
        <member name="T:Lexical.FileSystem.Decoration.FileSystemDecoration.Component">
            <summary>FileSystem (as component of composition) specific information</summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.FileSystemDecoration.Component.Assignment">
            <summary>FileSystem and option assignment</summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.FileSystemDecoration.Component.FileSystem">
            <summary>FileSystem component</summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.FileSystemDecoration.Component.Options">
            <summary>Intersection of option in <see cref="P:Lexical.FileSystem.Decoration.FileSystemDecoration.Component.FileSystem"/> and option that was provided in constructor.</summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.FileSystemDecoration.Component.UnknownOptions">
            <summary>Intersection of option in <see cref="P:Lexical.FileSystem.Decoration.FileSystemDecoration.Component.FileSystem"/> and option that was provided in constructor.</summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.FileSystemDecoration.Component.Path">
            <summary>Tool that converts paths.</summary>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileSystemDecoration.Component.#ctor(System.String,Lexical.FileSystem.FileSystemAssignment)">
            <summary>Create component info.</summary>
            <param name="parentPath">The subpath the filesystem starts at</param>
            <param name="assignment">filesystem and option</param>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileSystemDecoration.Component.#ctor(System.String,Lexical.FileSystem.FileSystemAssignment,Lexical.FileSystem.Decoration.AllOptions)">
            <summary>Create component info.</summary>
            <param name="parentPath">The subpath the filesystem starts at</param>
            <param name="assignment">filesystem and option</param>
            <param name="option">consolidated options</param>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.FileSystemDecoration.componentTupleComparer">
            <summary>Comparer that <see cref="M:Lexical.FileSystem.Decoration.FileSystemDecoration.SetComponents(Lexical.FileSystem.Internal.StructList2{Lexical.FileSystem.Decoration.FileSystemDecoration.Component}@,Lexical.FileSystem.Internal.StructList2{Lexical.FileSystem.Decoration.FileSystemDecoration.Component}@,Lexical.FileSystem.Internal.StructList2{Lexical.FileSystem.Decoration.FileSystemDecoration.Component}@,System.String,Lexical.FileSystem.FileSystemAssignment[])"/> uses.</summary>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileSystemDecoration.SetComponents(Lexical.FileSystem.Internal.StructList2{Lexical.FileSystem.Decoration.FileSystemDecoration.Component}@,Lexical.FileSystem.Internal.StructList2{Lexical.FileSystem.Decoration.FileSystemDecoration.Component}@,Lexical.FileSystem.Internal.StructList2{Lexical.FileSystem.Decoration.FileSystemDecoration.Component}@,System.String,Lexical.FileSystem.FileSystemAssignment[])">
            <summary>
            Set new list components. Recycles previous components if path, filesystem and option matches.
            </summary>
            <param name="componentsAdded">list of components added</param>
            <param name="componentsRemoved">list of components removed</param>
            <param name="componentsReused">list of previous components that were reused</param>
            <param name="parentPath">Path in parent (vfs) filesystem, "" if there is vfs</param>
            <param name="assignments"></param>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileSystemDecoration.Browse(System.String,Lexical.FileSystem.IOption)">
            <summary>
            Browse a directory for file and subdirectory entries.
            </summary>
            <param name="path">path to directory, "" is root, separator is "/"</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns>a snapshot of file and directory entries</returns>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.IO.DirectoryNotFoundException">The specified path is invalid, such as being on an unmapped drive.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support browse</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters.</exception>
            <exception cref="T:System.InvalidOperationException">If <paramref name="path"/> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc.</exception>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileSystemDecoration.GetEntry(System.String,Lexical.FileSystem.IOption)">
            <summary>
            Get entry of a single file or directory.
            </summary>
            <param name="path">path to a directory or to a single file, "" is root, separator is "/"</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns>entry, or null if entry is not found</returns>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support exists</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters.</exception>
            <exception cref="T:System.InvalidOperationException">If <paramref name="path"/> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc.</exception>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileSystemDecoration.Open(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,Lexical.FileSystem.IOption)">
            <summary>
            Open a file for reading and/or writing. File can be created when <paramref name="fileMode"/> is <see cref="F:System.IO.FileMode.Create"/> or <see cref="F:System.IO.FileMode.CreateNew"/>.
            </summary>
            <param name="path">Relative path to file. Directory separator is "/". Root is without preceding "/", e.g. "dir/file.xml"</param>
            <param name="fileMode">determines whether to open or to create the file</param>
            <param name="fileAccess">how to access the file, read, write or read and write</param>
            <param name="fileShare">how the file will be shared by processes</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns>open file stream</returns>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> is an empty string (""), contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support opening files</exception>
            <exception cref="T:System.IO.FileNotFoundException">The file cannot be found, such as when mode is FileMode.Truncate or FileMode.Open, and and the file specified by path does not exist. The file must already exist in these modes.</exception>
            <exception cref="T:System.IO.DirectoryNotFoundException">The specified path is invalid, such as being on an unmapped drive.</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="fileMode"/>, <paramref name="fileAccess"/> or <paramref name="fileShare"/> contains an invalid value.</exception>
            <exception cref="T:System.InvalidOperationException">If <paramref name="path"/> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc.</exception>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileSystemDecoration.Delete(System.String,System.Boolean,Lexical.FileSystem.IOption)">
            <summary>
            Delete a file or directory.
            
            If <paramref name="recurse"/> is false and <paramref name="path"/> is a directory that is not empty, then <see cref="T:System.IO.IOException"/> is thrown.
            If <paramref name="recurse"/> is true, then any file or directory within <paramref name="path"/> is deleted as well.
            </summary>
            <param name="path">path to a file or directory</param>
            <param name="recurse">if path refers to directory, recurse into sub directories</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <exception cref="T:System.IO.FileNotFoundException">The specified path is invalid.</exception>
            <exception cref="T:System.IO.IOException">On unexpected IO error, or if <paramref name="path"/> refered to a directory that wasn't empty and <paramref name="recurse"/> is false</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> is an empty string (""), contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support deleting files</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters.</exception>
            <exception cref="T:System.InvalidOperationException"><paramref name="path"/> refers to non-file device</exception>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileSystemDecoration.SetFileAttribute(System.String,System.IO.FileAttributes,Lexical.FileSystem.IOption)">
            <summary>
            Set <paramref name="fileAttribute"/> on <paramref name="path"/>.
            </summary>
            <param name="path"></param>
            <param name="fileAttribute"></param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <exception cref="T:System.IO.FileNotFoundException"><paramref name="path"/> is not found</exception>
            <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path"/> is invalid. For example, it's on an unmapped drive. Only thrown when setting the property value.</exception>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support browse</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters.</exception>
            <exception cref="T:System.InvalidOperationException">If <paramref name="path"/> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc.</exception>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileSystemDecoration.Move(System.String,System.String,Lexical.FileSystem.IOption)">
            <summary>
            Try to move/rename a file or directory.
            </summary>
            <param name="srcPath">old path of a file or directory</param>
            <param name="dstPath">new path of a file or directory</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <exception cref="T:System.IO.FileNotFoundException">The specified <paramref name="srcPath"/> is invalid.</exception>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.IO.FileNotFoundException">The specified path is invalid.</exception>
            <exception cref="T:System.ArgumentNullException">path is null</exception>
            <exception cref="T:System.ArgumentException">path is an empty string (""), contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support renaming/moving files</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters.</exception>
            <exception cref="T:System.InvalidOperationException">path refers to non-file device, or an entry already exists at <paramref name="dstPath"/></exception>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileSystemDecoration.CreateDirectory(System.String,Lexical.FileSystem.IOption)">
            <summary>
            Create a directory, or multiple cascading directories.
            
            If directory at <paramref name="path"/> already exists, then returns without exception.
            </summary>
            <param name="path">Relative path to file. Directory separator is "/". The root is without preceding slash "", e.g. "dir/dir2"</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns>true if directory exists after the method, false if directory doesn't exist</returns>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.IO.DirectoryNotFoundException">The specified path is invalid, such as being on an unmapped drive.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> is an empty string (""), contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support create directory</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters.</exception>
            <exception cref="T:System.InvalidOperationException">If <paramref name="path"/> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc.</exception>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileSystemDecoration.Mount(System.String,Lexical.FileSystem.FileSystemAssignment[],Lexical.FileSystem.IOption)">
            <inheritdoc/>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileSystemDecoration.Unmount(System.String,Lexical.FileSystem.IOption)">
            <summary>
            Unmount a filesystem at <paramref name="path"/>.
            
            If there is no mount at <paramref name="path"/>, then does nothing.
            If there is an open stream to previously mounted filesystem, that stream is unlinked from the filesystem.
            </summary>
            <param name="path"></param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns>this (parent filesystem)</returns>
            <exception cref="T:System.NotSupportedException">If operation is not supported</exception>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileSystemDecoration.ListMountPoints(Lexical.FileSystem.IOption)">
            <summary>
            List all mounts.
            </summary>
            <returns></returns>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <exception cref="T:System.NotSupportedException">If operation is not supported</exception>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileSystemDecoration.Observe(System.String,System.IObserver{Lexical.FileSystem.IEvent},System.Object,Lexical.FileSystem.IEventDispatcher,Lexical.FileSystem.IOption)">
            <summary>
            Attach an <paramref name="observer"/> on to a single file or directory. 
            Observing a directory will observe the whole subtree.
            </summary>
            <param name="filter">path to file or directory. The directory separator is "/". The root is without preceding slash "", e.g. "dir/dir2"</param>
            <param name="observer"></param>
            <param name="state">(optional) </param>
            <param name="eventDispatcher">(optional) event dispatcher</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns>dispose handle</returns>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="filter"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="filter"/> contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support observe</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters.</exception>
            <exception cref="T:System.InvalidOperationException">If <paramref name="filter"/> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc.</exception>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileSystemDecoration.AddSourceToBeDisposed">
            <summary>
            Add source <see cref="T:Lexical.FileSystem.IFileSystem"/> instances to be disposed along with this decoration.
            
            Disposes only those assignments at the time of decoration's dispose.
            </summary>
            <returns>self</returns>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileSystemDecoration.AddDisposeAction(System.Action{Lexical.FileSystem.Decoration.FileSystemDecoration})">
            <summary>
            Invoke <paramref name="disposeAction"/> on the dispose of the object.
            
            If parent object is disposed or being disposed, the disposable will be disposed immedialy.
            </summary>
            <param name="disposeAction"></param>
            <returns>self</returns>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileSystemDecoration.AddDisposeAction(System.Action{System.Object},System.Object)">
            <summary>
            Invoke <paramref name="disposeAction"/> on the dispose of the object.
            
            If parent object is disposed or being disposed, the disposable will be disposed immedialy.
            </summary>
            <param name="disposeAction"></param>
            <param name="state"></param>
            <returns>self</returns>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileSystemDecoration.AddDisposable(System.Object)">
            <summary>
            Add <paramref name="disposable"/> to list of objects to be disposed along with the system.
            </summary>
            <param name="disposable"></param>
            <returns>filesystem</returns>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileSystemDecoration.AddDisposables(System.Collections.IEnumerable)">
            <summary>
            Add <paramref name="disposables"/> to list of objects to be disposed along with the system.
            </summary>
            <param name="disposables"></param>
            <returns>filesystem</returns>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileSystemDecoration.RemoveDisposable(System.Object)">
            <summary>
            Remove <paramref name="disposable"/> from dispose list.
            </summary>
            <param name="disposable"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileSystemDecoration.RemoveDisposables(System.Collections.IEnumerable)">
            <summary>
            Remove <paramref name="disposables"/> from dispose list.
            </summary>
            <param name="disposables"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileSystemDecoration.GetEnumerator">
            <summary>
            Get file systems
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileSystemDecoration.ToString">
            <summary>
            Print info
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileSystemDecoration.CreateEntry(Lexical.FileSystem.IEntry,Lexical.FileSystem.IFileSystem,System.String,Lexical.FileSystem.Decoration.AllOptions)">
            <summary>Override this to change entry class. Must implement <see cref="T:Lexical.FileSystem.IMountEntry"/></summary>
        </member>
        <member name="T:Lexical.FileSystem.Decoration.FileSystemDecoration.Entry">
            <summary>
            Decoration that offers modified Option. Creates option at runtime, if requested.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.FileSystemDecoration.Entry.newFileSystem">
            <summary>New overriding filesystem.</summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.FileSystemDecoration.Entry.newPath">
            <summary>New overriding path.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.FileSystemDecoration.Entry.FileSystem">
            <summary>New overriding filesystem.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.FileSystemDecoration.Entry.Path">
            <summary>New path.</summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.FileSystemDecoration.Entry.optionModifier">
            <summary>(optional) Option that will be intersected lazily with original options.</summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.FileSystemDecoration.Entry.optionIntersection">
            <summary>Lazily construction intersection of <see cref="F:Lexical.FileSystem.Decoration.FileSystemDecoration.Entry.optionModifier"/> and Original.Option()</summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.FileSystemDecoration.Entry.Options">
            <summary>Intersection of Original.Option() and <see cref="F:Lexical.FileSystem.Decoration.FileSystemDecoration.Entry.optionModifier"/></summary>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileSystemDecoration.Entry.#ctor(Lexical.FileSystem.IEntry,Lexical.FileSystem.IFileSystem,System.String,Lexical.FileSystem.Decoration.AllOptions)">
            <summary>
            Create decoration with <paramref name="newFileSystem"/>.
            </summary>
            <param name="original"></param>
            <param name="newFileSystem"></param>
            <param name="newPath"></param>
            <param name="optionModifier">(optional) option that will be applied to original option with intersection</param>
        </member>
        <member name="T:Lexical.FileSystem.Decoration.FileSystemDecoration.MountEntry">
            <summary>
            Decoration that offers modified option (inherited from <see cref="T:Lexical.FileSystem.Decoration.FileSystemDecoration.Entry"/>), and modified mounts.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.FileSystemDecoration.MountEntry.mounts">
            <summary>Mount infos.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.FileSystemDecoration.MountEntry.IsMountPoint">
            <summary></summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.FileSystemDecoration.MountEntry.Mounts">
            <summary></summary>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.FileSystemDecoration.MountEntry.#ctor(Lexical.FileSystem.IEntry,Lexical.FileSystem.IFileSystem,System.String,Lexical.FileSystem.Decoration.AllOptions,Lexical.FileSystem.FileSystemAssignment[])">
            <summary>
            Create decoration with <paramref name="newFileSystem"/>.
            </summary>
            <param name="original"></param>
            <param name="newFileSystem"></param>
            <param name="newPath"></param>
            <param name="mounts"></param>
            <param name="optionModifier">(optional) option that will be applied to original option with intersection</param>
        </member>
        <member name="T:Lexical.FileSystem.Decoration.ObserverDecoration">
            <summary>
            Decorates events of child <see cref="T:Lexical.FileSystem.IFileSystem"/> to parent <see cref="T:Lexical.FileSystem.IFileSystem"/>.
            
            When this object is disposed, it forwards <see cref="M:System.IObserver`1.OnCompleted"/> event.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.ObserverDecoration.FileSystem">
            <summary>Parent filesystem to use in decorated events.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.ObserverDecoration.Filter">
            <summary><see cref="T:Lexical.FileSystem.ISubPathOption"/> adapted path filter string.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.ObserverDecoration.Observer">
            <summary>The observer were decorated events are forwarded to.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.ObserverDecoration.State">
            <summary>The state object the Observe() caller provided.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.ObserverDecoration.Dispatcher">
            <summary>Event dispatcher</summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.ObserverDecoration.feedingObserverCount">
            <summary>
            Number of feeding observers. 
            This count is incremented when <see cref="T:Lexical.FileSystem.IStartEvent"/> event is sent, and decremented when <see cref="P:Lexical.FileSystem.IEvent.Observer"/> is sent.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.ObserverDecoration.disposeWhenLastCompletes">
            <summary>
            If true, when last attached observer sends <see cref="M:System.IObserver`1.OnCompleted"/> event, then this object is disposed.
            This mechanism works only if observer is implemented properly, so that is sends OnCompleted once and only once.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.ObserverDecoration.#ctor(Lexical.FileSystem.IFileSystem,System.String,System.IObserver{Lexical.FileSystem.IEvent},System.Object,Lexical.FileSystem.IEventDispatcher,System.Boolean)">
            <summary>
            Create adapter observer.
            </summary>
            <param name="sourceFileSystem">File system to show as the source of forwarded events (in <see cref="P:Lexical.FileSystem.IEvent.Observer"/>)</param>
            <param name="filter"></param>
            <param name="observer">The IObserver from caller were the decorated events are forwarded to</param>
            <param name="state"></param>
            <param name="eventDispatcher">event dispatcher to show on the interface, doesn't use it</param>
            <param name="disposeWhenLastCompletes">if true, when last attached observer sends <see cref="M:System.IObserver`1.OnCompleted"/> event, 
            then diposes this object and sends <see cref="M:System.IObserver`1.OnCompleted"/> to <see cref="P:Lexical.FileSystem.Decoration.ObserverDecoration.Observer"/>.</param>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.ObserverDecoration.OnCompleted">
            <summary>child observer completes</summary>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.ObserverDecoration.OnError(System.Exception)">
            <summary>Child observer has error</summary>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.ObserverDecoration.OnNext(Lexical.FileSystem.IEvent)">
            <summary>Forward OnNext</summary>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.ObserverDecoration.InnerDispose(Lexical.FileSystem.Internal.StructList4{System.Exception}@)">
            <summary>
            Handle dispose, forwards OnCompleted event.
            </summary>
            <param name="disposeErrors"></param>
        </member>
        <member name="T:Lexical.FileSystem.Decoration.ObserverDecoration.StateInfo">
            <summary>
            State object to supply to child filesystem (decoree) on .Observe() method.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.ObserverDecoration.StateInfo.pathConverter">
            <summary>Path converter</summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.ObserverDecoration.StateInfo.state">
            <summary>3rd party object</summary>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.ObserverDecoration.StateInfo.#ctor(Lexical.FileSystem.IPathConverter,System.Object)">
            <summary>
            Create state info.
            </summary>
            <param name="pathConverter"></param>
            <param name="state"></param>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.ObserverDecoration.ToString">
            <summary>Print info</summary>
        </member>
        <member name="T:Lexical.FileSystem.Decoration.AllOptions">
            <summary>Class that implements all options except <see cref="T:Lexical.FileSystem.IToken"/>.</summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.AllOptions.Types">
            <summary>Contained interface types.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.AllOptions.CanBrowse">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.AllOptions.CanGetEntry">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.AllOptions.CanObserve">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.AllOptions.CanOpen">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.AllOptions.CanRead">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.AllOptions.CanWrite">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.AllOptions.CanCreateFile">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.AllOptions.CanDelete">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.AllOptions.CanMove">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.AllOptions.CanCreateDirectory">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.AllOptions.CanMount">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.AllOptions.CanUnmount">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.AllOptions.CanListMountPoints">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.AllOptions.CaseSensitivity">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.AllOptions.EmptyDirectoryName">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.AllOptions.SubPath">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Decoration.AllOptions.CanSetFileAttribute">
            <inheritdoc/>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.AllOptions.Read(Lexical.FileSystem.IOption)">
            <summary>
            Read options from <paramref name="option"/> and return flattened object.
            </summary>
            <param name="option"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.AllOptions.ReadFrom(Lexical.FileSystem.IOption)">
            <summary>
            Read options from <paramref name="option"/> and return flattened object.
            </summary>
            <param name="option"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.AllOptions.Intersection(Lexical.FileSystem.IOption)">
            <summary>
            Create intersection with another option
            </summary>
            <param name="option"></param>
            <returns>this if <paramref name="option"/> is null or new instance with intersection</returns>
        </member>
        <member name="T:Lexical.FileSystem.Decoration.AllOptionsAndTokens">
            <summary>
            Options with tokens
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Decoration.AllOptionsAndTokens.tokens">
            <summary>Tokens</summary>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.AllOptionsAndTokens.Read(Lexical.FileSystem.IOption)">
            <summary>
            Read options from <paramref name="option"/> and return flattened object.
            </summary>
            <param name="option"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.AllOptionsAndTokens.ReadFrom(Lexical.FileSystem.IOption)">
            <summary>
            Read options from <paramref name="option"/> and return flattened object.
            </summary>
            <param name="option"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Decoration.AllOptionsAndTokens.GetEnumerator">
            <summary>Get enumerator</summary>
        </member>
        <member name="T:Lexical.FileSystem.EventBase">
            <summary>
            Base implementation to <see cref="T:Lexical.FileSystem.IEvent"/> classes.
            
            See sub-classes:
            <list type="bullet">
                <item><see cref="T:Lexical.FileSystem.RenameEvent"/></item>
                <item><see cref="T:Lexical.FileSystem.CreateEvent"/></item>
                <item><see cref="T:Lexical.FileSystem.ChangeEvent"/></item>
                <item><see cref="T:Lexical.FileSystem.DeleteEvent"/></item>
                <item><see cref="T:Lexical.FileSystem.ErrorEvent"/></item>
                <item><see cref="T:Lexical.FileSystem.StartEvent"/></item>
            </list>
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.EventBase.Observer">
            <summary>
            The filesystem observer that sent the event.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.EventBase.EventTime">
            <summary>
            The time the event occured, or approximation if not exactly known.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.EventBase.Path">
            <summary>
            (optional) Affected entry if applicable.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.EventBase.#ctor(Lexical.FileSystem.IFileSystemObserver,System.DateTimeOffset,System.String)">
            <summary>
            Create event.
            </summary>
            <param name="observer"></param>
            <param name="eventTime"></param>
            <param name="path"></param>
        </member>
        <member name="M:Lexical.FileSystem.EventBase.ToString">
            <summary>Print info</summary>
            <returns>Info</returns>
        </member>
        <member name="T:Lexical.FileSystem.IEventDispatcherExtended">
            <summary>Dispatches <see cref="T:Lexical.FileSystem.IEvent"/>s.</summary>
        </member>
        <member name="M:Lexical.FileSystem.IEventDispatcherExtended.DispatchEvents(Lexical.FileSystem.Internal.StructList12{Lexical.FileSystem.IEvent}@)">
            <summary>
            Send <paramref name="events"/> to observers>.
            </summary>
            <param name="events">events</param>
            <exception cref="T:System.Exception">Any exception from observer may be captured or passed to caller</exception>
        </member>
        <member name="T:Lexical.FileSystem.EventDispatcher">
            <summary>
            Dispatches events on API caller's current thread.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.EventDispatcher.Instance">
            <summary>Singleton instance </summary>
        </member>
        <member name="F:Lexical.FileSystem.EventDispatcher.errorHandler">
            <summary>
            (optional) Error handler;
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.EventDispatcher.#ctor(System.Action{Lexical.FileSystem.IEventDispatcher,Lexical.FileSystem.IEvent,System.Exception})">
            <summary>
            Create event dispatcher that dispatches events in the API caller's thread.
            </summary>
            <param name="errorHandler"></param>
        </member>
        <member name="M:Lexical.FileSystem.EventDispatcher.DispatchEvent(Lexical.FileSystem.IEvent)">
            <summary>Dispatch <paramref name="event"/></summary>
            <param name="event"></param>
        </member>
        <member name="M:Lexical.FileSystem.EventDispatcher.DispatchEvents(Lexical.FileSystem.Internal.StructList12{Lexical.FileSystem.IEvent}@)">
            <summary>Dispatch <paramref name="events"/></summary>
            <param name="events"></param>
        </member>
        <member name="M:Lexical.FileSystem.EventDispatcher.DispatchEvents(System.Collections.Generic.IEnumerable{Lexical.FileSystem.IEvent})">
            <summary>Dispatch <paramref name="events"/></summary>
            <param name="events"></param>
        </member>
        <member name="T:Lexical.FileSystem.EventTaskDispatcher">
            <summary>
            Dispatches events in concurrent tasks.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.EventTaskDispatcher.Instance">
            <summary>Singleton instance </summary>
        </member>
        <member name="F:Lexical.FileSystem.EventTaskDispatcher.taskFactory">
            <summary>
            Task-factory that is used for sending events.
            If factory is set to null, then events are processed in the current thread.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.EventTaskDispatcher.processEventsAction">
            <summary>Delegate that processes events</summary>
        </member>
        <member name="F:Lexical.FileSystem.EventTaskDispatcher.errorHandler">
            <summary>
            (optional) Error handler;
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.EventTaskDispatcher.#ctor(System.Threading.Tasks.TaskFactory,System.Action{Lexical.FileSystem.IEventDispatcher,Lexical.FileSystem.IEvent,System.Exception})">
            <summary>
            Create event dispatcher that uses task factory.
            </summary>
            <param name="taskFactory">(optional) task factory</param>
            <param name="errorHandler">(optional) error handler</param>
        </member>
        <member name="M:Lexical.FileSystem.EventTaskDispatcher.DispatchEvent(Lexical.FileSystem.IEvent)">
            <summary>Dispatch <paramref name="event"/></summary>
            <param name="event"></param>
        </member>
        <member name="M:Lexical.FileSystem.EventTaskDispatcher.DispatchEvents(Lexical.FileSystem.Internal.StructList12{Lexical.FileSystem.IEvent}@)">
            <summary>Dispatch <paramref name="events"/></summary>
            <param name="events"></param>
        </member>
        <member name="M:Lexical.FileSystem.EventTaskDispatcher.DispatchEvents(System.Collections.Generic.IEnumerable{Lexical.FileSystem.IEvent})">
            <summary>Dispatch <paramref name="events"/></summary>
            <param name="events"></param>
        </member>
        <member name="M:Lexical.FileSystem.EventTaskDispatcher.processEvents(System.Object)">
            <summary>Forward events to observers.</summary>
            <param name="events">IEnumerable or <see cref="T:Lexical.FileSystem.IEvent"/></param>
        </member>
        <member name="T:Lexical.FileSystem.RenameEvent">
            <summary>
            File renamed event.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.RenameEvent.OldPath">
            <summary>
            The affected file or directory.
            
            Path is relative to the <see cref="T:Lexical.FileSystem.FileSystem"/>'s root.
            
            Directory separator is "/". Root path doesn't use separator.
            
            Example: "dir/file.ext"
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.RenameEvent.NewPath">
            <summary>
            The new file or directory path.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.RenameEvent.#ctor(Lexical.FileSystem.IFileSystemObserver,System.DateTimeOffset,System.String,System.String)">
            <summary>
            Create rename event.
            </summary>
            <param name="observer"></param>
            <param name="eventTime"></param>
            <param name="oldPath"></param>
            <param name="newPath"></param>
        </member>
        <member name="M:Lexical.FileSystem.RenameEvent.ToString">
            <summary>Print info</summary>
            <returns>Info</returns>
        </member>
        <member name="T:Lexical.FileSystem.CreateEvent">
            <summary>
            File created event
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.CreateEvent.#ctor(Lexical.FileSystem.IFileSystemObserver,System.DateTimeOffset,System.String)">
            <summary>
            Create create event.
            </summary>
            <param name="observer"></param>
            <param name="eventTime"></param>
            <param name="path"></param>
        </member>
        <member name="M:Lexical.FileSystem.CreateEvent.ToString">
            <summary>Print info</summary>
            <returns>Info</returns>
        </member>
        <member name="T:Lexical.FileSystem.ChangeEvent">
            <summary>
            File contents changed event
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.ChangeEvent.#ctor(Lexical.FileSystem.IFileSystemObserver,System.DateTimeOffset,System.String)">
            <summary>
            Create file contents changed event.
            </summary>
            <param name="observer"></param>
            <param name="eventTime"></param>
            <param name="path"></param>
        </member>
        <member name="M:Lexical.FileSystem.ChangeEvent.ToString">
            <summary>Print info</summary>
            <returns>Info</returns>
        </member>
        <member name="T:Lexical.FileSystem.DeleteEvent">
            <summary>
            File deleted event
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.DeleteEvent.#ctor(Lexical.FileSystem.IFileSystemObserver,System.DateTimeOffset,System.String)">
            <summary>
            Create file deleted event.
            </summary>
            <param name="observer"></param>
            <param name="eventTime"></param>
            <param name="path"></param>
        </member>
        <member name="M:Lexical.FileSystem.DeleteEvent.ToString">
            <summary>Print info</summary>
            <returns>Info</returns>
        </member>
        <member name="T:Lexical.FileSystem.ErrorEvent">
            <summary>
            Filesystem error event
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.ErrorEvent.Error">
            <summary>
            Error
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.ErrorEvent.#ctor(Lexical.FileSystem.IFileSystemObserver,System.DateTimeOffset,System.Exception,System.String)">
            <summary>
            Create Error event.
            </summary>
            <param name="observer"></param>
            <param name="eventTime"></param>
            <param name="error"></param>
            <param name="path">(optional)</param>
        </member>
        <member name="M:Lexical.FileSystem.ErrorEvent.ToString">
            <summary>Print info</summary>
            <returns>Info</returns>
        </member>
        <member name="T:Lexical.FileSystem.StartEvent">
            <summary>
            Filesystem observe started event.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.StartEvent.#ctor(Lexical.FileSystem.IFileSystemObserver,System.DateTimeOffset)">
            <summary>
            Create Error event.
            </summary>
            <param name="observer"></param>
            <param name="eventTime"></param>
        </member>
        <member name="M:Lexical.FileSystem.StartEvent.ToString">
            <summary>Print info</summary>
            <returns>Info</returns>
        </member>
        <member name="T:Lexical.FileSystem.MountEvent">
            <summary>
            The event when mountpoint is created or when assignments are changed when <see cref="M:Lexical.FileSystem.IFileSystemMount.Mount(System.String,Lexical.FileSystem.FileSystemAssignment[],Lexical.FileSystem.IOption)"/> is called.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.MountEvent.Assignments">
            <summary>(new) Assignment configuration at mountpoint</summary>
        </member>
        <member name="P:Lexical.FileSystem.MountEvent.Option">
            <summary>Mount option</summary>
        </member>
        <member name="M:Lexical.FileSystem.MountEvent.#ctor(Lexical.FileSystem.IFileSystemObserver,System.DateTimeOffset,System.String,Lexical.FileSystem.FileSystemAssignment[],Lexical.FileSystem.IOption)">
            <summary>
            Create Error event.
            </summary>
            <param name="observer"></param>
            <param name="eventTime"></param>
            <param name="mountpoint"></param>
            <param name="assignments"></param>
            <param name="option"></param>
        </member>
        <member name="M:Lexical.FileSystem.MountEvent.ToString">
            <summary>Print info</summary>
            <returns>Info</returns>
        </member>
        <member name="T:Lexical.FileSystem.UnmountEvent">
            <summary>
            The event when whole mountpoint is unmounted.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.UnmountEvent.#ctor(Lexical.FileSystem.IFileSystemObserver,System.DateTimeOffset,System.String)">
            <summary>
            Create Error event.
            </summary>
            <param name="observer"></param>
            <param name="eventTime"></param>
            <param name="mountpoint"></param>
        </member>
        <member name="M:Lexical.FileSystem.UnmountEvent.ToString">
            <summary>Print info</summary>
            <returns>Info</returns>
        </member>
        <member name="T:Lexical.FileSystem.FileProviderExtensions">
            <summary>
            Extension methods for <see cref="T:Microsoft.Extensions.FileProviders.IFileProvider"/>.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.FileProviderExtensions.ToFileSystem(Microsoft.Extensions.FileProviders.IFileProvider)">
            <summary>
            Adapt <paramref name="fileProvider"/> to <see cref="T:Lexical.FileSystem.IFileSystem"/>.
            
            WARNING: The Observe implementation browses the subtree of the watched directory path in order to create delta of changes.
            </summary>
            <param name="fileProvider"></param>
            <returns><see cref="T:Lexical.FileSystem.IFileSystem"/></returns>
        </member>
        <member name="M:Lexical.FileSystem.FileProviderExtensions.ToFileSystem(Microsoft.Extensions.FileProviders.IFileProvider,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Adapt <paramref name="fileProvider"/> to <see cref="T:Lexical.FileSystem.IFileSystem"/>.
            
            WARNING: The Observe implementation browses the subtree of the watched directory path in order to create delta of changes.
            </summary>
            <param name="fileProvider"></param>
            <param name="canBrowse"></param>
            <param name="canObserve"></param>
            <param name="canOpen"></param>
            <returns><see cref="T:Lexical.FileSystem.IFileSystem"/></returns>
        </member>
        <member name="M:Lexical.FileSystem.FileProviderExtensions.ToFileSystem(Microsoft.Extensions.FileProviders.IFileProvider,Lexical.FileSystem.IOption)">
            <summary>
            Adapt <paramref name="fileProvider"/> to <see cref="T:Lexical.FileSystem.IFileSystem"/>.
            
            WARNING: The Observe implementation browses the subtree of the watched directory path in order to create delta of changes.
            </summary>
            <param name="fileProvider"></param>
            <param name="option"></param>
            <returns><see cref="T:Lexical.FileSystem.IFileSystem"/></returns>
        </member>
        <member name="M:Lexical.FileSystem.FileProviderExtensions.ToFileProvider(Lexical.FileSystem.IFileSystem)">
            <summary>
            Adapt <paramref name="filesystem"/> to <see cref="T:Microsoft.Extensions.FileProviders.IFileProvider"/>.
            </summary>
            <param name="filesystem"></param>
            <returns><see cref="T:Microsoft.Extensions.FileProviders.IFileProvider"/></returns>
        </member>
        <member name="T:Lexical.FileSystem.FileSystem">
            <summary>
            Operating System based <see cref="T:Lexical.FileSystem.IFileSystem"/> implementation that uses normal files and directories.
            
            If file watchers have been created, and file system is disposed, then watchers will be disposed also. 
            <see cref="M:System.IObserver`1.OnCompleted"/> event is forwarded to watchers.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystem.PathPattern">
            <summary>
            Regex pattern that extracts features and classifies paths.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystem.osSeparator">
            <summary>
            Native separator character in the running OS.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystem.isWindows">
            <summary>
            Is OS Windows, Linux, or OSX.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystem.isLinux">
            <summary>
            Is OS Windows, Linux, or OSX.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystem.isOsx">
            <summary>
            Is OS Windows, Linux, or OSX.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystem.os">
            <summary>Operating system root.</summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystem.application">
            <summary>Running application's base directory.</summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystem.temp">
            <summary>Running user's temp directory. "C:\Users\user\AppData\Local\Temp"</summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystem.myDocuments">
            <summary>The My Documents folder. "C:\Users\user\Documents"</summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystem.commonDocuments">
            <summary>Documents that are common to all users. "C:\Users\Public\Documents", linux = null</summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystem.personal">
            <summary>A common repository for documents. "C:\Users\user\Documents"</summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystem.userProfile">
            <summary>The user's profile folder. Applications should not create files or folders at this level; they should put their data under the locations referred to by <see cref="F:Lexical.FileSystem.FileSystem.applicationData"/>. "C:\Users\user"</summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystem.applicationData">
            <summary>A common repository for application-specific data for the current roaming user. "C:\Users\user\AppData\Roaming"</summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystem.localApplicationData">
            <summary>A common repository for application-specific data that is used by the current, non-roaming user. "C:\Users\user\AppData\Local"</summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystem.commonApplicationData">
            <summary>A common repository for application-specific data that is used by all users. "C:\ProgramData"</summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystem.desktop">
            <summary>Desktop. "C:\Users\user\Desktop" "/home/user/Desktop"</summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystem.myPictures">
            <summary>MyPictures. "C:\Users\user\Pictures" "/home/user/Pictures"</summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystem.myVideos">
            <summary>MyVideos. "C:\Users\user\Videos" "/home/user/Videos"</summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystem.myMusic">
            <summary>MyMusic. "C:\Users\user\Music" "/home/user/Music"</summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystem.templates">
            <summary>Templates. "C:\Users\user\AppData\Roaming\Microsoft\Windows\Templates" "/home/user/Templates"</summary>
        </member>
        <member name="P:Lexical.FileSystem.FileSystem.OS">
            <summary>Operating system root.</summary>
        </member>
        <member name="P:Lexical.FileSystem.FileSystem.Application">
            <summary>Running application's base directory.</summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystem.Temp">
            <summary>Running user's temp directory. "C:\Users\user\AppData\Local\Temp"</summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystem.MyDocuments">
            <summary>The My Documents folder. "C:\Users\user\Documents"</summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystem.CommonDocuments">
            <summary>Documents that are common to all users. "C:\Users\Public\Documents", linux = null</summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystem.Personal">
            <summary>A common repository for documents. "C:\Users\user\Documents"</summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystem.UserProfile">
            <summary>The user's profile folder. Applications should not create files or folders at this level; they should put their data under the locations referred to by <see cref="F:Lexical.FileSystem.FileSystem.applicationData"/>. "C:\Users\user"</summary>
        </member>
        <member name="P:Lexical.FileSystem.FileSystem.Desktop">
            <summary>Desktop. "C:\Users\user\Desktop" "/home/user/Desktop"</summary>
        </member>
        <member name="P:Lexical.FileSystem.FileSystem.MyPictures">
            <summary>MyPictures. "C:\Users\user\Pictures" "/home/user/Pictures"</summary>
        </member>
        <member name="P:Lexical.FileSystem.FileSystem.MyVideos">
            <summary>MyVideos. "C:\Users\user\Videos" "/home/user/Videos"</summary>
        </member>
        <member name="P:Lexical.FileSystem.FileSystem.MyMusic">
            <summary>MyMusic. "C:\Users\user\Music" "/home/user/Music"</summary>
        </member>
        <member name="P:Lexical.FileSystem.FileSystem.Templates">
            <summary>Templates. "C:\Users\user\AppData\Roaming\Microsoft\Windows\Templates" "/home/user/Templates"</summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystem.Config">
            <summary>User's cloud-sync program configuration (roaming data). "C:\Users\user\AppData\Roaming\" "/home/user/.config/"</summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystem.Data">
            <summary>User's local program data. "C:\Users\user\AppData\Local\" "/home/user/.local/share/"</summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystem.ProgramData">
            <summary>Program data that is shared with every user. "C:\ProgramData\" "/usr/share/"</summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystem.Path">
            <summary>
            The root path as provided with constructor.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystem.AbsolutePath">
            <summary>
            Full absolute root path.
            <see cref="F:Lexical.FileSystem.FileSystem.Path"/> ran with <see cref="M:System.IO.Path.GetFullPath(System.String)"/>.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystem.IsOsRoot">
            <summary>
            Constructed to filesystem root.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.FileSystem.CaseSensitivity">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.FileSystem.EmptyDirectoryName">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.FileSystem.CanBrowse">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.FileSystem.CanGetEntry">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.FileSystem.CanObserve">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.FileSystem.CanOpen">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.FileSystem.CanRead">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.FileSystem.CanWrite">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.FileSystem.CanCreateFile">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.FileSystem.CanDelete">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.FileSystem.CanMove">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.FileSystem.CanCreateDirectory">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.FileSystem.CanSetFileAttribute">
            <inheritdoc/>
        </member>
        <member name="F:Lexical.FileSystem.FileSystem.rootEntry">
            <summary>Root "" entry</summary>
        </member>
        <member name="M:Lexical.FileSystem.FileSystem.#ctor(System.String)">
            <summary>
            Create an access to local filesystem.
            
            If <paramref name="path"/> is "", then FileSystem returns drive letters on Windows "C:" and "/" on Linux.
            
            If FileSystem is constructed with relative drive letter "C:", then the instance refers to the absolute path at time of the construction.
            If working directory is modified later on, the FileSystem instance is not affected.
            </summary>
            <param name="path">Path to root directory, or "" for OS root which returns drive letters.</param>
        </member>
        <member name="T:Lexical.FileSystem.FileSystem.NonDisposable">
            <summary>
            Non-disposable <see cref="T:Lexical.FileSystem.FileSystem"/> disposes and cleans all attached <see cref="T:System.IDisposable"/> on dispose, but doesn't go into disposed state.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.FileSystem.NonDisposable.#ctor(System.String)">
            <summary>Create non-disposable filesystem.</summary>
            <param name="path">Path to root directory, or "" for OS root which returns drive letters.</param>
        </member>
        <member name="M:Lexical.FileSystem.FileSystem.Open(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,Lexical.FileSystem.IOption)">
            <summary>
            Open a file for reading and/or writing. File can be created when <paramref name="fileMode"/> is <see cref="F:System.IO.FileMode.Create"/> or <see cref="F:System.IO.FileMode.CreateNew"/>.
            </summary>
            <param name="path">Relative path to file. Directory separator is "/". Root is without preceding "/", e.g. "dir/file.xml"</param>
            <param name="fileMode">determines whether to open or to create the file</param>
            <param name="fileAccess">how to access the file, read, write or read and write</param>
            <param name="fileShare">how the file will be shared by processes</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns>open file stream</returns>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support opening files</exception>
            <exception cref="T:System.IO.FileNotFoundException">The file cannot be found, such as when mode is FileMode.Truncate or FileMode.Open, and and the file specified by path does not exist. The file must already exist in these modes.</exception>
            <exception cref="T:System.IO.DirectoryNotFoundException">The specified path is invalid, such as being on an unmapped drive.</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="fileMode"/>, <paramref name="fileAccess"/> or <paramref name="fileShare"/> contains an invalid value.</exception>
            <exception cref="T:System.InvalidOperationException">If <paramref name="path"/> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc.</exception>
        </member>
        <member name="M:Lexical.FileSystem.FileSystem.CreateDirectory(System.String,Lexical.FileSystem.IOption)">
            <summary>
            Create a directory, or multiple cascading directories.
            
            If directory at <paramref name="path"/> already exists, then returns without exception.
            </summary>
            <param name="path">Relative path to file. Directory separator is "/". The root is without preceding slash "", e.g. "dir/dir2"</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns>true if directory exists after the method, false if directory doesn't exist</returns>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.IO.DirectoryNotFoundException">The specified path is invalid, such as being on an unmapped drive.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> is an empty string (""), contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support create directory</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters.</exception>
            <exception cref="T:System.InvalidOperationException">If <paramref name="path"/> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc.</exception>
        </member>
        <member name="M:Lexical.FileSystem.FileSystem.ConcatenateAndAssertPath(System.String,System.String@,System.String@)">
            <summary>
            Concatenates <see cref="F:Lexical.FileSystem.FileSystem.Path"/> to <paramref name="path"/> argument.
            
            Asserts that <paramref name="path"/> doesn't refer over the constructed root, e.g. ".".
            
            If <paramref name="path"/> ends with directory separator, it is reduced.
            If <paramref name="path"/> ends with ":" on windows and root is "", then "\\" is appended to the path so that
            relative path is not used.
            
            </summary>
            <param name="path"></param>
            <param name="concatenatedPath"></param>
            <param name="absolutePath"></param>
            <return>path without trailing separator, or null if refers beyond root</return>
        </member>
        <member name="M:Lexical.FileSystem.FileSystem.Browse(System.String,Lexical.FileSystem.IOption)">
            <summary>
            Browse a directory for child entries.
            </summary>
            <param name="path">path to directory, "" is root, separator is "/"</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns>a snapshot of file and directory entries</returns>
            <exception cref="T:System.IO.DirectoryNotFoundException"></exception>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support browse</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters.</exception>
            <exception cref="T:System.InvalidOperationException">If <paramref name="path"/> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc.</exception>
        </member>
        <member name="M:Lexical.FileSystem.FileSystem.GetEntry(System.String,Lexical.FileSystem.IOption)">
            <summary>
            Get entry of a single file or directory.
            </summary>
            <param name="path">path to a directory or to a single file, "" is root, separator is "/"</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns>entry, or null if entry is not found</returns>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support exists</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters.</exception>
            <exception cref="T:System.InvalidOperationException">If <paramref name="path"/> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc.</exception>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="M:Lexical.FileSystem.FileSystem.BrowseRoot">
            <summary>
            Browse root drive letters
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.FileSystem.Delete(System.String,System.Boolean,Lexical.FileSystem.IOption)">
            <summary>
            Delete a file or directory.
            
            If <paramref name="recursive"/> is false and <paramref name="path"/> is a directory that is not empty, then <see cref="T:System.InvalidOperationException"/> is thrown.
            If <paramref name="recursive"/> is true, then any file or directory within <paramref name="path"/> is deleted as well.
            </summary>
            <param name="path">path to a file or directory</param>
            <param name="recursive">if path refers to directory, recurse into sub directories</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <exception cref="T:System.IO.FileNotFoundException">The specified path is invalid.</exception>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> contains invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support deleting files</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters.</exception>
            <exception cref="T:System.InvalidOperationException">If <paramref name="path"/> refered to a directory that wasn't empty and <paramref name="recursive"/> is false, or <paramref name="path"/> refers to non-file device</exception>
        </member>
        <member name="M:Lexical.FileSystem.FileSystem.SetFileAttribute(System.String,System.IO.FileAttributes,Lexical.FileSystem.IOption)">
            <summary>
            Set <paramref name="fileAttribute"/> on <paramref name="path"/>.
            </summary>
            <param name="path"></param>
            <param name="fileAttribute"></param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <exception cref="T:System.IO.FileNotFoundException"><paramref name="path"/> is not found</exception>
            <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path"/> is invalid. For example, it's on an unmapped drive. Only thrown when setting the property value.</exception>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support browse</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters.</exception>
            <exception cref="T:System.InvalidOperationException">If <paramref name="path"/> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc.</exception>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:Lexical.FileSystem.FileSystem.Move(System.String,System.String,Lexical.FileSystem.IOption)">
            <summary>
            Try to move/rename a file or directory.
            </summary>
            <param name="oldPath">old path of a file or directory</param>
            <param name="newPath">new path of a file or directory</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <exception cref="T:System.IO.FileNotFoundException">The specified <paramref name="oldPath"/> is invalid.</exception>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.IO.FileNotFoundException">The specified path is invalid.</exception>
            <exception cref="T:System.ArgumentNullException">path is null</exception>
            <exception cref="T:System.ArgumentException">path is an empty string (""), contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support renaming/moving files</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters.</exception>
            <exception cref="T:System.InvalidOperationException">path refers to non-file device, or an entry already exists at <paramref name="newPath"/></exception>
        </member>
        <member name="M:Lexical.FileSystem.FileSystem.Observe(System.String,System.IObserver{Lexical.FileSystem.IEvent},System.Object,Lexical.FileSystem.IEventDispatcher,Lexical.FileSystem.IOption)">
            <summary>
            Attach an <paramref name="observer"/> on to a directory. 
            </summary>
            <param name="filter">glob pattern to filter events. "**" means any directory. For example "mydir/**/somefile.txt", or "**" for <paramref name="filter"/> and sub-directories</param>
            <param name="observer"></param>
            <param name="state">(optional) </param>
            <param name="eventDispatcher">(optional) </param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns>disposable handle</returns>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="filter"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="filter"/> contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support observe</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters.</exception>
            <exception cref="T:System.InvalidOperationException">If <paramref name="filter"/> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc.</exception>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="T:Lexical.FileSystem.FileSystem.FileObserver">
            <summary>
            Single file observer.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystem.FileObserver.FileSystemRootAbsolutePath">
            <summary>
            Absolute path as <see cref="T:Lexical.FileSystem.FileSystem"/> root. Separator is '\\' or '/' depending on operating system.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystem.FileObserver.AbsolutePath">
            <summary>
            Absolute path to file. Separator is '\\' or '/' depending on operating system.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystem.FileObserver.RelativePath">
            <summary>
            Relative path (<see cref="T:Lexical.FileSystem.FileSystem"/> path). The directory separator is '/'.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystem.FileObserver.watcher">
            <summary>
            Watcher
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystem.FileObserver.startTime">
            <summary>Time when observing started.</summary>
        </member>
        <member name="M:Lexical.FileSystem.FileSystem.FileObserver.#ctor(Lexical.FileSystem.IFileSystem,System.String,System.IObserver{Lexical.FileSystem.IEvent},System.Object,Lexical.FileSystem.IEventDispatcher,System.String,System.String)">
            <summary>
            Create observer for one file (or directory).
            </summary>
            <param name="filesystem">associated file system</param>
            <param name="relativePath">path to file as <see cref="T:Lexical.FileSystem.IFileSystem"/> path</param>
            <param name="observer">observer for callbacks</param>
            <param name="state"></param>
            <param name="eventDispatcher"></param>
            <param name="filesystemRootAbsolutePath">Absolute path to filesystem root.</param>
            <param name="absolutePath">Absolute path to the file</param>
            <exception cref="T:System.IO.DirectoryNotFoundException">If directory in <paramref name="filesystemRootAbsolutePath"/> is not found.</exception>
        </member>
        <member name="M:Lexical.FileSystem.FileSystem.FileObserver.OnError(System.Object,System.IO.ErrorEventArgs)">
            <summary>
            Handle (Forward) error event.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Lexical.FileSystem.FileSystem.FileObserver.OnEvent(System.Object,System.IO.FileSystemEventArgs)">
            <summary>
            Forward event
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Lexical.FileSystem.FileSystem.FileObserver.ConvertPath(System.String)">
            <summary>
            Convert path from <see cref="T:System.EventArgs"/> into relative path of <see cref="T:Lexical.FileSystem.IFileSystem"/>.
            </summary>
            <param name="absolutePath">absolute file path to file that is to be converted to relative path</param>
            <returns>relative path, or null if failed</returns>
        </member>
        <member name="M:Lexical.FileSystem.FileSystem.FileObserver.InnerDispose(Lexical.FileSystem.Internal.StructList4{System.Exception}@)">
            <summary>
            Dispose observer
            </summary>
            <exception cref="T:System.AggregateException"></exception>
        </member>
        <member name="T:Lexical.FileSystem.FileSystem.PatternObserver">
            <summary>
            Watches a group of files using a pattern.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystem.PatternObserver.FileSystemRootAbsolutePath">
            <summary>
            Absolute path as <see cref="T:Lexical.FileSystem.FileSystem"/> root. Separator is '\\' or '/' depending on operating system.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystem.PatternObserver.AbsolutePathToPrefixPart">
            <summary>
            Absolute path to file. Separator is '\\' or '/' depending on operating system.
            
            For example, if filter string is "dir/**" then this is "C:\temp\dir". 
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystem.PatternObserver.RelativePathToPrefixPartWithoutTrailingSeparatorRelativePath">
            <summary>
            Relative path (<see cref="T:Lexical.FileSystem.FileSystem"/> path). The directory separator is '/'.
            
            For example, if filter string is "dir/**" then this is "dir".
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystem.PatternObserver.SuffixPart">
            <summary>
            Suffix part of filter string that contains wildcards and filenames.
            
            For example, if filter string is "dir/**", then this is "**".
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystem.PatternObserver.filterInfo">
            <summary>
            Filter info.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystem.PatternObserver.fileWatcher">
            <summary>
            Watcher
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystem.PatternObserver.directoryWatcher">
            <summary>
            Watcher
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystem.PatternObserver.Pattern">
            <summary>
            Filter glob pattern
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystem.PatternObserver.startTime">
            <summary>Time when observing started.</summary>
        </member>
        <member name="M:Lexical.FileSystem.FileSystem.PatternObserver.#ctor(Lexical.FileSystem.IFileSystem,System.IObserver{Lexical.FileSystem.IEvent},System.Object,Lexical.FileSystem.IEventDispatcher,System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Create observer for one file.
            </summary>
            <param name="filesystem">associated file system</param>
            <param name="observer">observer for callbacks</param>
            <param name="state"></param>
            <param name="eventDispatcher"></param>
            <param name="filterString">original filter string</param>
            <param name="filesystemRootAbsolutePath">Absolute path to <see cref="T:Lexical.FileSystem.FileSystem"/> root.</param>
            <param name="relativePathToPrefixPartWithoutTrailingSeparator">prefix part of <paramref name="filterString"/>, for example "dir" if filter string is "dir/**"</param>
            <param name="absolutePathToPrefixPart">absolute path to prefix part of <paramref name="filterString"/>, for example "C:\Temp\Dir", if filter string is "dir/**" and <paramref name="filesystemRootAbsolutePath"/> is "C:\temp"</param>
            <param name="suffixPart">Suffix part of <paramref name="filterString"/>, for example "**" if filter string is "dir/**"</param>
        </member>
        <member name="M:Lexical.FileSystem.FileSystem.PatternObserver.OnError(System.Object,System.IO.ErrorEventArgs)">
            <summary>
            Handle (Forward) error event.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Lexical.FileSystem.FileSystem.PatternObserver.OnEvent(System.Object,System.IO.FileSystemEventArgs)">
            <summary>
            Forward event
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Lexical.FileSystem.FileSystem.PatternObserver.ConvertPath(System.String)">
            <summary>
            Convert path from <see cref="T:System.EventArgs"/> into relative path of <see cref="T:Lexical.FileSystem.IFileSystem"/>.
            </summary>
            <param name="absolutePath">absolute file path to file that is to be converted to relative path</param>
            <returns>relative path, or null if failed</returns>
        </member>
        <member name="M:Lexical.FileSystem.FileSystem.PatternObserver.InnerDispose(Lexical.FileSystem.Internal.StructList4{System.Exception}@)">
            <summary>
            Dispose unmanaged resources
            </summary>
            <exception cref="T:System.AggregateException"></exception>
        </member>
        <member name="M:Lexical.FileSystem.FileSystem.AddDisposeAction(System.Action{Lexical.FileSystem.FileSystem})">
            <summary>
            Invoke <paramref name="disposeAction"/> on the dispose of the object.
            
            If parent object is disposed or being disposed, the disposable will be disposed immedialy.
            </summary>
            <param name="disposeAction"></param>
            <returns>self</returns>
        </member>
        <member name="M:Lexical.FileSystem.FileSystem.AddDisposeAction(System.Action{System.Object},System.Object)">
            <summary>
            Invoke <paramref name="disposeAction"/> on the dispose of the object.
            
            If parent object is disposed or being disposed, the disposable will be disposed immedialy.
            </summary>
            <param name="disposeAction"></param>
            <param name="state"></param>
            <returns>self</returns>
        </member>
        <member name="M:Lexical.FileSystem.FileSystem.AddDisposable(System.Object)">
            <summary>
            Add <paramref name="disposable"/> to list of objects to be disposed along with the system.
            </summary>
            <param name="disposable"></param>
            <returns>filesystem</returns>
        </member>
        <member name="M:Lexical.FileSystem.FileSystem.AddDisposables(System.Collections.IEnumerable)">
            <summary>
            Add <paramref name="disposables"/> to list of objects to be disposed along with the system.
            </summary>
            <param name="disposables"></param>
            <returns>filesystem</returns>
        </member>
        <member name="M:Lexical.FileSystem.FileSystem.RemoveDisposable(System.Object)">
            <summary>
            Remove <paramref name="disposable"/> from dispose list.
            </summary>
            <param name="disposable"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.FileSystem.RemoveDisposables(System.Collections.IEnumerable)">
            <summary>
            Remove <paramref name="disposables"/> from dispose list.
            </summary>
            <param name="disposables"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.FileSystem.ToString">
            <summary>
            Print info
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemInfoExtensions.LastAccessTimeUtcUnchecked(System.IO.FileSystemInfo)">
            <summary>
            Gets LastAccessTime, but captures exceptions and returns default value.
            </summary>
            <param name="fi"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemInfoExtensions.LastWriteTimeUtcUnchecked(System.IO.FileSystemInfo)">
            <summary>
            Gets LastWriteTime, but captures exceptions and returns default value.
            </summary>
            <param name="fi"></param>
            <returns></returns>
        </member>
        <member name="T:Lexical.FileSystem.DirectoryContent">
            <summary>
            Directory content
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.DirectoryContent.FileSystem">
            <summary>The filesystem where the browse was issued.</summary>
        </member>
        <member name="P:Lexical.FileSystem.DirectoryContent.Path">
            <summary>The browsed path at <see cref="P:Lexical.FileSystem.DirectoryContent.FileSystem"/>.</summary>
        </member>
        <member name="P:Lexical.FileSystem.DirectoryContent.Exists">
            <summary><see cref="P:Lexical.FileSystem.DirectoryContent.Path"/> exists.</summary>
        </member>
        <member name="P:Lexical.FileSystem.DirectoryContent.Count">
            <summary>Number of entries</summary>
        </member>
        <member name="P:Lexical.FileSystem.DirectoryContent.Item(System.Int32)">
            <summary>Entry at <paramref name="index"/></summary>
        </member>
        <member name="F:Lexical.FileSystem.DirectoryContent.entries">
            <summary>Entries</summary>
        </member>
        <member name="F:Lexical.FileSystem.DirectoryContent.filesystem">
            <summary>The filesystem where the browse was issued.</summary>
        </member>
        <member name="F:Lexical.FileSystem.DirectoryContent.path">
            <summary>The browsed path at <see cref="P:Lexical.FileSystem.DirectoryContent.FileSystem"/>.</summary>
        </member>
        <member name="M:Lexical.FileSystem.DirectoryContent.#ctor(Lexical.FileSystem.IFileSystem,System.String,System.Collections.Generic.IEnumerable{Lexical.FileSystem.IEntry})">
            <summary>
            Create directory content.
            </summary>
            <param name="filesystem"></param>
            <param name="path"></param>
            <param name="entries"></param>
        </member>
        <member name="M:Lexical.FileSystem.DirectoryContent.GetEnumerator">
            <summary>Get enumerator for entries</summary>
        </member>
        <member name="M:Lexical.FileSystem.DirectoryContent.System#Collections#IEnumerable#GetEnumerator">
            <summary>Get enumerator for entries</summary>
        </member>
        <member name="M:Lexical.FileSystem.DirectoryContent.ToString">
            <summary>Print into</summary>
        </member>
        <member name="T:Lexical.FileSystem.DirectoryEmpty">
            <summary>
            Directory content with no entries, but existing directory.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.DirectoryEmpty.enumerator">
            <summary>enumerator</summary>
        </member>
        <member name="P:Lexical.FileSystem.DirectoryEmpty.FileSystem">
            <summary>The filesystem where the browse was issued.</summary>
        </member>
        <member name="P:Lexical.FileSystem.DirectoryEmpty.Path">
            <summary>The browsed path at <see cref="P:Lexical.FileSystem.DirectoryEmpty.FileSystem"/>.</summary>
        </member>
        <member name="P:Lexical.FileSystem.DirectoryEmpty.Exists">
            <summary><see cref="P:Lexical.FileSystem.DirectoryEmpty.Path"/> exists.</summary>
        </member>
        <member name="P:Lexical.FileSystem.DirectoryEmpty.Count">
            <summary>Number of entries</summary>
        </member>
        <member name="P:Lexical.FileSystem.DirectoryEmpty.Item(System.Int32)">
            <summary>Entry at <paramref name="index"/></summary>
        </member>
        <member name="F:Lexical.FileSystem.DirectoryEmpty.filesystem">
            <summary>The filesystem where the browse was issued.</summary>
        </member>
        <member name="F:Lexical.FileSystem.DirectoryEmpty.path">
            <summary>The browsed path at <see cref="P:Lexical.FileSystem.DirectoryEmpty.FileSystem"/>.</summary>
        </member>
        <member name="M:Lexical.FileSystem.DirectoryEmpty.#ctor(Lexical.FileSystem.IFileSystem,System.String)">
            <summary>
            Create directory content.
            </summary>
            <param name="filesystem"></param>
            <param name="path"></param>
        </member>
        <member name="M:Lexical.FileSystem.DirectoryEmpty.GetEnumerator">
            <summary>Get enumerator for no entries</summary>
        </member>
        <member name="M:Lexical.FileSystem.DirectoryEmpty.System#Collections#Generic#IEnumerable{Lexical#FileSystem#IEntry}#GetEnumerator">
            <summary>Get enumerator for no entries</summary>
        </member>
        <member name="M:Lexical.FileSystem.DirectoryEmpty.System#Collections#IEnumerable#GetEnumerator">
            <summary>Get enumerator for no entries</summary>
        </member>
        <member name="T:Lexical.FileSystem.DirectoryEmpty.Enumerator">
            <summary>Directory enumerator</summary>
        </member>
        <member name="P:Lexical.FileSystem.DirectoryEmpty.Enumerator.Current">
            <summary>Current entry at cursor</summary>
        </member>
        <member name="P:Lexical.FileSystem.DirectoryEmpty.Enumerator.System#Collections#IEnumerator#Current">
            <summary>Current entry at cursor</summary>
        </member>
        <member name="M:Lexical.FileSystem.DirectoryEmpty.Enumerator.Dispose">
            <summary>Dispose enumerator</summary>
        </member>
        <member name="M:Lexical.FileSystem.DirectoryEmpty.Enumerator.MoveNext">
            <summary>Move cursor</summary>
        </member>
        <member name="M:Lexical.FileSystem.DirectoryEmpty.Enumerator.Reset">
            <summary>Reset cursor.</summary>
        </member>
        <member name="M:Lexical.FileSystem.DirectoryEmpty.ToString">
            <summary>Print into</summary>
        </member>
        <member name="T:Lexical.FileSystem.DirectoryNotFound">
            <summary>
            Directory content for directory that doesn't exist
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.DirectoryNotFound.enumerator">
            <summary>enumerator</summary>
        </member>
        <member name="P:Lexical.FileSystem.DirectoryNotFound.FileSystem">
            <summary>The filesystem where the browse was issued.</summary>
        </member>
        <member name="P:Lexical.FileSystem.DirectoryNotFound.Path">
            <summary>The browsed path at <see cref="P:Lexical.FileSystem.DirectoryNotFound.FileSystem"/>.</summary>
        </member>
        <member name="P:Lexical.FileSystem.DirectoryNotFound.Exists">
            <summary><see cref="P:Lexical.FileSystem.DirectoryNotFound.Path"/> exists.</summary>
        </member>
        <member name="P:Lexical.FileSystem.DirectoryNotFound.Count">
            <summary>Entry count</summary>
        </member>
        <member name="P:Lexical.FileSystem.DirectoryNotFound.Item(System.Int32)">
            <summary>Entry</summary>
        </member>
        <member name="F:Lexical.FileSystem.DirectoryNotFound.filesystem">
            <summary>The filesystem where the browse was issued.</summary>
        </member>
        <member name="F:Lexical.FileSystem.DirectoryNotFound.path">
            <summary>The browsed path at <see cref="P:Lexical.FileSystem.DirectoryNotFound.FileSystem"/>.</summary>
        </member>
        <member name="M:Lexical.FileSystem.DirectoryNotFound.#ctor(Lexical.FileSystem.IFileSystem,System.String)">
            <summary>
            Create content instance for directory that doesn't exist.
            </summary>
            <param name="filesystem"></param>
            <param name="path"></param>
        </member>
        <member name="M:Lexical.FileSystem.DirectoryNotFound.GetEnumerator">
            <summary>Get enumerator for no entries</summary>
        </member>
        <member name="M:Lexical.FileSystem.DirectoryNotFound.System#Collections#Generic#IEnumerable{Lexical#FileSystem#IEntry}#GetEnumerator">
            <summary>Get enumerator for no entries</summary>
        </member>
        <member name="M:Lexical.FileSystem.DirectoryNotFound.System#Collections#IEnumerable#GetEnumerator">
            <summary>Get enumerator for no entries</summary>
        </member>
        <member name="T:Lexical.FileSystem.DirectoryNotFound.Enumerator">
            <summary>Directory enumerator</summary>
        </member>
        <member name="P:Lexical.FileSystem.DirectoryNotFound.Enumerator.Current">
            <summary>Current entry at cursor</summary>
        </member>
        <member name="P:Lexical.FileSystem.DirectoryNotFound.Enumerator.System#Collections#IEnumerator#Current">
            <summary>Current entry at cursor</summary>
        </member>
        <member name="M:Lexical.FileSystem.DirectoryNotFound.Enumerator.Dispose">
            <summary>Dispose enumerator</summary>
        </member>
        <member name="M:Lexical.FileSystem.DirectoryNotFound.Enumerator.MoveNext">
            <summary>Move cursor</summary>
        </member>
        <member name="M:Lexical.FileSystem.DirectoryNotFound.Enumerator.Reset">
            <summary>Reset cursor.</summary>
        </member>
        <member name="M:Lexical.FileSystem.DirectoryNotFound.ToString">
            <summary>Print into</summary>
        </member>
        <member name="T:Lexical.FileSystem.FileSystemBase">
            <summary>
            Base implementation for <see cref="T:Lexical.FileSystem.IFileSystem"/>. 
            
            Disposables can be attached to be disposed along with <see cref="T:Lexical.FileSystem.IFileSystem"/>.
            Watchers can be attached as disposables, so that they forward <see cref="M:System.IObserver`1.OnCompleted"/> event upon IFileSystem dispose.
            
            Can send events to observers.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemBase.#ctor">
            <summary>
            Create new filesystem.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemBase.DispatchEvents(Lexical.FileSystem.Internal.StructList12{Lexical.FileSystem.IEvent}@)">
            <summary>
            Send <paramref name="events"/> to observers.
            </summary>
            <param name="events"></param>
        </member>
        <member name="T:Lexical.FileSystem.FileSystemExtensions">
            <summary>
            Facade for services and extension methods.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemExtensions.Concat(Lexical.FileSystem.IFileSystem,Lexical.FileSystem.IFileSystem)">
            <summary>
            Concatenate <paramref name="filesystem"/> and <paramref name="anotherFileSystem"/> into composition filesystem.
            </summary>
            <param name="filesystem"></param>
            <param name="anotherFileSystem"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemExtensions.Concat(Lexical.FileSystem.IFileSystem,Lexical.FileSystem.IFileSystem[])">
            <summary>
            Concatenate <paramref name="filesystem"/> and <paramref name="otherFileSystems"/> into composition filesystem.
            </summary>
            <param name="filesystem"></param>
            <param name="otherFileSystems"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemExtensions.Concat(Lexical.FileSystem.IFileSystem,System.Collections.Generic.IEnumerable{Lexical.FileSystem.IFileSystem})">
            <summary>
            Concatenate <paramref name="filesystem"/> and <paramref name="otherFileSystems"/> into composition filesystem.
            </summary>
            <param name="filesystem"></param>
            <param name="otherFileSystems"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemExtensions.Concat(Lexical.FileSystem.IFileSystem[])">
            <summary>
            Concatenate <paramref name="filesystems"/> into a composition filesystem.
            </summary>
            <param name="filesystems"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemExtensions.Concat(System.Collections.Generic.IEnumerable{Lexical.FileSystem.IFileSystem})">
            <summary>
            Concatenate <paramref name="filesystems"/> into a composition filesystem.
            </summary>
            <param name="filesystems"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemExtensions.Concat(System.ValueTuple{Lexical.FileSystem.IFileSystem,Lexical.FileSystem.IOption}[])">
            <summary>
            Concatenate <paramref name="filesystemsAndOptions"/> into one composition filesystem.
            </summary>
            <param name="filesystemsAndOptions"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemExtensions.Concat(Lexical.FileSystem.FileSystemAssignment[])">
            <summary>
            Concatenate <paramref name="filesystemsAndOptions"/> into one composition filesystem.
            </summary>
            <param name="filesystemsAndOptions"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemExtensions.Decorate(Lexical.FileSystem.IFileSystem,Lexical.FileSystem.IOption)">
            <summary>
            Creates a new filesystem decoration that reduces the permissions of <paramref name="filesystem"/> by 
            intersecting <paramref name="filesystem"/>'s options with <paramref name="option"/>.
            </summary>
            <param name="filesystem"></param>
            <param name="option"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemExtensions.AsReadOnly(Lexical.FileSystem.IFileSystem)">
            <summary>
            Creates a new filesystem decoration that reduces the permissions of <paramref name="filesystem"/> to readonly.
            </summary>
            <param name="filesystem"></param>
            <returns></returns>
        </member>
        <member name="T:Lexical.FileSystem.FileSystemOperationExtensions">
            <summary>
            Extension methods for <see cref="T:Lexical.FileSystem.IFileSystem"/>.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemOperationExtensions.Transfer(Lexical.FileSystem.IFileSystem,System.String,Lexical.FileSystem.IFileSystem,System.String,Lexical.FileSystem.IOption,Lexical.FileSystem.IOption)">
            <summary>
            Transfer a file or directory by copy and delete.
            
            If <paramref name="srcPath"/> and <paramref name="dstPath"/> refers to a directory, then the path names 
            should end with directory separator character '/'.
            </summary>
            <param name="filesystem"></param>
            <param name="srcPath">old path of a file or directory</param>
            <param name="dstFileSystem">filesystem to copy to</param>
            <param name="dstPath">new path of a file or directory</param>
            <param name="srcOption">(optional)</param>
            <param name="dstOption">(optional)</param>
            <exception cref="T:System.IO.FileNotFoundException">The specified <paramref name="srcPath"/> is invalid.</exception>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.IO.FileNotFoundException">The specified path is invalid.</exception>
            <exception cref="T:System.ArgumentNullException">path is null</exception>
            <exception cref="T:System.ArgumentException">path is an empty string (""), contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support copy and delete of files</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters.</exception>
            <exception cref="T:System.InvalidOperationException">path refers to non-file device, or an entry already exists at <paramref name="dstPath"/></exception>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemOperationExtensions.CopyFile(Lexical.FileSystem.IFileSystem,System.String,System.String,Lexical.FileSystem.IOption)">
            <summary>
            Copy a file.
            </summary>
            <param name="filesystem"></param>
            <param name="srcPath">source path of a file or directory</param>
            <param name="dstPath">target path of a file or directory</param>
            <param name="option">(optional) token to authorize or facilitate operation</param>
            <exception cref="T:System.IO.FileNotFoundException">The specified <paramref name="srcPath"/> is invalid.</exception>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.IO.FileNotFoundException">The specified path is invalid.</exception>
            <exception cref="T:System.ArgumentNullException">path is null</exception>
            <exception cref="T:System.ArgumentException">path is an empty string (""), contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support copy and delete of files</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters.</exception>
            <exception cref="T:System.InvalidOperationException">path refers to non-file device, or an entry already exists at <paramref name="dstPath"/></exception>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemOperationExtensions.CopyFile(Lexical.FileSystem.IFileSystem,System.String,Lexical.FileSystem.IFileSystem,System.String,Lexical.FileSystem.IOption,Lexical.FileSystem.IOption)">
            <summary>
            Copy a file.
            </summary>
            <param name="filesystem"></param>
            <param name="srcPath">source path of a file or directory</param>
            <param name="dstFileSystem">filesystem to copy to</param>
            <param name="dstPath">target path of a file or directory</param>
            <param name="srcOption">(optional)</param>
            <param name="dstOption">(optional)</param>
            <exception cref="T:System.IO.FileNotFoundException">The specified <paramref name="srcPath"/> is invalid.</exception>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.IO.FileNotFoundException">The specified path is invalid.</exception>
            <exception cref="T:System.ArgumentNullException">path is null</exception>
            <exception cref="T:System.ArgumentException">path is an empty string (""), contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support copy and delete of files</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters.</exception>
            <exception cref="T:System.InvalidOperationException">path refers to non-file device, or an entry already exists at <paramref name="dstPath"/></exception>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemOperationExtensions.CopyTree(Lexical.FileSystem.IFileSystem,System.String,System.String,Lexical.FileSystem.IOption)">
            <summary>
            Copy a file or directory tree.
            
            If <paramref name="srcPath"/> and <paramref name="dstPath"/> refers to a directory, then the path names 
            should end with directory separator character '/'.
            </summary>
            <param name="filesystem"></param>
            <param name="srcPath">source path of a file or directory</param>
            <param name="dstPath">target path of a file or directory</param>
            <param name="option">(optional) token to authorize or facilitate operation</param>
            <exception cref="T:System.IO.FileNotFoundException">The specified <paramref name="srcPath"/> is invalid.</exception>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.IO.FileNotFoundException">The specified path is invalid.</exception>
            <exception cref="T:System.ArgumentNullException">path is null</exception>
            <exception cref="T:System.ArgumentException">path is an empty string (""), contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support copy and delete of files</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters.</exception>
            <exception cref="T:System.InvalidOperationException">path refers to non-file device, or an entry already exists at <paramref name="dstPath"/></exception>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemOperationExtensions.CopyTree(Lexical.FileSystem.IFileSystem,System.String,Lexical.FileSystem.IFileSystem,System.String,Lexical.FileSystem.IOption,Lexical.FileSystem.IOption)">
            <summary>
            Copy a file or directory tree.
            
            If <paramref name="srcPath"/> and <paramref name="dstPath"/> refers to a directory, then the path names 
            should end with directory separator character '/'.
            </summary>
            <param name="filesystem"></param>
            <param name="srcPath">source path of a file or directory</param>
            <param name="dstFileSystem">filesystem to copy to</param>
            <param name="dstPath">target path of a file or directory</param>
            <param name="srcOption">(optional)</param>
            <param name="dstOption">(optional)</param>
            <exception cref="T:System.IO.FileNotFoundException">The specified <paramref name="srcPath"/> is invalid.</exception>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.IO.FileNotFoundException">The specified path is invalid.</exception>
            <exception cref="T:System.ArgumentNullException">path is null</exception>
            <exception cref="T:System.ArgumentException">path is an empty string (""), contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support copy and delete of files</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters.</exception>
            <exception cref="T:System.InvalidOperationException">path refers to non-file device, or an entry already exists at <paramref name="dstPath"/></exception>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="T:Lexical.FileSystem.IPathConverter">
            <summary>
            Interface for classes that make path conversions between two filesystems "Parent" and "Child".
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.IPathConverter.ParentPathSegment">
            <summary>Path stem on parent filesystem</summary>
        </member>
        <member name="P:Lexical.FileSystem.IPathConverter.ParentPath">
            <summary>Path stem on parent filesystem</summary>
        </member>
        <member name="P:Lexical.FileSystem.IPathConverter.ChildPathSegment">
            <summary>Path stem on child filesystem</summary>
        </member>
        <member name="P:Lexical.FileSystem.IPathConverter.ChildPath">
            <summary>Path stem on child filesystem</summary>
        </member>
        <member name="M:Lexical.FileSystem.IPathConverter.ParentToChild(Lexical.FileSystem.Internal.StringSegment,Lexical.FileSystem.Internal.StringSegment@)">
            <summary>
            Convert input <paramref name="parentPath"/> of parent filesystem to path of child filesystem.
            </summary>
            <param name="parentPath"></param>
            <param name="childPath"></param>
            <returns>true <paramref name="parentPath"/> started with expected <see cref="P:Lexical.FileSystem.IPathConverter.ParentPathSegment"/></returns>
        </member>
        <member name="M:Lexical.FileSystem.IPathConverter.ParentToChild(System.String,System.String@)">
            <summary>
            Convert <paramref name="parentPath"/> of parent filesystem to path of child filesystem.
            
            If <paramref name="childPath"/> is null then <paramref name="parentPath"/> is placed null as well.
            </summary>
            <param name="parentPath">(optional) path in parent filesystem's format</param>
            <param name="childPath">(optional) <paramref name="parentPath"/> converted to child filesystem's path notation</param>
            <returns>true <paramref name="parentPath"/> started with expected <see cref="P:Lexical.FileSystem.IPathConverter.ParentPathSegment"/></returns>
        </member>
        <member name="M:Lexical.FileSystem.IPathConverter.ChildToParent(Lexical.FileSystem.Internal.StringSegment,Lexical.FileSystem.Internal.StringSegment@)">
            <summary>
            Converts path in child filesystem to path in parent filesystem.
            </summary>
            <param name="childPath"></param>
            <param name="parentPath"></param>
            <returns>true if <paramref name="childPath"/> started with expected <see cref="P:Lexical.FileSystem.IPathConverter.ChildPathSegment"/></returns>
        </member>
        <member name="M:Lexical.FileSystem.IPathConverter.ChildToParent(System.String,System.String@)">
            <summary>
            Converts path from child filesystem to path in parent filesystem.
            
            If <paramref name="childPath"/> is null then <paramref name="parentPath"/> is placed null as well.
            </summary>
            <param name="childPath">(optional) child filesystem path to be converted</param>
            <param name="parentPath">(optional) path in parent filesystem format</param>
            <returns>true if <paramref name="childPath"/> started with expected <see cref="P:Lexical.FileSystem.IPathConverter.ChildPathSegment"/></returns>
        </member>
        <member name="T:Lexical.FileSystem.PathConverter">
            <summary>
            Tool that makes path conversions of decorated filesystems.
            
            This tool is used by <see cref="T:Lexical.FileSystem.IFileSystem"/> implementations that support <see cref="T:Lexical.FileSystem.ISubPathOption"/> option.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.PathConverter.ParentPathSegment">
            <summary>Path stem on parent filesystem</summary>
        </member>
        <member name="P:Lexical.FileSystem.PathConverter.ParentPath">
            <summary>Path stem on parent filesystem</summary>
        </member>
        <member name="P:Lexical.FileSystem.PathConverter.ChildPathSegment">
            <summary>Path stem on child filesystem</summary>
        </member>
        <member name="P:Lexical.FileSystem.PathConverter.ChildPath">
            <summary>Path stem on child filesystem</summary>
        </member>
        <member name="F:Lexical.FileSystem.PathConverter.equals">
            <summary>
            If <see cref="P:Lexical.FileSystem.PathConverter.ParentPathSegment"/> and <see cref="P:Lexical.FileSystem.PathConverter.ChildPathSegment"/> are equal, then 
            they can be passed as is with no modification.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.PathConverter.#ctor(System.String,System.String)">
            <summary>
            Create path conversion.
            </summary>
            <param name="parentPath"></param>
            <param name="childPath"></param>
        </member>
        <member name="M:Lexical.FileSystem.PathConverter.ParentToChild(Lexical.FileSystem.Internal.StringSegment,Lexical.FileSystem.Internal.StringSegment@)">
            <summary>
            Convert input <paramref name="parentPath"/> of parent filesystem to path of child filesystem.
            </summary>
            <param name="parentPath"></param>
            <param name="childPath"></param>
            <returns>true <paramref name="parentPath"/> started with expected <see cref="P:Lexical.FileSystem.PathConverter.ParentPathSegment"/></returns>
        </member>
        <member name="M:Lexical.FileSystem.PathConverter.ParentToChild(System.String,System.String@)">
            <summary>
            Convert <paramref name="parentPath"/> of parent filesystem to path of child filesystem.
            
            If <paramref name="childPath"/> is null then <paramref name="parentPath"/> is placed null as well.
            </summary>
            <param name="parentPath">(optional) path in parent filesystem's format</param>
            <param name="childPath">(optional) <paramref name="parentPath"/> converted to child filesystem's path notation</param>
            <returns>true <paramref name="parentPath"/> started with expected <see cref="P:Lexical.FileSystem.PathConverter.ParentPathSegment"/></returns>
        </member>
        <member name="M:Lexical.FileSystem.PathConverter.ChildToParent(Lexical.FileSystem.Internal.StringSegment,Lexical.FileSystem.Internal.StringSegment@)">
            <summary>
            Converts path in child filesystem to path in parent filesystem.
            </summary>
            <param name="childPath"></param>
            <param name="parentPath"></param>
            <returns>true if <paramref name="childPath"/> started with expected <see cref="P:Lexical.FileSystem.PathConverter.ChildPathSegment"/></returns>
        </member>
        <member name="M:Lexical.FileSystem.PathConverter.ChildToParent(System.String,System.String@)">
            <summary>
            Converts path from child filesystem to path in parent filesystem.
            
            If <paramref name="childPath"/> is null then <paramref name="parentPath"/> is placed null as well.
            </summary>
            <param name="childPath">(optional) child filesystem path to be converted</param>
            <param name="parentPath">(optional) path in parent filesystem format</param>
            <returns>true if <paramref name="childPath"/> started with expected <see cref="P:Lexical.FileSystem.PathConverter.ChildPathSegment"/></returns>
        </member>
        <member name="T:Lexical.FileSystem.PrintTree">
            <summary>
            Print extension methods for <see cref="T:Lexical.FileSystem.IFileSystem"/>.
            </summary>
        </member>
        <member name="T:Lexical.FileSystem.PrintTree.Format">
            <summary>
            Print format
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.PrintTree.Format.Tree">
            <summary>
            Print tree lines.
            
            ""
            ""
            "mnt"
            "tmp"
            "helloworld.txt"
            "usr"
               "lex"
            "c:"
               "dir"
                  "dir"
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.PrintTree.Format.Name">
            <summary>
            Print entry name.
            
            ""
            ""
            "mnt"
            "tmp"
            "helloworld.txt"
            "usr"
               "lex"
            "c:"
               "dir"
                  "dir"
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.PrintTree.Format.Path">
            <summary>
            Print entry path.
            
            /
            /mnt/
            /tmp/
            /tmp/helloworld.txt
            /usr/
               /usr/myuser/
            c:
               c:/dir/
                  c:/dir/dir/
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.PrintTree.Format.Length">
            <summary>
            Print length on files
            
            /
            /mnt/
            /tmp/
            /tmp/helloworld.txt [128]
            /usr/
               /usr/myuser/
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.PrintTree.Format.Mount">
            <summary>
            Print mount info on mountpoints.
            
            /
            /application/ [C:\Program Files (x86)\MyApplication]
            /assembly/ [AssemblyFileSystem]
            /tmp/ [MemoryFileSystem]
            /docs/ [C:\Users\myuser\MyDocuments]
            /home/ [C:\Users\myuser]
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.PrintTree.Format.DriveLabel">
            <summary>
            Print drive label [Tank]
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.PrintTree.Format.DriveFreespace">
            <summary>
            Print drive free space [32G/]
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.PrintTree.Format.DriveSize">
            <summary>
            Print drive total size [512GB]
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.PrintTree.Format.DriveType">
            <summary>
            Print drive format if other than <see cref="F:System.IO.DriveType.Unknown"/> [Ram]
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.PrintTree.Format.DriveFormat">
            <summary>
            Print drive type [NTFS]
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.PrintTree.Format.FileAttributes">
            <summary>
            Print file attributes
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.PrintTree.Format.PhysicalPath">
            <summary>
            Print physical path [C:\Temp\myfile.txt]
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.PrintTree.Format.Error">
            <summary>
            Print error on files
            
            /
            /tmp/ [IOException: File not found.]
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.PrintTree.Format.LineFeed">
            <summary>
            Print "\n"
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.PrintTree.Format.Default">
            <summary>
            Default format.
            
            ""
            ""
            "mnt"
            "tmp"
            "helloworld.txt"
            "usr"
               "lex"
            "c:"
               "dir"
                  "dir"
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.PrintTree.Format.DefaultPath">
            <summary>
            Print entry path.
            
            /
            /mnt
            /tmp
            /tmp/helloworld.txt
            /usr
               /usr/lex
            c:
               c:/dir
                  c:/dir/dir
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.PrintTree.Format.All">
            <summary>
            All flags
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.PrintTree.Format.AllWithName">
            <summary>
            All flags with Name (excludes Path)
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.PrintTree.Format.AllWithPath">
            <summary>
            All flags with Path (excludes Name)
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.PrintTree.PrintTo(Lexical.FileSystem.IFileSystem,System.IO.TextWriter,System.String,System.Int32,Lexical.FileSystem.PrintTree.Format,Lexical.FileSystem.IOption)">
            <summary>
            Print tree structure of the whole filesystem. 
            
            Starts at <paramref name="path"/> if provided, otherwise starts at root "".
            <paramref name="depth"/> sets maximum visit depths.
            
            ""
            ""
            "mnt"
            "tmp"
            "helloworld.txt"
            "usr"
               "lex"
            "c:"
               "dir"
                  "dir"
            
            
            Any thrown exceptions are printed into the line that produced the error.
            </summary>
            <param name="filesystem"></param>
            <param name="output">output such as <see cref="P:System.Console.Out"/></param>
            <param name="path"></param>
            <param name="depth">maximum visit depth</param>
            <param name="format">print format</param>
            <param name="option">(null) session or security token</param>
        </member>
        <member name="M:Lexical.FileSystem.PrintTree.PrintTo(Lexical.FileSystem.IFileSystem,System.Text.StringBuilder,System.String,System.Int32,Lexical.FileSystem.PrintTree.Format,Lexical.FileSystem.IOption)">
            <summary>
            Print tree structure of the whole filesystem. 
            
            Starts at <paramref name="path"/> if provided, otherwise starts at root "".
            <paramref name="depth"/> sets maximum visit depths.
            
            ""
            ""
            "mnt"
            "tmp"
            "helloworld.txt"
            "usr"
               "lex"
            "c:"
               "dir"
                  "dir"
            
            
            Any thrown exceptions are printed into the line that produced the error.
            </summary>
            <param name="filesystem"></param>
            <param name="output">output</param>
            <param name="path"></param>
            <param name="depth">maximum visit depth</param>
            <param name="format">print format</param>
            <param name="option">(null) session or security token</param>
        </member>
        <member name="M:Lexical.FileSystem.PrintTree.Print(Lexical.FileSystem.IFileSystem,System.String,System.Int32,Lexical.FileSystem.PrintTree.Format,Lexical.FileSystem.IOption)">
            <summary>
            Print tree structure of the whole filesystem. 
            
            Starts at <paramref name="path"/> if provided, otherwise starts at root "".
            <paramref name="depth"/> sets maximum visit depths.
            
            ""
            ""
            "mnt"
            "tmp"
            "helloworld.txt"
            "usr"
               "lex"
            "c:"
               "dir"
                  "dir"
            
            
            Any thrown exceptions are printed into the line that produced the error.
            </summary>
            <param name="filesystem"></param>
            <param name="path"></param>
            <param name="depth">maximum visit depth</param>
            <param name="format">print format</param>
            <param name="option">(null) session or security token</param>
            <returns>Tree as string</returns>
        </member>
        <member name="T:Lexical.FileSystem.TreeVisit">
            <summary>
            Visit extension methods for <see cref="T:Lexical.FileSystem.IFileSystem"/>.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.TreeVisit.VisitTree(Lexical.FileSystem.IFileSystem,System.String,System.Int32,Lexical.FileSystem.IOption)">
            <summary>
            Vists tree structure of filesystem. 
            
            Starts at <paramref name="path"/> if provided, otherwise starts at root "".
            <paramref name="depth"/> sets maximum visit depths.
            
            ""
            ""
            "mnt"
            "tmp"
            "helloworld.txt"
            "usr"
               "lex"
            "c:"
               "dir"
                  "dir"
            
            
            Any thrown exceptions are printed into the line that produced the error.
            </summary>
            <param name="filesystem"></param>
            <param name="path"></param>
            <param name="depth">maximum visit depth</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <exception cref="T:System.Exception">any exception that GetEntry or Browse can throw</exception>
            <exception cref="T:System.IO.IOException">If Browse returns an entry whose path is not under parent entry's path</exception>
        </member>
        <member name="T:Lexical.FileSystem.TreeVisit.Line">
            <summary>
            Tree visit line.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.TreeVisit.Line.Entry">
            <summary>
            Visited tree entry.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.TreeVisit.Line.Level">
            <summary>
            Visit depth, starts at 0.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.TreeVisit.Line.LevelContinuesBitMask">
            <summary>
            Bitmask for each level on whether the level has more entries to come in the enumerator.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.TreeVisit.Line.Error">
            <summary>
            (optional) Browse() error is placed here.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.TreeVisit.Line.Path">
            <summary>
            Entry path.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.TreeVisit.Line.Name">
            <summary>
            Entry name.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.TreeVisit.Line.#ctor(Lexical.FileSystem.IEntry,System.Int32,System.UInt64,System.Exception)">
            <summary>
            Create line
            </summary>
            <param name="entry"></param>
            <param name="level"></param>
            <param name="levelContinuesBitMask"></param>
            <param name="error">(optional) initial error</param>
        </member>
        <member name="M:Lexical.FileSystem.TreeVisit.Line.NewLevelContinuesBitMask(System.UInt64)">
            <summary>
            Create line with new value to <see cref="F:Lexical.FileSystem.TreeVisit.Line.LevelContinuesBitMask"/>.
            </summary>
            <param name="newLevelContinuesBitMask"></param>
            <returns>line with new mask</returns>
        </member>
        <member name="M:Lexical.FileSystem.TreeVisit.Line.LevelContinues(System.Int32)">
            <summary>
            Tests whether there will be more entries to specific <paramref name="level"/>.
            </summary>
            <param name="level"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.TreeVisit.Line.AppendTo(System.Text.StringBuilder,Lexical.FileSystem.PrintTree.Format)">
            <summary>
            Write to <see cref="T:System.Text.StringBuilder"/> <paramref name="output"/>.
            </summary>
            <param name="output"></param>
            <param name="format">print format</param>
        </member>
        <member name="M:Lexical.FileSystem.TreeVisit.Line.WriteTo(System.IO.TextWriter,Lexical.FileSystem.PrintTree.Format)">
            <summary>
            Write to <see cref="T:System.Text.StringBuilder"/> <paramref name="output"/>.
            </summary>
            <param name="output"></param>
            <param name="format">print format</param>
        </member>
        <member name="M:Lexical.FileSystem.TreeVisit.Line.ToString">
            <summary>
            Print line info.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.TreeVisit.Line.ToString(Lexical.FileSystem.PrintTree.Format)">
            <summary>
            Print line info.
            </summary>
            <param name="format">print format</param>
            <returns></returns>
        </member>
        <member name="T:Lexical.FileSystem.TreeVisit.Line.Comparer">
            <summary>Comparer that sorts by: Type, Name.</summary>
        </member>
        <member name="F:Lexical.FileSystem.TreeVisit.Line.Comparer.typeNameComparer">
            <summary>Comparer that sorts by: Type, Name.</summary>
        </member>
        <member name="P:Lexical.FileSystem.TreeVisit.Line.Comparer.TypeNameComparer">
            <summary>Comparer that sorts by: Type, Name.</summary>
        </member>
        <member name="F:Lexical.FileSystem.TreeVisit.Line.Comparer.entryComparer">
            <summary>Entry comparer</summary>
        </member>
        <member name="M:Lexical.FileSystem.TreeVisit.Line.Comparer.Compare(Lexical.FileSystem.TreeVisit.Line,Lexical.FileSystem.TreeVisit.Line)">
            <summary>
            Sort by type, then name, using AlphaNumericComparer
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.TreeVisit.Line.Comparer.#ctor(System.Collections.Generic.IComparer{Lexical.FileSystem.IEntry})">
            <summary>
            Create comparer
            </summary>
            <param name="entryComparer"></param>
        </member>
        <member name="T:Lexical.FileSystem.HttpFileSystem">
            <summary>
            Simple "http://" based filesystem that can download documents.
            
            HttpFileSystem utilizes three kinds of <see cref="T:Lexical.FileSystem.ITokenObject"/>s:
            <list type="bullet">
                <item>Key=<see cref="F:Lexical.FileSystem.HttpFileSystem.TOKEN_HEADERS"/> as Type=IEnumerable{KeyValuePair{string, IEnumerable{string}}}</item>
                <item>Key=<see cref="F:Lexical.FileSystem.HttpFileSystem.TOKEN_AUTHENTICATION"/> as Type=<see cref="T:System.Net.Http.Headers.AuthenticationHeaderValue"/></item>
                <item>Key=<see cref="T:System.Threading.CancellationToken"/>.FullName as Type=<see cref="T:System.Threading.CancellationToken"/></item>
            </list>
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.HttpFileSystem.TOKEN_HEADERS">
            <summary>
            Token key for http headers. 
            
            Token type is IEnumerable{KeyValuePair{string, IEnumerable{string}}}.
            "System.Net.Http.Headers.HttpHeaders"
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.HttpFileSystem.TOKEN_AUTHENTICATION">
            <summary>
            Token key for authentication. 
            
            Token type is <see cref="T:System.Net.Http.Headers.AuthenticationHeaderValue"/>.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.HttpFileSystem.instance">
            <summary>Default singleton instance.</summary>
        </member>
        <member name="P:Lexical.FileSystem.HttpFileSystem.Instance">
            <summary>Default singleton instance.</summary>
        </member>
        <member name="P:Lexical.FileSystem.HttpFileSystem.CanOpen">
            <summary></summary>
        </member>
        <member name="P:Lexical.FileSystem.HttpFileSystem.CanRead">
            <summary></summary>
        </member>
        <member name="P:Lexical.FileSystem.HttpFileSystem.CanWrite">
            <summary></summary>
        </member>
        <member name="P:Lexical.FileSystem.HttpFileSystem.CanCreateFile">
            <summary></summary>
        </member>
        <member name="P:Lexical.FileSystem.HttpFileSystem.CanDelete">
            <summary></summary>
        </member>
        <member name="P:Lexical.FileSystem.HttpFileSystem.CanBrowse">
            <summary></summary>
        </member>
        <member name="P:Lexical.FileSystem.HttpFileSystem.CanGetEntry">
            <summary></summary>
        </member>
        <member name="F:Lexical.FileSystem.HttpFileSystem.options">
            <summary>Options</summary>
        </member>
        <member name="F:Lexical.FileSystem.HttpFileSystem.token">
            <summary>(optional) token</summary>
        </member>
        <member name="T:Lexical.FileSystem.HttpFileSystem.Options">
            <summary>options</summary>
        </member>
        <member name="P:Lexical.FileSystem.HttpFileSystem.Options.Instance">
            <summary>Instance with all true</summary>
        </member>
        <member name="P:Lexical.FileSystem.HttpFileSystem.Options.CanOpen">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.HttpFileSystem.Options.CanRead">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.HttpFileSystem.Options.CanWrite">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.HttpFileSystem.Options.CanCreateFile">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.HttpFileSystem.Options.CanDelete">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.HttpFileSystem.Options.CanBrowse">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.HttpFileSystem.Options.CanGetEntry">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.HttpFileSystem.Options.SubPath">
            <inheritdoc/>
        </member>
        <member name="M:Lexical.FileSystem.HttpFileSystem.Options.Read(Lexical.FileSystem.IOption)">
            <summary>Read from <paramref name="option"/></summary>
            <param name="option"></param>
            <returns>this</returns>
        </member>
        <member name="F:Lexical.FileSystem.HttpFileSystem.httpClient">
            <summary>
            Client object.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.HttpFileSystem.#ctor(System.Net.Http.HttpClient,Lexical.FileSystem.IOption)">
            <summary>
            Create http:// filesystem.
            
            HttpFileSystem is intended 
            </summary>
            <param name="httpClient">(optional) httpClient instance to use, or null to have new created</param>
            <param name="option">(optional) options</param>
        </member>
        <member name="M:Lexical.FileSystem.HttpFileSystem.CreateOptions">
            <summary>Override this</summary>
        </member>
        <member name="T:Lexical.FileSystem.HttpFileSystem.NonDisposable">
            <summary>
            Non-disposable <see cref="T:Lexical.FileSystem.HttpFileSystem"/> disposes and cleans all attached <see cref="T:System.IDisposable"/> on dispose, but doesn't go into disposed state.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.HttpFileSystem.NonDisposable.#ctor">
            <summary>Create non-disposable http-filesystem.</summary>
        </member>
        <member name="M:Lexical.FileSystem.HttpFileSystem.ReadTokenToHeaders(System.String,Lexical.FileSystem.IOption,System.Net.Http.Headers.HttpHeaders)">
            <summary>
            Reads possible tokens from two sources, this.tokens and from <paramref name="t"/>.
            Writes to <paramref name="headers"/>.
            
            Searches for following keys:
            <list type="bullet">
                <item>"System.Net.Http.Headers.HttpHeaders" as IEnumerable{KeyValuePair{string, IEnumerable{string}}}</item>
            </list>
            
            Appends "User-Agent" is one is not set.
            </summary>
            <param name="uri">Uri to use as token query criteria</param>
            <param name="t">(optional)</param>
            <param name="headers"></param>
        </member>
        <member name="M:Lexical.FileSystem.HttpFileSystem.Open(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,Lexical.FileSystem.IOption)">
            <summary>
            Open a file for reading or writing. 
            
            To GET a file, the combination of <see cref="F:System.IO.FileMode.Open"/> and <see cref="F:System.IO.FileAccess.Read"/> issues a GET request on <paramref name="uri"/>.
            Returns async stream that may not yet have been fully loaded.
            
            To PUT a file, the combination of <see cref="F:System.IO.FileMode.Create"/>, <see cref="F:System.IO.FileMode.CreateNew"/> or <see cref="F:System.IO.FileMode.Truncate"/>, and <see cref="F:System.IO.FileAccess.Write"/> issues a request on <paramref name="uri"/>.
            Returns a memory stream that can be written to. 
            
            <paramref name="fileShare"/> is ignored.
            
            Authentication header can be placed in <paramref name="option"/> as instance of <see cref="T:System.Net.Http.Headers.AuthenticationHeaderValue"/> wrapped in (for example) <see cref="T:Lexical.FileSystem.Token"/> or <see cref="T:Lexical.FileSystem.TokenList"/>.
            
            Other <see cref="T:System.Net.Http.Headers.HttpHeaders"/> can also placed in <paramref name="option"/>.
            
            <see cref="T:System.Threading.CancellationToken"/> can be placed in <paramref name="option"/>.
            </summary>
            <param name="uri">Relative path to file. Directory separator is "/". Root is without preceding "/", e.g. "dir/file.xml"</param>
            <param name="fileMode">determines whether to open or to create the file</param>
            <param name="fileAccess">how to access the file, read, write or read and write</param>
            <param name="fileShare">how the file will be shared by processes</param>
            <param name="option">(optional) Credentials</param>
            <returns>open file stream</returns>
            <exception cref="T:Lexical.FileSystem.FileSystemException">On unexpected IO error</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="uri"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="uri"/> is an empty string (""), contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support opening files</exception>
            <exception cref="T:System.IO.FileNotFoundException">The file cannot be found, such as when mode is FileMode.Truncate or FileMode.Open, and and the file specified by path does not exist. The file must already exist in these modes.</exception>
            <exception cref="T:System.IO.DirectoryNotFoundException">The specified path is invalid, such as being on an unmapped drive.</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="fileMode"/>, <paramref name="fileAccess"/> or <paramref name="fileShare"/> contains an invalid value.</exception>
            <exception cref="T:System.InvalidOperationException">If <paramref name="uri"/> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc.</exception>
            <exception cref="T:System.ObjectDisposedException"/>
            <exception cref="T:Lexical.FileSystem.FileSystemExceptionNoReadAccess">No read access</exception>
            <exception cref="T:Lexical.FileSystem.FileSystemExceptionNoWriteAccess">No write access</exception>
            <exception cref="T:System.OperationCanceledException">operation canceled</exception>
        </member>
        <member name="T:Lexical.FileSystem.HttpFileSystem.WriteStream">
            <summary>
            Stream that notifies <see cref="T:Lexical.FileSystem.HttpFileSystem.FileSystemHttpContent"/> when closed.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.HttpFileSystem.WriteStream.taskToNotifyOnceClosed">
            <summary>Task to notify</summary>
        </member>
        <member name="F:Lexical.FileSystem.HttpFileSystem.WriteStream.responseTask">
            <summary>Response task</summary>
        </member>
        <member name="F:Lexical.FileSystem.HttpFileSystem.WriteStream.filesystem">
            <summary>Filesystem</summary>
        </member>
        <member name="F:Lexical.FileSystem.HttpFileSystem.WriteStream.uri">
            <summary>Uri</summary>
        </member>
        <member name="M:Lexical.FileSystem.HttpFileSystem.WriteStream.#ctor(System.IO.Stream,System.Threading.Tasks.TaskCompletionSource{System.IO.Stream},System.Threading.Tasks.Task{System.Net.Http.HttpResponseMessage},Lexical.FileSystem.IFileSystem,System.String)">
            <summary>Create write stream</summary>
            <param name="sourceStream"></param>
            <param name="taskToNotifyOnceClosed">Task to notify when stream is completed</param>
            <param name="responseTask">request task</param>
            <param name="filesystem"></param>
            <param name="uri"></param>
        </member>
        <member name="M:Lexical.FileSystem.HttpFileSystem.WriteStream.InnerDispose(Lexical.FileSystem.Internal.StructList4{System.Exception}@)">
            <summary>
            Notify <see cref="T:Lexical.FileSystem.HttpFileSystem.FileSystemHttpContent"/>.
            </summary>
            <param name="disposeErrors"></param>
        </member>
        <member name="T:Lexical.FileSystem.HttpFileSystem.FileSystemHttpContent">
            <summary>
            Captures stream and signals on capture.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.HttpFileSystem.FileSystemHttpContent.tcs">
            <summary>
            Used for signaling completion.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.HttpFileSystem.FileSystemHttpContent.Stream">
            <summary>
            Captured stream.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.HttpFileSystem.FileSystemHttpContent.Semaphore">
            <summary>
            Signal semaphore
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.HttpFileSystem.FileSystemHttpContent.SerializeToStreamAsync(System.IO.Stream,System.Net.TransportContext)">
            <summary>
            Serialize the HTTP content to a stream as an asynchronous operation.
            </summary>
            <param name="stream">The target stream.</param>
            <param name="context">Information about the transport (channel binding token, for example). This parameter may be null.</param>
            <returns>The task object representing the asynchronous operation.</returns>
        </member>
        <member name="M:Lexical.FileSystem.HttpFileSystem.FileSystemHttpContent.TryComputeLength(System.Int64@)">
            <summary>
            Determines whether the HTTP content has a valid length in bytes.
            </summary>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.HttpFileSystem.DeleteAsync(System.String,System.Boolean,Lexical.FileSystem.IOption)">
            <summary>
            Delete resource at <paramref name="uri"/>.
            
            <paramref name="recurse"/> is ignored..
            
            Authentication header can be placed in <paramref name="option"/> as instance of <see cref="T:System.Net.Http.Headers.AuthenticationHeaderValue"/> wrapped in (for example) <see cref="T:Lexical.FileSystem.Token"/> or <see cref="T:Lexical.FileSystem.TokenList"/>.
            
            Other <see cref="T:System.Net.Http.Headers.HttpHeaders"/> can also placed in <paramref name="option"/>.
            
            <see cref="T:System.Threading.CancellationToken"/> can be placed in <paramref name="option"/>.
            </summary>
            <param name="uri">path to a file or directory</param>
            <param name="recurse">value is ignored</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <exception cref="T:System.IO.FileNotFoundException">The specified path is invalid.</exception>
            <exception cref="T:System.IO.IOException">On unexpected IO error, or if <paramref name="uri"/> refered to a directory that wasn't empty and <paramref name="recurse"/> is false, or trying to delete root when not allowed</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="uri"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="uri"/> contains invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support deleting files</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters.</exception>
            <exception cref="T:System.InvalidOperationException"><paramref name="uri"/> refers to non-file device</exception>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="M:Lexical.FileSystem.HttpFileSystem.BrowseAsync(System.String,Lexical.FileSystem.IOption)">
            <summary>
            Read <paramref name="uri"/> and parse anchors for file references.
            </summary>
            <param name="uri"></param>
            <param name="option"></param>
            <returns>child links</returns>
        </member>
        <member name="M:Lexical.FileSystem.HttpFileSystem.GetEntryAsync(System.String,Lexical.FileSystem.IOption)">
            <summary>
            Tests if document exists without attempting to download it completely.
            
            Estimates that <paramref name="uri"/> refers to a directory if path ends with '/'.
            </summary>
            <param name="uri"></param>
            <param name="option"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.HttpFileSystem.GetEntryName(System.String)">
            <summary>
            Extracts file or directory name from <paramref name="uri"/>.
            
            Examples:
            <list type="bullet">
                <item>http://lexical.fi/Dir/                      -> "Dir"</item>
                <item>http://lexical.fi/Dir/file.txt              -> "file.txt"</item>
                <item>http://lexical.fi/Dir/?query=value          -> "Dir"</item>
                <item>http://lexical.fi/Dir/file.txt?query=value  -> "file.txt"</item>
            </list>
            </summary>
            <param name="uri"></param>
            <returns>extracted name or null</returns>
        </member>
        <member name="F:Lexical.FileSystem.HttpFileSystem.anchorPattern">
            <summary>
            Pattern that searches for html anchors
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.HttpFileSystem.ReadEntries(System.String,System.String,Lexical.FileSystem.IPathConverter)">
            <summary>
            Reads through html <paramref name="html"/> and scans for anchor elements with "href" attributes.
            Validates local or global links that refer to a subfile or subdirectory.
            </summary>
            <param name="baseUri">The uri where the document was loaded. Used for creating absolute uris from relative uris.</param>
            <param name="html">document data as stream</param>
            <param name="pathConverter">convert child urls (the real URIs) back to parent (API caller's) path format</param>
            <returns>array of files</returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:Lexical.FileSystem.HttpFileSystem.InnerDispose(Lexical.FileSystem.Internal.StructList4{System.Exception}@)">
            <summary>Handle dispose</summary>
        </member>
        <member name="M:Lexical.FileSystem.HttpFileSystem.AddSourceToBeDisposed">
            <summary>
            Adds the attached <see cref="T:System.Net.Http.HttpClient"/> to be disposed along with this filesystem.
            </summary>
            <returns>self</returns>
        </member>
        <member name="M:Lexical.FileSystem.HttpFileSystem.AddDisposeAction(System.Action{System.Object},System.Object)">
            <summary>
            Invoke <paramref name="disposeAction"/> on the dispose of the object.
            
            If parent object is disposed or being disposed, the disposable will be disposed immedialy.
            </summary>
            <param name="disposeAction"></param>
            <param name="state"></param>
            <returns>self</returns>
        </member>
        <member name="M:Lexical.FileSystem.HttpFileSystem.AddDisposable(System.Object)">
            <summary>
            Add <paramref name="disposable"/> to list of objects to be disposed along with the system.
            </summary>
            <param name="disposable"></param>
            <returns>filesystem</returns>
        </member>
        <member name="M:Lexical.FileSystem.HttpFileSystem.AddDisposables(System.Collections.IEnumerable)">
            <summary>
            Add <paramref name="disposables"/> to list of objects to be disposed along with the system.
            </summary>
            <param name="disposables"></param>
            <returns>filesystem</returns>
        </member>
        <member name="M:Lexical.FileSystem.HttpFileSystem.RemoveDisposable(System.Object)">
            <summary>
            Remove <paramref name="disposable"/> from dispose list.
            </summary>
            <param name="disposable"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.HttpFileSystem.RemoveDisposables(System.Collections.IEnumerable)">
            <summary>
            Remove <paramref name="disposables"/> from dispose list.
            </summary>
            <param name="disposables"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.HttpFileSystem.ToString">
            <summary>Print info</summary>
        </member>
        <member name="T:Lexical.FileSystem.Internal.AlphaNumericComparer">
            <summary>
            Alpha numeric string comparer. 
            Considers numeric character sequences as numbers which are compared with number sorters.
            
            For example: strings "a1", "a10", "a9" would be sorted to "a1", "a9", "a10".
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Internal.AlphaNumericComparer.Default">
            <summary>
            Singleton instance
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.AlphaNumericComparer.pattern">
            <summary>
            Pattern that classifies a substring either as number or text groups.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Internal.AlphaNumericComparer.StringCompare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
            <summary>
            Placeholder for making text literal comparisons.
            
            Override this to change behaviour.
            </summary>
            <param name="x"></param>
            <param name="x_ix"></param>
            <param name="y"></param>
            <param name="y_ix"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.AlphaNumericComparer.Compare(System.Object,System.Object)">
            <summary>
            Compare uncasted objects. Calls ToString().
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.AlphaNumericComparer.Compare(System.String,System.String)">
            <summary>
            Compare strings.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="T:Lexical.FileSystem.Internal.ArrayList`1">
            <summary>
            Thread-safe <see cref="T:System.Collections.Generic.IList`1"/> collection. 
            
            List is modified under mutually exclusive lock <see cref="P:Lexical.FileSystem.Internal.ArrayList`1.SyncRoot"/>.
            
            <see cref="P:Lexical.FileSystem.Internal.ArrayList`1.Array"/> and <see cref="M:Lexical.FileSystem.Internal.ArrayList`1.GetEnumerator"/> creates a snapshot array, which won't throw <see cref="T:System.InvalidOperationException"/> 
            if list is modified while being enumerated.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.ArrayList`1.EmptyArray">
            <summary>Empty array of T</summary>
        </member>
        <member name="P:Lexical.FileSystem.Internal.ArrayList`1.Item(System.Int32)">
            <summary>
            Get or set an element at <paramref name="index"/>.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:Lexical.FileSystem.Internal.ArrayList`1.Count">
            <summary>The number of elements.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Internal.ArrayList`1.IsReadOnly">
            <summary>Is in readonly state</summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.ArrayList`1.snapshot">
            <summary>
            Last snapshot. This snapshot is cleared when internal <see cref="P:Lexical.FileSystem.Internal.ArrayList`1.list"/> is modified.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Internal.ArrayList`1.Array">
            <summary>
            Array snapshot of current contents. Makes a snapshot if retrieved after content is modified.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.ArrayList`1._list">
            <summary>Internal list. Lazy allocation.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Internal.ArrayList`1.list">
            <summary>Internal list. Lazy allocation.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Internal.ArrayList`1.IsSynchronized">
            <summary>Is synchronized</summary>
        </member>
        <member name="P:Lexical.FileSystem.Internal.ArrayList`1.SyncRoot">
            <summary>object that can be used to synchronize access</summary>
        </member>
        <member name="M:Lexical.FileSystem.Internal.ArrayList`1.#ctor">
            <summary>
            Create copy-on-write list
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Internal.ArrayList`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Create copy-on-write list.
            </summary>
            <param name="strsEnumr"></param>
        </member>
        <member name="M:Lexical.FileSystem.Internal.ArrayList`1.BuildArray">
            <summary>
            Construct array
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.ArrayList`1.ClearCache">
            <summary>
            Clear last array
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Internal.ArrayList`1.Add(`0)">
            <summary>
            Add element
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Lexical.FileSystem.Internal.ArrayList`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add elements
            </summary>
            <param name="items"></param>
        </member>
        <member name="M:Lexical.FileSystem.Internal.ArrayList`1.Clear">
            <summary>
            Clear elements
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Internal.ArrayList`1.Contains(`0)">
            <summary>
            Test if contains element
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.ArrayList`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copy elements to array
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="M:Lexical.FileSystem.Internal.ArrayList`1.CopyTo(System.Array,System.Int32)">
            <summary>
            Copy elements to array
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="M:Lexical.FileSystem.Internal.ArrayList`1.IndexOf(`0)">
            <summary>
            Index of element.
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.ArrayList`1.Insert(System.Int32,`0)">
            <summary>
            Insert element
            </summary>
            <param name="index"></param>
            <param name="item"></param>
        </member>
        <member name="M:Lexical.FileSystem.Internal.ArrayList`1.CopyFrom(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Copy elements from <paramref name="newContent"/>.
            </summary>
            <param name="newContent"></param>
        </member>
        <member name="M:Lexical.FileSystem.Internal.ArrayList`1.Reverse">
            <summary>
            Reverse elements.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Internal.ArrayList`1.Remove(`0)">
            <summary>
            Remove element
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.ArrayList`1.RemoveAt(System.Int32)">
            <summary>
            Remove element at index.
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:Lexical.FileSystem.Internal.ArrayList`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Get enumerator to a snapsot list. Enumerator will not throw <see cref="T:System.InvalidOperationException"/>.
            </summary>
            <returns>enumerator</returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.ArrayList`1.GetEnumerator">
            <summary>
            Get enumerator to a snapsot list. Enumerator not throw <see cref="T:System.InvalidOperationException"/>.
            </summary>
            <returns>enumerator</returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.ArrayList`1.ToString">
            <summary>Print info</summary>
        </member>
        <member name="T:Lexical.FileSystem.Internal.GlobPatternInfo">
            <summary>
            Separates wildcard pattern string into two parts.
            
            First part contains directory levels without any wilcards.
            Second parts contains all the directory levels after first wildcard.
            
            Used for estimating the location and size of subtree a pattern represents.
            
            For example "dir/**/file.txt" is split into "dir/" and "**/file.txt".
            
            Examples:
              Pattern=dir/dir/file.txt, Stem=dir/dir/file.txt, Suffix=, SuffixDepth=0
              Pattern=*.txt, Stem=, Suffix=*.txt, SuffixDepth=1
              Pattern=**.txt, Stem=, Suffix=**.txt, SuffixDepth=2147483647
              Pattern=/*.txt, Stem=/, Suffix=*.txt, SuffixDepth=1
              Pattern=*/*.txt, Stem=, Suffix=*/*.txt, SuffixDepth=2
              Pattern=/**.txt, Stem=/, Suffix=**.txt, SuffixDepth=2147483647
              Pattern=dir/dir/*/*.txt, Stem=dir/dir/, Suffix=*/*.txt, SuffixDepth=2
              Pattern=dir/dir?/*/*.txt, Stem=dir/, Suffix=dir?/*/*.txt, SuffixDepth=3
              Pattern=dir/dir/dir/*/*.txt, Stem=dir/dir/dir/, Suffix=*/*.txt, SuffixDepth=2
              Pattern=dir/dir/dir?/*/*.txt, Stem=dir/dir/, Suffix=dir?/*/*.txt, SuffixDepth=3
              Pattern=dir/dir/dir?/*/**.txt, Stem=dir/dir/, Suffix=dir?/*/**.txt, SuffixDepth=2147483647
              Pattern=dir/*/dir/dir/dir/file.txt, Stem=dir/, Suffix=*/dir/dir/dir/file.txt, SuffixDepth=5
              
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.GlobPatternInfo.Pattern">
            <summary>Full pattern string.</summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.GlobPatternInfo.Stem">
            <summary>The stem part of <see cref="F:Lexical.FileSystem.Internal.GlobPatternInfo.Pattern"/> that doesn't have wild cards. The directories and filename before first entry with a wildcard character '*'/'**'/'?'.</summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.GlobPatternInfo.Suffix">
            <summary>The latter part of <see cref="F:Lexical.FileSystem.Internal.GlobPatternInfo.Pattern"/>, the string after first directory that has wildcards.</summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.GlobPatternInfo.SuffixDepth">
            <summary>
            Number of directory levels in <see cref="F:Lexical.FileSystem.Internal.GlobPatternInfo.Suffix"/>.
            
            Depth is 0 if there are no wildcard characters in <see cref="F:Lexical.FileSystem.Internal.GlobPatternInfo.Pattern"/>.
            Depth is 1 if there are wildcard characters '?'/'*' in one directory.
            Depth is n if there are wildcard characters '?'/'*' in n directories after <see cref="F:Lexical.FileSystem.Internal.GlobPatternInfo.Stem"/> part.
            Depth is <see cref="F:System.Int32.MaxValue"/>, if there is **' wildcards anywhere.
            
            Examples:
                Pattern="dir/dir/file.txt", Stem="dir/dir/file.txt", Suffix="", depth = 0
                Pattern="dir/dir/*.txt", Stem="dir/dir/", Suffix="*.txt", depth = 1
                Pattern="dir/dir/*/*.txt", Stem="dir/dir/", Suffix="*/*.txt", depth = 2
                Pattern="dir/dir/dir?/*/*.txt", Stem="dir/dir/", Suffix="dir?/*/*.txt", depth = 3
                Pattern="dir/*/dir/dir/dir/file.txt", Stem="dir/", Suffix="*/dir/dir/dir/file.txt", depth = 5
                Pattern="dir/dir/**.txt", Stem="dir/dir/", Suffix="**", depth = int.MaxValue
                
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Internal.GlobPatternInfo.op_Implicit(Lexical.FileSystem.Internal.GlobPatternInfo)~System.String">
            <summary>Implicit conversion</summary>
        </member>
        <member name="M:Lexical.FileSystem.Internal.GlobPatternInfo.op_Implicit(System.String)~Lexical.FileSystem.Internal.GlobPatternInfo">
            <summary>Implicit conversion</summary>
        </member>
        <member name="M:Lexical.FileSystem.Internal.GlobPatternInfo.#ctor(System.String)">
            <summary>
            Create filter info.
            
            If <paramref name="pattern"/> is null, then monitors any file in the path, but not subdirectories.
            <paramref name="pattern"/> is "**" then monitors any file in subdirectories.
            
            </summary>
            <param name="pattern">glob pattern, e.g. "dir/**.txt"</param>
        </member>
        <member name="M:Lexical.FileSystem.Internal.GlobPatternInfo.ToString">
            <summary>
            Info
            </summary>
            <returns></returns>
        </member>
        <member name="T:Lexical.FileSystem.Internal.GlobPatternSet">
            <summary>
            Glob pattern set theory operations
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Internal.GlobPatternSet.Union(System.String,System.String)">
            <summary>
            Create union of <paramref name="leftPattern"/> and <paramref name="rightPattern"/>.
            </summary>
            <param name="leftPattern"></param>
            <param name="rightPattern"></param>
            <returns>union that contains <paramref name="leftPattern"/> and <paramref name="rightPattern"/>. May return broader union that minimal due to lack of expression capability to hold in a single pattern string.</returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.GlobPatternSet.Unions(System.String,System.String)">
            <summary>
            Create unions of <paramref name="leftPattern"/> and <paramref name="rightPattern"/>.
            </summary>
            <param name="leftPattern"></param>
            <param name="rightPattern"></param>
            <returns>unions</returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.GlobPatternSet.Intersection(System.String,System.String)">
            <summary>
            Create intersection of <paramref name="pattern1"/> and <paramref name="pattern2"/>.
            </summary>
            <param name="pattern1"></param>
            <param name="pattern2"></param>
            <returns>intersection or null if patterns do not intersect. May return broader intersection that minimal due to lack of expression capability to hold in a single pattern string.</returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.GlobPatternSet.Intersections(System.String,System.String)">
            <summary>
            Create intersections of <paramref name="leftPattern"/> and <paramref name="rightPattern"/>.
            </summary>
            <param name="leftPattern"></param>
            <param name="rightPattern"></param>
            <returns>intersections</returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.GlobPatternSet.Print(System.Collections.Generic.List{Lexical.FileSystem.Internal.GlobPatternSet.Token})">
            <summary>
            Print <paramref name="tokens"/> to string.
            </summary>
            <param name="tokens"></param>
            <returns></returns>
        </member>
        <member name="F:Lexical.FileSystem.Internal.GlobPatternSet.Line.li">
            <summary>Left and right token indices</summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.GlobPatternSet.Line.ri">
            <summary>Left and right token indices</summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.GlobPatternSet.Line.tokens">
            <summary>(optional)List of tokens</summary>
        </member>
        <member name="T:Lexical.FileSystem.Internal.GlobPatternSet.Token">
            <summary>
            Glob pattern token
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.GlobPatternSet.Token.None">
            <summary>Non-content token</summary>
        </member>
        <member name="M:Lexical.FileSystem.Internal.GlobPatternSet.Token.op_Implicit(Lexical.FileSystem.Internal.GlobPatternSet.Token)~Lexical.FileSystem.Internal.GlobPatternSet.Token.Type">
            <summary>Implicit conversion</summary>
        </member>
        <member name="M:Lexical.FileSystem.Internal.GlobPatternSet.Token.op_Implicit(Lexical.FileSystem.Internal.GlobPatternSet.Token)~System.Char">
            <summary>Implicit conversion</summary>
        </member>
        <member name="M:Lexical.FileSystem.Internal.GlobPatternSet.Token.op_Implicit(Lexical.FileSystem.Internal.GlobPatternSet.Token.Type)~Lexical.FileSystem.Internal.GlobPatternSet.Token">
            <summary>Implicit conversion</summary>
        </member>
        <member name="M:Lexical.FileSystem.Internal.GlobPatternSet.Token.op_Implicit(System.Char)~Lexical.FileSystem.Internal.GlobPatternSet.Token">
            <summary>Implicit conversion</summary>
        </member>
        <member name="T:Lexical.FileSystem.Internal.GlobPatternSet.Token.Type">
            <summary>Token type</summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.GlobPatternSet.Token.Type.None">
            <summary>not initialized</summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.GlobPatternSet.Token.Type.Slash">
            <summary>"/"</summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.GlobPatternSet.Token.Type.QuestionMark">
            <summary>"?"</summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.GlobPatternSet.Token.Type.Star">
            <summary>"*"</summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.GlobPatternSet.Token.Type.StarStar">
            <summary>"**"</summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.GlobPatternSet.Token.Type.Char">
            <summary>any other character</summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.GlobPatternSet.Token.Kind">
            <summary>Literal type</summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.GlobPatternSet.Token.Char">
            <summary>Characters</summary>
        </member>
        <member name="M:Lexical.FileSystem.Internal.GlobPatternSet.Token.#ctor(Lexical.FileSystem.Internal.GlobPatternSet.Token.Type)">
            <summary>Create record of token</summary>
        </member>
        <member name="M:Lexical.FileSystem.Internal.GlobPatternSet.Token.#ctor(System.Char)">
            <summary>Create record of token</summary>
        </member>
        <member name="M:Lexical.FileSystem.Internal.GlobPatternSet.Token.op_Equality(Lexical.FileSystem.Internal.GlobPatternSet.Token,Lexical.FileSystem.Internal.GlobPatternSet.Token)">
            <summary>Compare equality.</summary>
        </member>
        <member name="M:Lexical.FileSystem.Internal.GlobPatternSet.Token.op_Inequality(Lexical.FileSystem.Internal.GlobPatternSet.Token,Lexical.FileSystem.Internal.GlobPatternSet.Token)">
            <summary>Compare inequality.</summary>
        </member>
        <member name="M:Lexical.FileSystem.Internal.GlobPatternSet.Token.Equals(Lexical.FileSystem.Internal.GlobPatternSet.Token)">
            <summary>Compare equality.</summary>
        </member>
        <member name="M:Lexical.FileSystem.Internal.GlobPatternSet.Token.Equals(System.Object)">
            <summary>Compare equality.</summary>
        </member>
        <member name="M:Lexical.FileSystem.Internal.GlobPatternSet.Token.GetHashCode">
            <summary>Get hashcode.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Internal.GlobPatternSet.Token.Length">
            <summary>Number of characters</summary>
        </member>
        <member name="M:Lexical.FileSystem.Internal.GlobPatternSet.Token.AppendTo(System.Text.StringBuilder)">
            <summary>Append to string builder</summary>
        </member>
        <member name="M:Lexical.FileSystem.Internal.GlobPatternSet.Token.ToString">
            <summary>Print info</summary>
        </member>
        <member name="T:Lexical.FileSystem.Internal.GlobPatternSet.Token.Enumerable">
            <summary>
            Glob pattern token enumerable
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.GlobPatternSet.Token.Enumerable.Pattern">
            <summary>Glob pattern string</summary>
        </member>
        <member name="M:Lexical.FileSystem.Internal.GlobPatternSet.Token.Enumerable.#ctor(System.String)">
            <summary>Create glob pattern enumerable.</summary>
            <param name="pattern"></param>
        </member>
        <member name="M:Lexical.FileSystem.Internal.GlobPatternSet.Token.Enumerable.GetEnumerator">
            <summary>Get enumerator</summary>
            <returns></returns>
        </member>
        <member name="T:Lexical.FileSystem.Internal.GlobPatternSet.Token.Enumerator">
            <summary>
            Glob pattern token enumerator
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.GlobPatternSet.Token.Enumerator.Pattern">
            <summary>Glob pattern string</summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.GlobPatternSet.Token.Enumerator.index">
            <summary>Character index.</summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.GlobPatternSet.Token.Enumerator.current">
            <summary>Current token.</summary>
        </member>
        <member name="M:Lexical.FileSystem.Internal.GlobPatternSet.Token.Enumerator.#ctor(System.String)">
            <summary>Create glob pattern token enumerable.</summary>
            <param name="pattern"></param>
        </member>
        <member name="P:Lexical.FileSystem.Internal.GlobPatternSet.Token.Enumerator.Current">
            <summary>Current token.</summary>
        </member>
        <member name="M:Lexical.FileSystem.Internal.GlobPatternSet.Token.Enumerator.Dispose">
            <summary></summary>
        </member>
        <member name="M:Lexical.FileSystem.Internal.GlobPatternSet.Token.Enumerator.MoveNext">
            <summary>Move to next token</summary>
        </member>
        <member name="M:Lexical.FileSystem.Internal.GlobPatternSet.Token.Enumerator.Reset">
            <summary>Start from beginning.</summary>
        </member>
        <member name="T:Lexical.FileSystem.Internal.PathEnumerable">
            <summary>
            Separates directories and filename from path strings.
            Directory separator is slash '/'. 
            
            Path is not expected to start with separator. 
            
            Examples:
            <list type="bullet">
                <item>"" -> [""]</item>
                <item>"dir/dir/file" -> ["dir", "dir", "file"]</item>
                <item>"dir/dir/path/" -> ["dir", "dir", "path", ""]</item>
                <item>"/mnt/shared/" -> ["", "mnt", "shared", ""]</item>
                <item>"/" -> ["", ""]</item>
                <item>"//" -> ["", "", ""]</item>
            </list>
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Internal.PathEnumerable.GetParent(Lexical.FileSystem.Internal.StringSegment)">
            <summary>
            Get parent path of <paramref name="path"/>.
            
            Examples:
            <list type="bullet">
                <item>"" -> ""</item>
                <item>"/" -> ""</item>
                <item>"dir" -> ""</item>
                <item>"dir/" -> ""</item>
                <item>"dir/file" -> "dir/"</item>
                <item>"dir/dir" -> "dir/"</item>
                <item>"dir/dir/" -> "dir/"</item>
                <item>"dir/dir/dir/" -> "dir/dir/"</item>
            </list>
            </summary>
            <param name="path"></param>
            <returns>parent path</returns>
        </member>
        <member name="F:Lexical.FileSystem.Internal.PathEnumerable.Path">
            <summary>
            Path string.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Internal.PathEnumerable.#ctor(System.String,System.Boolean)">
            <summary>
            Create path string separator.
            </summary>
            <param name="path"></param>
            <param name="ignoreTrailingSlash">If set, trailing slash of <paramref name="path"/> is ignored. for example "/mnt/dir/" registers as "/mnt/dir"</param>
        </member>
        <member name="M:Lexical.FileSystem.Internal.PathEnumerable.#ctor(Lexical.FileSystem.Internal.StringSegment)">
            <summary>
            Create path string separator.
            </summary>
            <param name="path"></param>
        </member>
        <member name="M:Lexical.FileSystem.Internal.PathEnumerable.GetEnumerator">
            <summary>Get enumerator</summary>
            <returns></returns>
        </member>
        <member name="T:Lexical.FileSystem.Internal.PathEnumerator">
            <summary>
            Enumerator of <see cref="T:Lexical.FileSystem.Internal.PathEnumerable"/>.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.PathEnumerator.Path">
            <summary>Path string.</summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.PathEnumerator.startIx">
            <summary>Start index.</summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.PathEnumerator.endIx">
            <summary>End index.</summary>
        </member>
        <member name="M:Lexical.FileSystem.Internal.PathEnumerator.#ctor(System.String,System.Boolean)">
            <summary>
            Create path string separator.
            </summary>
            <param name="path"></param>
            <param name="ignoreTrailingSlash">If set, trailing slash of <paramref name="path"/> is ignored. for example "/mnt/dir/" registers as "/mnt/dir"</param>
        </member>
        <member name="M:Lexical.FileSystem.Internal.PathEnumerator.#ctor(Lexical.FileSystem.Internal.StringSegment)">
            <summary>
            Create path string separator.
            </summary>
            <param name="path"></param>
        </member>
        <member name="P:Lexical.FileSystem.Internal.PathEnumerator.Current">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Internal.PathEnumerator.System#Collections#IEnumerator#Current">
            <inheritdoc/>
        </member>
        <member name="M:Lexical.FileSystem.Internal.PathEnumerator.Reset">
            <inheritdoc/>
        </member>
        <member name="M:Lexical.FileSystem.Internal.PathEnumerator.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:Lexical.FileSystem.Internal.PathEnumerator.MoveNext">
            <inheritdoc/>
        </member>
        <member name="T:Lexical.FileSystem.Internal.StringSegment">
            <summary>
            Span of characters of a <see cref="F:Lexical.FileSystem.Internal.StringSegment.String"/>.
            
            Used as workaround for missing Span class in .NET Standard.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Internal.StringSegment.Item(System.Int32)">
            <summary>
            Character at <paramref name="ix"/>
            </summary>
            <param name="ix"></param>
            <returns>character</returns>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StringSegment.Empty">
            <summary>Empty string ""</summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StringSegment.Dot">
            <summary>String "."</summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StringSegment.DotDot">
            <summary>String ".."</summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StringSegment.Start">
            <summary>Start index</summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StringSegment.Length">
            <summary>Length</summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.StringSegment.String">
            <summary>String</summary>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StringSegment.op_Implicit(Lexical.FileSystem.Internal.StringSegment)~System.String">
            <summary>Implicit converter</summary>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StringSegment.op_Implicit(System.String)~Lexical.FileSystem.Internal.StringSegment">
            <summary>Implicit converter</summary>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StringSegment.#ctor(System.String)">
            <summary>
            Create span of characters.
            </summary>
            <param name="str"></param>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StringSegment.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            Create span of characters.
            </summary>
            <param name="str"></param>
            <param name="start"></param>
            <param name="length"></param>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StringSegment.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StringSegment.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StringSegment.AppendTo(System.Text.StringBuilder)">
            <summary>Append to string builder</summary>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StringSegment.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StringSegment.Equals(Lexical.FileSystem.Internal.StringSegment)">
            <inheritdoc/>
        </member>
        <member name="T:Lexical.FileSystem.Internal.StringSegment.Comparer">
            <summary>
            EqualityComparer
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Internal.StringSegment.Comparer.Instance">
            <summary>
            Singleton instance
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StringSegment.Comparer.Equals(Lexical.FileSystem.Internal.StringSegment,Lexical.FileSystem.Internal.StringSegment)">
            <summary>
            Compare equal content
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.StringSegment.Comparer.GetHashCode(Lexical.FileSystem.Internal.StringSegment)">
            <summary>
            Calculate hashcode for 
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="T:Lexical.FileSystem.Internal.Pair`2">
            <summary>
            Pair (2-tuple). Hashcode is cached. Elements are immutable. Type is stack allocated. 
            </summary>
            <typeparam name="A"></typeparam>
            <typeparam name="B"></typeparam>
        </member>
        <member name="F:Lexical.FileSystem.Internal.Pair`2.a">
            <summary>A</summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.Pair`2.b">
            <summary>B</summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.Pair`2.hashcode">
            <summary>Precalculated hashcode</summary>
        </member>
        <member name="M:Lexical.FileSystem.Internal.Pair`2.#ctor(`0,`1)">
            <summary>
            Create Pair (2-tuple).
            </summary>
            <param name="a"></param>
            <param name="b"></param>
        </member>
        <member name="M:Lexical.FileSystem.Internal.Pair`2.GetHashCode">
            <summary>
            Get Hash-Code
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.Pair`2.Equals(System.Object)">
            <summary>
            Test equality with default element comparer.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.Pair`2.Equals(Lexical.FileSystem.Internal.Pair{`0,`1})">
            <summary>
            Test equality with default element comparer.
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.Pair`2.CompareTo(Lexical.FileSystem.Internal.Pair{`0,`1})">
            <summary>
            Compare order with default element comparer.
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="T:Lexical.FileSystem.Internal.Pair`2.EqualityComparer">
            <summary>
            Equality comparer
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Internal.Pair`2.EqualityComparer.Default">
            <summary>
            Default instance
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.Pair`2.EqualityComparer.aComparer">
            <summary>
            Element A comparer.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.Pair`2.EqualityComparer.bComparer">
            <summary>
            Element B comparer.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Internal.Pair`2.EqualityComparer.#ctor(System.Collections.Generic.IEqualityComparer{`0},System.Collections.Generic.IEqualityComparer{`1})">
            <summary>
            Create equality comparer.
            </summary>
            <param name="aComparer">(optional) element comparer</param>
            <param name="bComparer">(optional) element comparer</param>
        </member>
        <member name="M:Lexical.FileSystem.Internal.Pair`2.EqualityComparer.Equals(Lexical.FileSystem.Internal.Pair{`0,`1},Lexical.FileSystem.Internal.Pair{`0,`1})">
            <summary>
            Test equality
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.Pair`2.EqualityComparer.GetHashCode(Lexical.FileSystem.Internal.Pair{`0,`1})">
            <summary>
            Calculate hash-code
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="T:Lexical.FileSystem.Internal.Pair`2.Comparer">
            <summary>
            Order comparer
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Internal.Pair`2.Comparer.Default">
            <summary>
            Default instance
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.Pair`2.Comparer.aComparer">
            <summary>
            Element A comparer
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.Pair`2.Comparer.bComparer">
            <summary>
            Element B comparer
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Internal.Pair`2.Comparer.#ctor(System.Collections.Generic.IComparer{`0},System.Collections.Generic.IComparer{`1})">
            <summary>
            Create comparer
            </summary>
            <param name="aComparer">(optional) element comparer</param>
            <param name="bComparer">(optional) element comparer</param>
        </member>
        <member name="M:Lexical.FileSystem.Internal.Pair`2.Comparer.Compare(Lexical.FileSystem.Internal.Pair{`0,`1},Lexical.FileSystem.Internal.Pair{`0,`1})">
            <summary>
            Compare for order
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.Pair`2.ToString">
            <summary>
            Print info
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.Pair`2.AppendTo(System.Text.StringBuilder)">
            <summary>
            Append info to <paramref name="sb"/>
            </summary>
            <param name="sb"></param>
        </member>
        <member name="T:Lexical.FileSystem.Internal.Triple`3">
            <summary>
            Triple (3-tuple). Hashcode is cached. Elements are immutable. Type is stack allocated. 
            </summary>
            <typeparam name="A"></typeparam>
            <typeparam name="B"></typeparam>
            <typeparam name="C"></typeparam>
        </member>
        <member name="F:Lexical.FileSystem.Internal.Triple`3.a">
            <summary>A</summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.Triple`3.b">
            <summary>B</summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.Triple`3.c">
            <summary>C</summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.Triple`3.hashcode">
            <summary>Precalculated hashcode</summary>
        </member>
        <member name="M:Lexical.FileSystem.Internal.Triple`3.#ctor(`0,`1,`2)">
            <summary>
            Create Triple (3-tuple).
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="c"></param>
        </member>
        <member name="M:Lexical.FileSystem.Internal.Triple`3.GetHashCode">
            <summary>
            Get Hash-Code
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.Triple`3.Equals(System.Object)">
            <summary>
            Test equality with default element comparer.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.Triple`3.Equals(Lexical.FileSystem.Internal.Triple{`0,`1,`2})">
            <summary>
            Test equality with default element comparer.
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.Triple`3.CompareTo(Lexical.FileSystem.Internal.Triple{`0,`1,`2})">
            <summary>
            Compare order with default element comparer.
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="T:Lexical.FileSystem.Internal.Triple`3.EqualityComparer">
            <summary>
            Equality comparer
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Internal.Triple`3.EqualityComparer.Default">
            <summary>
            Default instance
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.Triple`3.EqualityComparer.aComparer">
            <summary>
            Element A comparer.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.Triple`3.EqualityComparer.bComparer">
            <summary>
            Element B comparer.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.Triple`3.EqualityComparer.cComparer">
            <summary>
            Element C comparer.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Internal.Triple`3.EqualityComparer.#ctor(System.Collections.Generic.IEqualityComparer{`0},System.Collections.Generic.IEqualityComparer{`1},System.Collections.Generic.IEqualityComparer{`2})">
            <summary>
            Create equality comparer.
            </summary>
            <param name="aComparer">(optional) element comparer</param>
            <param name="bComparer">(optional) element comparer</param>
            <param name="cComparer">(optional) element comparer</param>
        </member>
        <member name="M:Lexical.FileSystem.Internal.Triple`3.EqualityComparer.Equals(Lexical.FileSystem.Internal.Triple{`0,`1,`2},Lexical.FileSystem.Internal.Triple{`0,`1,`2})">
            <summary>
            Test equality
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.Triple`3.EqualityComparer.GetHashCode(Lexical.FileSystem.Internal.Triple{`0,`1,`2})">
            <summary>
            Calculate hash-code
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="T:Lexical.FileSystem.Internal.Triple`3.Comparer">
            <summary>
            Order comparer
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Internal.Triple`3.Comparer.Default">
            <summary>
            Default instance
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.Triple`3.Comparer.aComparer">
            <summary>
            Element A comparer
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.Triple`3.Comparer.bComparer">
            <summary>
            Element B comparer
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Internal.Triple`3.Comparer.cComparer">
            <summary>
            Element C comparer
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Internal.Triple`3.Comparer.#ctor(System.Collections.Generic.IComparer{`0},System.Collections.Generic.IComparer{`1},System.Collections.Generic.IComparer{`2})">
            <summary>
            Create comparer
            </summary>
            <param name="aComparer">(optional) element comparer</param>
            <param name="bComparer">(optional) element comparer</param>
            <param name="cComparer">(optional) element comparer</param>
        </member>
        <member name="M:Lexical.FileSystem.Internal.Triple`3.Comparer.Compare(Lexical.FileSystem.Internal.Triple{`0,`1,`2},Lexical.FileSystem.Internal.Triple{`0,`1,`2})">
            <summary>
            Compare for order
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.Triple`3.ToString">
            <summary>
            Print info
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Internal.Triple`3.AppendTo(System.Text.StringBuilder)">
            <summary>
            Append info to <paramref name="sb"/>
            </summary>
            <param name="sb"></param>
        </member>
        <member name="T:Lexical.FileSystem.MemoryFileSystem">
            <summary>
            In memory filesystem with file and directory structure.
            
            Directory separator character is forward slash '/'.  All characters exept '/' are valid file names. Directories can have empty name "". 
            Names "." and ".." are reserved for current and parent directories.
            
            Maximum file length is <see cref="F:System.Int32.MaxValue"/>*<see cref="F:Lexical.FileSystem.MemoryFileSystem.BlockSize"/>.
            The default blocksize is 1024 which allows 2TB - 1KB files.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.MemoryFileSystem.instance">
            <summary>Application's internal ram drive</summary>
        </member>
        <member name="P:Lexical.FileSystem.MemoryFileSystem.Instance">
            <summary>Application's internal ram drive</summary>
        </member>
        <member name="F:Lexical.FileSystem.MemoryFileSystem.root">
            <summary>
            Root directory
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.MemoryFileSystem.m_lock">
            <summary>
            Reader writer lock for modifying directory structure. 
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.MemoryFileSystem.observers">
            <summary>
            List of observers.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.MemoryFileSystem.Observers">
            <summary>
            A snapshot of observers.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.MemoryFileSystem.CaseSensitivity">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.MemoryFileSystem.EmptyDirectoryName">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.MemoryFileSystem.CanBrowse">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.MemoryFileSystem.CanGetEntry">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.MemoryFileSystem.CanCreateDirectory">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.MemoryFileSystem.CanDelete">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.MemoryFileSystem.CanObserve">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.MemoryFileSystem.CanMove">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.MemoryFileSystem.CanOpen">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.MemoryFileSystem.CanRead">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.MemoryFileSystem.CanWrite">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.MemoryFileSystem.CanCreateFile">
            <inheritdoc/>
        </member>
        <member name="F:Lexical.FileSystem.MemoryFileSystem.BlockSize">
            <summary>Block size</summary>
        </member>
        <member name="F:Lexical.FileSystem.MemoryFileSystem.blockPool">
            <summary>Block pool that dispenses blocks</summary>
        </member>
        <member name="M:Lexical.FileSystem.MemoryFileSystem.#ctor">
            <summary>
            Create new in-memory filesystem.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.MemoryFileSystem.#ctor(System.Int32)">
            <summary>
            Create new in-memory filesystem with <paramref name="blockSize"/> block size.
            </summary>
            <param name="blockSize"></param>
        </member>
        <member name="M:Lexical.FileSystem.MemoryFileSystem.#ctor(System.Int32,System.Int64)">
            <summary>
            Create new in-memory filesystem with <paramref name="blockSize"/> block size and limited space with <paramref name="maxSpace"/> parameter.
            </summary>
            <param name="blockSize"></param>
            <param name="maxSpace">maximum space in bytes, truncated to block size upwards</param>
        </member>
        <member name="M:Lexical.FileSystem.MemoryFileSystem.#ctor(Lexical.FileSystem.Utility.IBlockPool)">
            <summary>
            Create new in-memory filesystem that that allocates blocks with <paramref name="blockPool"/>.
            
            <paramref name="blockPool"/> can be shared with other <see cref="T:Lexical.FileSystem.MemoryFileSystem"/> implementations for shared free space quota.
            </summary>
            <param name="blockPool"></param>
        </member>
        <member name="T:Lexical.FileSystem.MemoryFileSystem.NonDisposable">
            <summary>
            Non-disposable <see cref="T:Lexical.FileSystem.MemoryFileSystem"/> cleans all files on dispose, closes observers, but doesn't go into disposed state.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.MemoryFileSystem.NonDisposable.#ctor">
            <summary>Create non-disposable memory filesystem.</summary>
        </member>
        <member name="M:Lexical.FileSystem.MemoryFileSystem.NonDisposable.#ctor(System.Int32)">
            <summary>Create non-disposable memory filesystem.</summary>
        </member>
        <member name="M:Lexical.FileSystem.MemoryFileSystem.NonDisposable.#ctor(Lexical.FileSystem.Utility.IBlockPool)">
            <summary>Create non-disposable memory filesystem.</summary>
        </member>
        <member name="M:Lexical.FileSystem.MemoryFileSystem.NonDisposable.InnerDispose(Lexical.FileSystem.Internal.StructList4{System.Exception}@)">
            <summary>Clean files</summary>
            <param name="disposeErrors"></param>
        </member>
        <member name="M:Lexical.FileSystem.MemoryFileSystem.Browse(System.String,Lexical.FileSystem.IOption)">
            <summary>
            Browse a directory for file and subdirectory entries.
            </summary>
            <param name="path">path to a directory or to a single file, "" is root, separator is "/"</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns>a snapshot of file and directory entries</returns>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support browse</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.InvalidOperationException">If <paramref name="path"/> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc.</exception>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="M:Lexical.FileSystem.MemoryFileSystem.GetEntry(System.String,Lexical.FileSystem.IOption)">
            <summary>
            Get entry of a single file or directory.
            </summary>
            <param name="path">path to a directory or to a single file, "" is root, separator is "/"</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns>entry, or null if entry is not found</returns>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support exists</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.InvalidOperationException">If <paramref name="path"/> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc.</exception>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="M:Lexical.FileSystem.MemoryFileSystem.CreateDirectory(System.String,Lexical.FileSystem.IOption)">
            <summary>
            Create a directory, or multiple cascading directories.
            
            If directory at <paramref name="path"/> already exists, then returns without exception.
            </summary>
            <param name="path">Relative path to file. Directory separator is "/". The root is without preceding slash "", e.g. "dir/dir2"</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns>true if directory exists after the method, false if directory doesn't exist</returns>
            <exception cref="T:System.IO.DirectoryNotFoundException">The specified path is invalid, such as parent beyond root "../dir".</exception>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> is an empty string (""), contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support create directory</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.InvalidOperationException">If <paramref name="path"/> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc.</exception>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="M:Lexical.FileSystem.MemoryFileSystem.Delete(System.String,System.Boolean,Lexical.FileSystem.IOption)">
            <summary>
            Delete a file or directory.
            
            If <paramref name="recursive"/> is false and <paramref name="path"/> is a directory that is not empty, then <see cref="T:System.IO.IOException"/> is thrown.
            If <paramref name="recursive"/> is true, then any file or directory in <paramref name="path"/> is deleted as well.
            </summary>
            <param name="path">path to a file or directory</param>
            <param name="recursive">if path refers to directory, recurse into sub directories</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <exception cref="T:System.IO.FileNotFoundException">The specified path is invalid.</exception>
            <exception cref="T:System.IO.IOException">On unexpected IO error, or if <paramref name="path"/> refered to a directory that wasn't empty and <paramref name="recursive"/> is false.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support deleting files</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.InvalidOperationException"><paramref name="path"/> refers to non-file device</exception>
            <exception cref="T:System.ObjectDisposedException"/>
            <exception cref="T:Lexical.FileSystem.FileSystemExceptionNoWriteAccess">When trying to delete root</exception>
        </member>
        <member name="M:Lexical.FileSystem.MemoryFileSystem.Move(System.String,System.String,Lexical.FileSystem.IOption)">
            <summary>
            Move/rename a file or directory.
            </summary>
            <param name="oldPath">old path of a file or directory</param>
            <param name="newPath">new path of a file or directory</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <exception cref="T:System.IO.FileNotFoundException">The specified <paramref name="oldPath"/> is invalid.</exception>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.ArgumentNullException">path is null</exception>
            <exception cref="T:System.ArgumentException">path is an empty string (""), contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support renaming/moving files</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.InvalidOperationException">path refers to non-file device, or an entry already exists at <paramref name="newPath"/></exception>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="M:Lexical.FileSystem.MemoryFileSystem.Open(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,Lexical.FileSystem.IOption)">
            <summary>
            Open a file for reading and/or writing. File can be created when <paramref name="fileMode"/> is <see cref="F:System.IO.FileMode.Create"/> or <see cref="F:System.IO.FileMode.CreateNew"/>.
            </summary>
            <param name="path">Relative path to file. Directory separator is "/". Root is without preceding "/", e.g. "dir/file.xml"</param>
            <param name="fileMode">determines whether to open or to create the file</param>
            <param name="fileAccess">how to access the file, read, write or read and write</param>
            <param name="fileShare">how the file will be shared by processes</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns>open file stream</returns>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> is an empty string (""), contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support opening files</exception>
            <exception cref="T:System.IO.FileNotFoundException">The file cannot be found, such as when mode is FileMode.Truncate or FileMode.Open, and and the file specified by path does not exist. The file must already exist in these modes.</exception>
            <exception cref="T:System.IO.DirectoryNotFoundException">The specified path is invalid, such as being on an unmapped drive.</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="fileMode"/>, <paramref name="fileAccess"/> or <paramref name="fileShare"/> contains an invalid value.</exception>
            <exception cref="T:System.InvalidOperationException">If <paramref name="path"/> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc.</exception>
            <exception cref="T:System.ObjectDisposedException"/>
            <exception cref="T:Lexical.FileSystem.FileSystemExceptionNoReadAccess">No read access</exception>
            <exception cref="T:Lexical.FileSystem.FileSystemExceptionNoWriteAccess">No write access</exception>
            <exception cref="T:Lexical.FileSystem.FileSystemExceptionDirectoryExists">Directory already exists</exception>
            <exception cref="T:Lexical.FileSystem.FileSystemExceptionFileExists">File already exists</exception>
        </member>
        <member name="M:Lexical.FileSystem.MemoryFileSystem.GetNode(System.String)">
            <summary>
            Get node by <paramref name="path"/>.
            Caller must ensure that lock is acquired.
            </summary>
            <param name="path"></param>
            <returns>node or null</returns>
        </member>
        <member name="M:Lexical.FileSystem.MemoryFileSystem.GetParentAndName(System.String,Lexical.FileSystem.Internal.StringSegment@,Lexical.FileSystem.Internal.StringSegment@,Lexical.FileSystem.MemoryFileSystem.Directory@)">
            <summary>
            Split <paramref name="path"/> into <paramref name="parentPath"/> and <paramref name="name"/>.
            
            Also searches for <paramref name="parent"/> directory node.
            </summary>
            <param name="path">path to parse</param>
            <param name="parentPath">path to parent</param>
            <param name="name"></param>
            <param name="parent">(optional) parent object</param>
            <returns>true parent was successfully found</returns>
        </member>
        <member name="M:Lexical.FileSystem.MemoryFileSystem.InnerDispose(Lexical.FileSystem.Internal.StructList4{System.Exception}@)">
            <summary>
            Handle dispose
            </summary>
            <param name="disposeErrors"></param>
        </member>
        <member name="M:Lexical.FileSystem.MemoryFileSystem.AddDisposeAction(System.Action{Lexical.FileSystem.MemoryFileSystem})">
            <summary>
            Invoke <paramref name="disposeAction"/> on the dispose of the object.
            
            If parent object is disposed or being disposed, the disposable will be disposed immedialy.
            </summary>
            <param name="disposeAction"></param>
            <returns>self</returns>
        </member>
        <member name="M:Lexical.FileSystem.MemoryFileSystem.AddDisposeAction(System.Action{System.Object},System.Object)">
            <summary>
            Invoke <paramref name="disposeAction"/> on the dispose of the object.
            
            If parent object is disposed or being disposed, the disposable will be disposed immedialy.
            </summary>
            <param name="disposeAction"></param>
            <param name="state"></param>
            <returns>self</returns>
        </member>
        <member name="M:Lexical.FileSystem.MemoryFileSystem.AddDisposable(System.Object)">
            <summary>
            Add <paramref name="disposable"/> to list of objects to be disposed along with the system.
            </summary>
            <param name="disposable"></param>
            <returns>filesystem</returns>
        </member>
        <member name="M:Lexical.FileSystem.MemoryFileSystem.AddDisposables(System.Collections.IEnumerable)">
            <summary>
            Add <paramref name="disposables"/> to list of objects to be disposed along with the system.
            </summary>
            <param name="disposables"></param>
            <returns>filesystem</returns>
        </member>
        <member name="M:Lexical.FileSystem.MemoryFileSystem.RemoveDisposable(System.Object)">
            <summary>
            Remove <paramref name="disposable"/> from dispose list.
            </summary>
            <param name="disposable"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.MemoryFileSystem.RemoveDisposables(System.Collections.IEnumerable)">
            <summary>
            Remove <paramref name="disposables"/> from dispose list.
            </summary>
            <param name="disposables"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.MemoryFileSystem.ToString">
            <summary>
            Print info
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.MemoryFileSystem.Observe(System.String,System.IObserver{Lexical.FileSystem.IEvent},System.Object,Lexical.FileSystem.IEventDispatcher,Lexical.FileSystem.IOption)">
            <inheritdoc/>
        </member>
        <member name="T:Lexical.FileSystem.MemoryFileSystem.ObserverHandle">
            <summary>
            Observer
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.MemoryFileSystem.ObserverHandle.filterPattern">
            <summary>Filter pattern that is used for filtering events by path.</summary>
        </member>
        <member name="F:Lexical.FileSystem.MemoryFileSystem.ObserverHandle.acceptAll">
            <summary>Accept all pattern "**".</summary>
        </member>
        <member name="F:Lexical.FileSystem.MemoryFileSystem.ObserverHandle.startTime">
            <summary>Time when observing started.</summary>
        </member>
        <member name="M:Lexical.FileSystem.MemoryFileSystem.ObserverHandle.#ctor(Lexical.FileSystem.MemoryFileSystem,System.String,System.IObserver{Lexical.FileSystem.IEvent},System.Object,Lexical.FileSystem.IEventDispatcher)">
            <summary>
            Create new observer.
            </summary>
            <param name="filesystem"></param>
            <param name="filter">path filter as glob pattenrn. "*" any sequence of charaters within a directory, "**" any sequence of characters, "?" one character. E.g. "**/*.txt"</param>
            <param name="observer"></param>
            <param name="state"></param>
            <param name="eventDispatcher"></param>
        </member>
        <member name="M:Lexical.FileSystem.MemoryFileSystem.ObserverHandle.Qualify(System.String)">
            <summary>
            Tests whether <paramref name="path"/> qualifies the filter.
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.MemoryFileSystem.ObserverHandle.InnerDispose(Lexical.FileSystem.Internal.StructList4{System.Exception}@)">
            <summary>
            Remove this handle from collection of observers.
            </summary>
            <param name="errors"></param>
        </member>
        <member name="T:Lexical.FileSystem.MemoryFileSystem.Node">
            <summary>
            Parent type for <see cref="T:Lexical.FileSystem.MemoryFileSystem.Directory"/> and <see cref="T:Lexical.FileSystem.Utility.MemoryFile"/>.
            
            Node class must be accessed only under reader or writer lock.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.MemoryFileSystem.Node.path">
            <summary>
            Cached path. 
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.MemoryFileSystem.Node.name">
            <summary>
            Name of the entry.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.MemoryFileSystem.Node.isDeleted">
            <summary>
            Has node been deleted.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.MemoryFileSystem.Node.lastModified">
            <summary>
            Last modified time.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.MemoryFileSystem.Node.lastAccess">
            <summary>
            Last access time.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.MemoryFileSystem.Node.filesystem">
            <summary>
            Parent filesystem.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.MemoryFileSystem.Node.parent">
            <summary>
            Parent directory.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.MemoryFileSystem.Node.entry">
            <summary>
            Cached entry
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.MemoryFileSystem.Node.Entry">
            <summary>
            Get or create entry.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.MemoryFileSystem.Node.Path">
            <summary>
            Path to the entry.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.MemoryFileSystem.Node.#ctor(Lexical.FileSystem.MemoryFileSystem,Lexical.FileSystem.MemoryFileSystem.Directory,System.String,System.DateTimeOffset)">
            <summary>
            Create entry
            </summary>
            <param name="filesystem"></param>
            <param name="parent"></param>
            <param name="name"></param>
            <param name="time">time for lastmodified and lastaccess</param>
        </member>
        <member name="M:Lexical.FileSystem.MemoryFileSystem.Node.CreateEntry">
            <summary>Create entry snapshot.</summary>
        </member>
        <member name="M:Lexical.FileSystem.MemoryFileSystem.Node.VisitTree">
            <summary>Visit self and subtree.</summary>
        </member>
        <member name="M:Lexical.FileSystem.MemoryFileSystem.Node.FlushPath">
            <summary>Flush cached path info</summary>
        </member>
        <member name="M:Lexical.FileSystem.MemoryFileSystem.Node.FlushEntry">
            <summary>Flush cached entry info.</summary>
        </member>
        <member name="M:Lexical.FileSystem.MemoryFileSystem.Node.FlushChildEntries">
            <summary>Flush child entries</summary>
        </member>
        <member name="M:Lexical.FileSystem.MemoryFileSystem.Node.Dispose">
            <summary>Delete node</summary>
        </member>
        <member name="M:Lexical.FileSystem.MemoryFileSystem.Node.ToString">
            <summary>Print info</summary>
        </member>
        <member name="T:Lexical.FileSystem.MemoryFileSystem.Directory">
            <summary>
            In-memory directory where in-memory files can be created.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.MemoryFileSystem.Directory.children">
            <summary>
            Files and directories. Lazy construction. Modified under m_lock.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.MemoryFileSystem.Directory.childEntries">
            <summary>
            Cached child entries
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.MemoryFileSystem.Directory.ChildEntries">
            <summary>
            Get or create child entries.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.MemoryFileSystem.Directory.Path">
            <summary>
            Path to the entry.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.MemoryFileSystem.Directory.#ctor(Lexical.FileSystem.MemoryFileSystem,Lexical.FileSystem.MemoryFileSystem.Directory,System.String,System.DateTimeOffset)">
            <summary>
            Create directory entry
            </summary>
            <param name="filesystem"></param>
            <param name="parent"></param>
            <param name="name"></param>
            <param name="lastModified"></param>
        </member>
        <member name="M:Lexical.FileSystem.MemoryFileSystem.Directory.CreateEntry">
            <summary>
            Create entry snapshot.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.MemoryFileSystem.Directory.FlushChildEntries">
            <summary>
            Flush cached array of child entries.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.MemoryFileSystem.Directory.VisitTree">
            <summary>
            Enumerate self and subtree.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Lexical.FileSystem.MemoryFileSystem.File">
            <summary>
            Memory file
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.MemoryFileSystem.File.memoryFile">
            <summary>
            Memory file
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.MemoryFileSystem.File.Path">
            <summary>
            Path to the entry.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.MemoryFileSystem.File.subscriptionHandle">
            <summary>
            Handle for modification notification subscription.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.MemoryFileSystem.File.#ctor(Lexical.FileSystem.MemoryFileSystem,Lexical.FileSystem.MemoryFileSystem.Directory,System.String,System.DateTimeOffset)">
            <summary>
            Create file entry.
            </summary>
            <param name="filesystem"></param>
            <param name="parent"></param>
            <param name="name"></param>
            <param name="lastModified"></param>
        </member>
        <member name="M:Lexical.FileSystem.MemoryFileSystem.File.CreateEntry">
            <summary>
            Create entry snapshot.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.MemoryFileSystem.File.System#IObserver{Lexical#FileSystem#Utility#MemoryFile#ModifiedEvent}#OnNext(Lexical.FileSystem.Utility.MemoryFile.ModifiedEvent)">
            <summary>
            File was modified
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Lexical.FileSystem.MemoryFileSystem.File.Open(System.IO.FileAccess,System.IO.FileShare)">
            <summary>
            Open a new stream to the file memory
            </summary>
            <param name="fileAccess"></param>
            <param name="fileShare"></param>
            <returns></returns>
            <exception cref="T:Lexical.FileSystem.FileSystemExceptionNoReadAccess">No read access</exception>
            <exception cref="T:Lexical.FileSystem.FileSystemExceptionNoWriteAccess">No write access</exception>
        </member>
        <member name="M:Lexical.FileSystem.MemoryFileSystem.File.VisitTree">
            <summary>
            Enumerate self.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.MemoryFileSystem.File.Dispose">
            <summary>
            Delete file
            </summary>
        </member>
        <member name="T:Lexical.FileSystem.Utility.DummyObserver">
            <summary>
            Dummy observer that returns no events.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Utility.DummyObserver.#ctor(Lexical.FileSystem.IFileSystem,System.String,System.IObserver{Lexical.FileSystem.IEvent},System.Object,Lexical.FileSystem.IEventDispatcher)">
            <summary>
            
            </summary>
            <param name="filesystem"></param>
            <param name="filter"></param>
            <param name="observer"></param>
            <param name="state"></param>
            <param name="eventDispatcher"></param>
        </member>
        <member name="T:Lexical.FileSystem.Utility.BlockPool">
            <summary>
            Block pool allocates and recycles memory blocks that are used for buffers.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Utility.BlockPool.BlockSize">
            <summary>Block size, typically 4096</summary>
        </member>
        <member name="F:Lexical.FileSystem.Utility.BlockPool.MaxBlockCount">
            <summary>Maximum number of blocks to dispence</summary>
        </member>
        <member name="F:Lexical.FileSystem.Utility.BlockPool.MaxRecycleQueue">
            <summary>Maximum number of blocks to keep in recycle queue</summary>
        </member>
        <member name="F:Lexical.FileSystem.Utility.BlockPool.ClearsRecycledBlocks">
            <summary>Clear recycled blocks with 0 values</summary>
        </member>
        <member name="F:Lexical.FileSystem.Utility.BlockPool.blocksAllocated">
            <summary>Number of blocks dispenced currently (not correlated with recycled blocks)</summary>
        </member>
        <member name="F:Lexical.FileSystem.Utility.BlockPool.m_lock">
            <summary>lock</summary>
        </member>
        <member name="F:Lexical.FileSystem.Utility.BlockPool.recycledBlocks">
            <summary>lock</summary>
        </member>
        <member name="P:Lexical.FileSystem.Utility.BlockPool.BytesAllocated">
            <summary>Number of bytes allocated</summary>
        </member>
        <member name="P:Lexical.FileSystem.Utility.BlockPool.BytesAvailable">
            <summary>Number of bytes available for allocation</summary>
        </member>
        <member name="M:Lexical.FileSystem.Utility.BlockPool.#ctor(System.Int32,System.Int64,System.Int32,System.Boolean)">
            <summary>Create block pool.</summary>
            <param name="blockSize">block size</param>
            <param name="maxBlockCount">maximum number of blocks to disposense concurrently</param>
            <param name="maxRecycleQueue">maximum number of blocks to recycle, 0 to not recycle blocks ever</param>
            <param name="clearRecycledBlocks">if true, clears recycled blocks with 0 values</param>
        </member>
        <member name="M:Lexical.FileSystem.Utility.BlockPool.TryAllocate(System.Byte[]@)">
            <summary>
            Try to allocate block, if no blocks are available returns false and null.
            </summary>
            <param name="block"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Utility.BlockPool.Allocate">
            <summary>
            Allocate block. If no blocks are available, then waits until one is returned.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Utility.BlockPool.Return(System.Byte[])">
            <summary>
            Return block to the block pool.
            
            If there is a thread waiting to get a block, then the thread is woken up and distributed the block.
            </summary>
            <param name="block">block to return</param>
        </member>
        <member name="M:Lexical.FileSystem.Utility.BlockPool.Return(System.Collections.Generic.IEnumerable{System.Byte[]})">
            <summary>
            Return <paramref name="blocks"/> to the block pool.
            
            If there is a thread waiting to get a block, then the thread is woken up and distributed one.
            </summary>
            <param name="blocks">block to return</param>
        </member>
        <member name="M:Lexical.FileSystem.Utility.BlockPool.Disconnect(System.Byte[])">
            <summary>
            Disconnect <paramref name="block"/> from pool. <paramref name="block"/> is a block that has been allocated by the pool earlier on.
            
            The caller gets the ownership of <paramref name="block"/>.
            </summary>
            <param name="block"></param>
        </member>
        <member name="M:Lexical.FileSystem.Utility.BlockPool.Disconnect(System.Collections.Generic.IEnumerable{System.Byte[]})">
            <summary>
            Disconnect <paramref name="blocks"/> from the pool. <paramref name="blocks"/> have been allocated by the pool earlier on.
            
            The caller gets the ownership of <paramref name="blocks"/>.
            </summary>
            <param name="blocks"></param>
        </member>
        <member name="M:Lexical.FileSystem.Utility.BlockPool.ToString">
            <summary>Print Info</summary>
        </member>
        <member name="T:Lexical.FileSystem.Utility.BlockPoolPseudo">
            <summary>
            Pseudo Block pool that always allocates new block. Doesn't recycle blocks. Doesn't keep track of the number of returned blocks.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Utility.BlockPoolPseudo.Instance">
            <summary>Singleton instance</summary>
        </member>
        <member name="P:Lexical.FileSystem.Utility.BlockPoolPseudo.BlockSize">
            <summary></summary>
        </member>
        <member name="P:Lexical.FileSystem.Utility.BlockPoolPseudo.MaxBlockCount">
            <summary></summary>
        </member>
        <member name="P:Lexical.FileSystem.Utility.BlockPoolPseudo.MaxRecycleQueue">
            <summary></summary>
        </member>
        <member name="P:Lexical.FileSystem.Utility.BlockPoolPseudo.ClearsRecycledBlocks">
            <summary></summary>
        </member>
        <member name="P:Lexical.FileSystem.Utility.BlockPoolPseudo.BytesAllocated">
            <summary></summary>
        </member>
        <member name="P:Lexical.FileSystem.Utility.BlockPoolPseudo.BytesAvailable">
            <summary></summary>
        </member>
        <member name="M:Lexical.FileSystem.Utility.BlockPoolPseudo.#ctor(System.Int32)">
            <summary>
            Create pseudo block pool.
            </summary>
            <param name="blockSize"></param>
        </member>
        <member name="M:Lexical.FileSystem.Utility.BlockPoolPseudo.Allocate">
            <summary>Allocate block</summary>
        </member>
        <member name="M:Lexical.FileSystem.Utility.BlockPoolPseudo.Return(System.Byte[])">
            <summary>Return block</summary>
        </member>
        <member name="M:Lexical.FileSystem.Utility.BlockPoolPseudo.Return(System.Collections.Generic.IEnumerable{System.Byte[]})">
            <summary>Return blocks</summary>
        </member>
        <member name="M:Lexical.FileSystem.Utility.BlockPoolPseudo.TryAllocate(System.Byte[]@)">
            <summary>Allocate block</summary>
        </member>
        <member name="M:Lexical.FileSystem.Utility.BlockPoolPseudo.Disconnect(System.Byte[])">
            <summary>Disconnect block</summary>
        </member>
        <member name="M:Lexical.FileSystem.Utility.BlockPoolPseudo.Disconnect(System.Collections.Generic.IEnumerable{System.Byte[]})">
            <summary>Disconnect blocks</summary>
        </member>
        <member name="M:Lexical.FileSystem.Utility.BlockPoolPseudo.ToString">
            <summary>Print Info</summary>
        </member>
        <member name="T:Lexical.FileSystem.Utility.DisposeList">
            <summary>
            A disposable that manages a list of disposable objects.
            
            All attached disposables are disposed at Dispose().
            
            Subclasses that inherit <see cref="T:Lexical.FileSystem.Utility.DisposeList"/> can put their own dispose
            behaviour into <see cref="M:Lexical.FileSystem.Utility.DisposeList.InnerDispose(Lexical.FileSystem.Internal.StructList4{System.Exception}@)"/> and <see cref="M:Lexical.FileSystem.Utility.DisposeList.InnerDisposeUnmanaged(Lexical.FileSystem.Internal.StructList4{System.Exception}@)"/>.
            
            InnerDispose will be called only once. 
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Utility.DisposeList.m_disposelist_lock">
            <summary>
            Lock for modifying <see cref="T:Lexical.FileSystem.Utility.DisposeList"/>.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Utility.DisposeList.disposeList">
            <summary>
            List of disposables that has been attached with this object.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Utility.DisposeList.disposing">
            <summary>
            State that is set when disposing starts and finalizes.
            Is changed with Interlocked. 
             0 - not disposed
             1 - dispose called, but not started
             2 - disposing started
             3 - disposed
             
            When disposing starts, new objects cannot be added to the object, instead they are disposed right at away.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Utility.DisposeList.IsDisposeCalled">
            <summary>
            Has Dispose() been called, has dispose started, or has dispose completed.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Utility.DisposeList.IsDisposing">
            <summary>
            Has dispose started or completed. Returns false, if Dispose() has been called but is postponed due to open belate handles.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Utility.DisposeList.IsDisposed">
            <summary>
            Has dispose completed.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Utility.DisposeList.belateHandleCount">
            <summary>
            Number of belate handles
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Utility.DisposeList.nonDisposable">
            <summary>
            Non disposable is a flag for objects that cannot be disposed, such as singleton instances.
            <see cref="F:Lexical.FileSystem.Utility.DisposeList.nonDisposable"/> is set at construction.
            
            Use method <see cref="M:Lexical.FileSystem.Utility.DisposeList.SetToNonDisposable"/> to modify the state at constructor.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Utility.DisposeList.SetToNonDisposable">
            <summary>
            Non-disposable is a flag for objects that cannot be disposed, such as singleton instances.
            <see cref="F:Lexical.FileSystem.Utility.DisposeList.nonDisposable"/> is set at construction.
            
            When Dispose() is called for non-disposable object, the attached disposables
            are removed and disposed, but the object itself does not go into disposed state.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Utility.DisposeList.BelateDispose">
            <summary>
            Delay dispose until belate handle is disposed.
            </summary>
            <returns></returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if object has already been disposed.</exception>
        </member>
        <member name="T:Lexical.FileSystem.Utility.DisposeList.BelateHandle">
            <summary>
            A handle that postpones dispose of the <see cref="T:Lexical.FileSystem.Utility.DisposeList"/> object.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Utility.DisposeList.Dispose">
            <summary>
            Dispose object. This method is intended to be called by the consumer of the object.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Utility.DisposeList.Dispose(System.Boolean)">
            <summary>
            Marks dispose-has-been-called. If there are no belate handles, then proceeds with dispose.
            </summary>
            <param name="disposing">
                If true, called by Dispose(), and should dispose managed and unmanaged resources.
                If false, called by GC, and should dispose only unmanaged resources.
            </param>
            <exception cref="T:System.AggregateException">thrown if disposing threw errors</exception>
        </member>
        <member name="M:Lexical.FileSystem.Utility.DisposeList.ProcessDispose">
            <summary>
            Process the actual dispose. This may be called from Dispose() or from the dispose of the last
            belate handle (After Dispose() has been called aswell).
            
            Disposes all attached diposables and call <see cref="M:Lexical.FileSystem.Utility.DisposeList.InnerDispose(Lexical.FileSystem.Internal.StructList4{System.Exception}@)"/>.
            
            Only one thread may process the dispose.
            Sets state to 2, and then 3.
            
            Unattaches all disposables, disposes them, and calls <see cref="M:Lexical.FileSystem.Utility.DisposeList.InnerDispose(Lexical.FileSystem.Internal.StructList4{System.Exception}@)"/>.
            </summary>
            <exception cref="T:System.AggregateException">thrown if disposing threw errors</exception>
        </member>
        <member name="M:Lexical.FileSystem.Utility.DisposeList.ProcessNonDispose">
            <summary>
            Process the non-dispose. Used when <see cref="F:Lexical.FileSystem.Utility.DisposeList.nonDisposable"/> is true (singleton instances).
            
            This may be called from Dispose() or from the dispose of the last
            belate handle (After Dispose() has been called aswell).
            
            Only one thread may process the dispose. Returns state back to 0.
            
            Unattaches all disposables, disposes them, and calls <see cref="M:Lexical.FileSystem.Utility.DisposeList.InnerDispose(Lexical.FileSystem.Internal.StructList4{System.Exception}@)"/>.
            Does not set state 
            </summary>
            <exception cref="T:System.AggregateException">thrown if disposing threw errors</exception>
        </member>
        <member name="M:Lexical.FileSystem.Utility.DisposeList.InnerDispose(Lexical.FileSystem.Internal.StructList4{System.Exception}@)">
            <summary>
            Override this to dispose managed resources
            </summary>
            <param name="disposeErrors">list that can be instantiated and where errors can be added</param>
            <exception cref="T:System.Exception">any exception is captured and aggregated with other errors</exception>
        </member>
        <member name="M:Lexical.FileSystem.Utility.DisposeList.InnerDisposeUnmanaged(Lexical.FileSystem.Internal.StructList4{System.Exception}@)">
            <summary>
            Override this to dispose unmanaged resources.
            </summary>
            <param name="disposeErrors">list that can be instantiated and where errors can be added</param>
            <exception cref="T:System.Exception">any exception is captured and aggregated with other errors</exception>
        </member>
        <member name="M:Lexical.FileSystem.Utility.DisposeList.Lexical#FileSystem#Utility#IDisposeList#AddDisposable(System.Object)">
            <summary>
            Add <paramref name="disposableObject"/> to be disposed with the object.
            
            If parent object is disposed or being disposed, the disposable will be disposed immedialy.
            </summary>
            <param name="disposableObject"></param>
            <returns>true if was added to list, false if was disposed right away</returns>
        </member>
        <member name="M:Lexical.FileSystem.Utility.DisposeList.Lexical#FileSystem#Utility#IDisposeList#AddDisposeAction(System.Action{System.Object},System.Object)">
            <summary>
            Invoke <paramref name="disposeAction"/> on the dispose of the object.
            
            If parent object is disposed or being disposed, the <paramref name="disposeAction"/> is executed immediately.
            </summary>
            <param name="disposeAction"></param>
            <param name="state"></param>
            <returns>true if was added to list, false if was disposed right away</returns>
        </member>
        <member name="T:Lexical.FileSystem.Utility.DisposeList.DisposeAction">
            <summary>
            Adapts <see cref="T:System.Action"/> into <see cref="T:System.IDisposable"/>.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Utility.DisposeList.DisposeAction.#ctor(System.Action{System.Object},System.Object)">
            <summary>
            Create dispose action.
            </summary>
            <param name="a"></param>
            <param name="state"></param>
        </member>
        <member name="M:Lexical.FileSystem.Utility.DisposeList.DisposeAction.Dispose">
            <summary>
            Run delegate with the attached object.
            </summary>
        </member>
        <member name="T:Lexical.FileSystem.Utility.DisposeList.DisposeAction`1">
            <summary>
            Adapts <see cref="T:System.Action"/> into <see cref="T:System.IDisposable"/>.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Utility.DisposeList.DisposeAction`1.#ctor(System.Action{`0},`0)">
            <summary>
            Create dispose action.
            </summary>
            <param name="a"></param>
            <param name="disposeObject"></param>
        </member>
        <member name="M:Lexical.FileSystem.Utility.DisposeList.DisposeAction`1.Dispose">
            <summary>
            Run delegate with the attached object.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Utility.DisposeList.Lexical#FileSystem#Utility#IDisposeList#AddDisposables(System.Collections.IEnumerable)">
            <summary>
            Add <paramref name="disposableObjects"/> to be disposed with the object.
            </summary>
            <param name="disposableObjects"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Utility.DisposeList.Lexical#FileSystem#Utility#IDisposeList#RemoveDisposable(System.Object)">
            <summary>
            Remove <paramref name="disposableObject"/> from list of attached disposables.
            </summary>
            <param name="disposableObject"></param>
            <returns>true if an item of <paramref name="disposableObject"/> was removed, false if it wasn't there</returns>
        </member>
        <member name="M:Lexical.FileSystem.Utility.DisposeList.Lexical#FileSystem#Utility#IDisposeList#RemoveDisposables(System.Collections.IEnumerable)">
            <summary>
            Remove <paramref name="disposableObjects"/> from the list. 
            </summary>
            <param name="disposableObjects"></param>
            <returns>true if was removed, false if it wasn't in the list.</returns>
        </member>
        <member name="M:Lexical.FileSystem.Utility.DisposeList.DisposeAndCapture(System.Collections.IEnumerable,Lexical.FileSystem.Internal.StructList4{System.Exception}@)">
            <summary>
            Dispose enumerable and capture errors
            </summary>
            <param name="disposableObjects">list of disposables</param>
            <param name="disposeErrors">list to be created if errors occur</param>
        </member>
        <member name="M:Lexical.FileSystem.Utility.DisposeList.DisposeAndCapture(Lexical.FileSystem.Internal.StructList2{System.IDisposable}@,Lexical.FileSystem.Internal.StructList4{System.Exception}@)">
            <summary>
            Dispose enumerable and capture errors
            </summary>
            <param name="disposableObjects">list of disposables</param>
            <param name="disposeErrors">list to be created if errors occur</param>
        </member>
        <member name="T:Lexical.FileSystem.Utility.EntryComparer">
            <summary>
            Equality comparer compares <see cref="T:Lexical.FileSystem.IEntry"/> for Path, Date, Length and FileSystem equality.
            
            Order comparer compares by type, then by name. 
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Utility.EntryComparer.pathDateLengthTypeEqualityComparer">
            <summary>Equality comparer for: Path, Date, Length, Type</summary>
        </member>
        <member name="F:Lexical.FileSystem.Utility.EntryComparer.typeNameComparer">
            <summary>Comparer that sorts by: Type, Name.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Utility.EntryComparer.PathDateLengthTypeEqualityComparer">
            <summary>Equality comparer for: Path, Date, Length, Type</summary>
        </member>
        <member name="P:Lexical.FileSystem.Utility.EntryComparer.TypeNameComparer">
            <summary>Comparer that sorts by: Type, Name.</summary>
        </member>
        <member name="T:Lexical.FileSystem.Utility.EntryComparer._PathDateLengthTypeEqualityComparer">
            <summary>Equality comparer for: Path, Date, Length, Type</summary>
        </member>
        <member name="M:Lexical.FileSystem.Utility.EntryComparer._PathDateLengthTypeEqualityComparer.Equals(Lexical.FileSystem.IEntry,Lexical.FileSystem.IEntry)">
            <summary>
            Compare entries.
            
            Two nulls are considered equal.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Utility.EntryComparer._PathDateLengthTypeEqualityComparer.GetHashCode(Lexical.FileSystem.IEntry)">
            <summary>
            Calculate hash
            </summary>
            <param name="entry"></param>
            <returns></returns>
        </member>
        <member name="T:Lexical.FileSystem.Utility.EntryComparer._TypeNameComparer">
            <summary>Comparer that sorts by: Type, Name.</summary>
        </member>
        <member name="M:Lexical.FileSystem.Utility.EntryComparer._TypeNameComparer.Compare(Lexical.FileSystem.IEntry,Lexical.FileSystem.IEntry)">
            <summary>
            Sort by type, then name, using AlphaNumericComparer
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="T:Lexical.FileSystem.Utility.FileScanner">
            <summary>
            This class scans directories and searches for files that match a wildcard and regex patterns.
            
            The class itself is IEnumerable, it will start a new scan for each IEnumerator that is requested.
            
            It uses concurrent threads for scanning. Tasks are spawned with Task.StartNew. 
            If TaskFactory is congested, the scanning may not start immediately. 
            Caller may provide customized <see cref="F:Lexical.FileSystem.Utility.FileScanner.TaskFactory"/> to avoid issues.
            
            The FileScanner is programmed so that it's internal separator is '/', and results use '/' as separator.
            For instance, to scan a network drive with RootFileSystem, use '/' separator after volume 
            <code>new FileScanner(root).AddWildcard(@"\\192.168.8.1\shared/*")</code>.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Utility.FileScanner.patterns">
            <summary>
            Patterns by start path. 
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Utility.FileScanner.TaskFactory">
            <summary>
            The factory that will be used for creating scanning threads.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Utility.FileScanner.errors">
            <summary>
            A place to put errors. Caller must place value here before starting a scan.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Utility.FileScanner.FileSystem">
            <summary>
            Root file provider
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Utility.FileScanner.RootPrefix">
            <summary>
            Prefix to add to each file entries before they are matched.
            
            For instance if "/" is used as prefix, then glob pattern "**/*.dll" can be used
            to match against all .dll files _including_ root, which would be "/" with prefix.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Utility.FileScanner.DirectoryEvaluator">
            <summary>
            Function that tests whether to enter a directory. 
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Utility.FileScanner.DefaultDirectoryEvaluator">
            <summary>
            Default evaluator.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Utility.FileScanner.ReturnDirectories">
            <summary>
            Should file scanner return directories.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Utility.FileScanner.ReturnFiles">
            <summary>
            Should file scanner return files.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Utility.FileScanner.#ctor(Lexical.FileSystem.IFileSystem)">
            <summary>
            Create new file scanner.
            </summary>
            <param name="FileSystem"></param>
        </member>
        <member name="M:Lexical.FileSystem.Utility.FileScanner.AddWildcard(System.String)">
            <summary>
            Add a filename pattern, a pattern with path and wildcard, for example "*.dll", "folder/*.dll"
            </summary>
            <param name="pattern"></param>
            <returns>self</returns>
        </member>
        <member name="M:Lexical.FileSystem.Utility.FileScanner.AddGlobPattern(System.String)">
            <summary>
            Adds glob pattern. 
              "**" Matched to for any string of characters including directory separator.
              "*" Matched for any string of characters within the same directory.
              "?" Matched for one character excluding directory separator.
            </summary>
            <param name="pattern"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Utility.FileScanner.AddRegex(System.String,System.Text.RegularExpressions.Regex)">
            <summary>
            Add regular expression pattern to scanner match patterns.
            </summary>
            <param name="path"></param>
            <param name="pattern"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Utility.FileScanner.SetTaskFactory(System.Threading.Tasks.TaskFactory)">
            <summary>
            Add custom <paramref name="taskFactory"/> that constructs the browsing sub-tasks.
            </summary>
            <param name="taskFactory"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Utility.FileScanner.SetPathPrefix(System.String)">
            <summary>
            Prefix to add to each file entries before they are matched.
            
            For instance if "/" is used as prefix, then glob pattern "**/*.dll" can be used
            to match against all .dll files _including_ root, which would be "/" with prefix.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Utility.FileScanner.SetErrorTarget(System.Collections.Concurrent.IProducerConsumerCollection{System.Exception})">
            <summary>
            Set collection where errors are written to.
            </summary>
            <param name="errors"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Utility.FileScanner.SetDirectoryEvaluator(System.Func{Lexical.FileSystem.IEntry,System.Boolean})">
            <summary>
            Add a custom directory qualifier <paramref name="func"/> that approves or disapprovies whether to 
            continue scan into a directory.
            </summary>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Utility.FileScanner.SetReturnDirectories(System.Boolean)">
            <summary>
            Should file scanner return directories.
            <paramref name="returnDirectories"/>
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Utility.FileScanner.SetReturnFiles(System.Boolean)">
            <summary>
            Should file scanner return directories.
            <paramref name="returnFiles"/>
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Utility.FileScanner.System#Collections#Generic#IEnumerable{Lexical#FileSystem#IEntry}#GetEnumerator">
            <summary>
            Start multi-threaded scan operation.
            </summary>
            <returns>FileScannerEnumerator</returns>
        </member>
        <member name="M:Lexical.FileSystem.Utility.FileScanner.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Start multi-threaded scan operation.
            </summary>
            <returns>FileScannerEnumerator</returns>
        </member>
        <member name="T:Lexical.FileSystem.Utility.PatternScanner">
            <summary>
            Resettable scan enumerator.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Utility.PatternScanner.errors">
            <summary>
            Collection or errors are placed here.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Utility.PatternScanner.#ctor(Lexical.FileSystem.IFileSystem,System.String,System.Collections.Generic.IEnumerable{System.ValueTuple{System.String,Lexical.FileSystem.Internal.PatternSet,System.Int32}},System.Threading.Tasks.TaskFactory,System.Collections.Concurrent.IProducerConsumerCollection{System.Exception},System.Func{Lexical.FileSystem.IEntry,System.Boolean},System.Boolean,System.Boolean)">
            <summary>
            Create scanner.
            </summary>
            <param name="FileSystem"></param>
            <param name="rootPrefix"></param>
            <param name="patterns"></param>
            <param name="taskFactory"></param>
            <param name="errors"></param>
            <param name="directoryEvaluator"></param>
            <param name="returnDirectories"></param>
            <param name="returnFiles"></param>
        </member>
        <member name="P:Lexical.FileSystem.Utility.PatternScanner.Current">
            <summary>
            Get current path.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Utility.PatternScanner.Dispose">
            <summary>
            Dispose scanner
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Utility.PatternScanner.MoveNext">
            <summary>
            Move to next element
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Utility.PatternScanner.Reset">
            <summary>
            Reset scanner
            </summary>
        </member>
        <member name="T:Lexical.FileSystem.Utility.ScanJob">
            <summary>
            A single scan job. 
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Utility.ScanJob.Scan">
            <summary>
            Call this from every thread that participates in scanning job.
            </summary>
        </member>
        <member name="T:Lexical.FileSystem.Utility.FileSystemComparerComposition">
            <summary>
            Comparer that compares known filesystems for equality of referred system.
            
            For instance, two different instances of <see cref="T:Lexical.FileSystem.EmbeddedFileSystem"/> that
            refer to same <see cref="T:System.Reflection.Assembly"/> are considered hash-equal.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Utility.FileSystemComparerComposition.instance">
            <summary>
            Default instance that supports:
            
            <list type="table">
                <item><see cref="T:Lexical.FileSystem.EmbeddedFileSystem"/></item>
                <item><see cref="T:Lexical.FileSystem.FileSystem"/></item>
                <item><see cref="T:Lexical.FileSystem.Decoration.FileProviderSystem"/></item>
                <item><see cref="T:Lexical.FileSystem.Decoration.FileSystemDecoration"/></item>
                <item><see cref="T:Lexical.FileSystem.MemoryFileSystem"/></item>
            </list>
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Utility.FileSystemComparerComposition.Instance">
            <summary>
            Singleton instance
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Utility.FileSystemComparerComposition.comparers">
            <summary>
            Comparers for each <see cref="T:Lexical.FileSystem.IFileSystem"/> type.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Utility.FileSystemComparerComposition.supportedTypes">
            <summary>
            Supported types.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Utility.FileSystemComparerComposition.comparerFactory">
            <summary>
            Comparer factory delegate.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Utility.FileSystemComparerComposition.#ctor(System.Type[])">
            <summary>
            Construct filesystem comparer.
            </summary>
            <param name="comparerTypes">supported comparer types that implement <see cref="T:System.Collections.Generic.IEqualityComparer`1"/></param>
        </member>
        <member name="M:Lexical.FileSystem.Utility.FileSystemComparerComposition.CreateComparer(System.Type)">
            <summary>
            Method that creates comparer.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Utility.FileSystemComparerComposition.Equals(Lexical.FileSystem.IFileSystem,Lexical.FileSystem.IFileSystem)">
            <summary>
            Compare two filesystems. 
            </summary>
            <param name="x">(optional) </param>
            <param name="y">(optional) </param>
            <returns>true if filesystems are equal</returns>
        </member>
        <member name="M:Lexical.FileSystem.Utility.FileSystemComparerComposition.GetHashCode(Lexical.FileSystem.IFileSystem)">
            <summary>
            Calculate filesystem hashcode.
            </summary>
            <param name="filesystem"></param>
            <returns></returns>
        </member>
        <member name="T:Lexical.FileSystem.Utility.EmbeddedFileSystemComparer">
            <summary>
            Compares <see cref="T:Lexical.FileSystem.EmbeddedFileSystem"/> instances.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Utility.EmbeddedFileSystemComparer.Equals(Lexical.FileSystem.IFileSystem,Lexical.FileSystem.IFileSystem)">
            <summary>
            Compare for <see cref="T:System.Reflection.Assembly"/> equality.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Utility.EmbeddedFileSystemComparer.GetHashCode(Lexical.FileSystem.IFileSystem)">
            <summary>
            Get hashcode
            </summary>
            <param name="filesystem"></param>
            <returns></returns>
        </member>
        <member name="T:Lexical.FileSystem.Utility.FileSystemComparer">
            <summary>
            Compares <see cref="T:Lexical.FileSystem.FileSystem"/> instances.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Utility.FileSystemComparer.Equals(Lexical.FileSystem.IFileSystem,Lexical.FileSystem.IFileSystem)">
            <summary>
            Compare for <see cref="F:Lexical.FileSystem.FileSystem.Path"/> equality.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Utility.FileSystemComparer.GetHashCode(Lexical.FileSystem.IFileSystem)">
            <summary>
            Get hashcode
            </summary>
            <param name="filesystem"></param>
            <returns></returns>
        </member>
        <member name="T:Lexical.FileSystem.Utility.FileProviderSystemComparer">
            <summary>
            Compares <see cref="T:Lexical.FileSystem.Decoration.FileProviderSystem"/> instances.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Utility.FileProviderSystemComparer.Equals(Lexical.FileSystem.IFileSystem,Lexical.FileSystem.IFileSystem)">
            <summary>
            Compare for <see cref="F:Lexical.FileSystem.FileSystem.Path"/> equality.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Utility.FileProviderSystemComparer.GetHashCode(Lexical.FileSystem.IFileSystem)">
            <summary>
            Get hashcode
            </summary>
            <param name="filesystem"></param>
            <returns></returns>
        </member>
        <member name="T:Lexical.FileSystem.Utility.FileSystemCompositionComparer">
            <summary>
            Compares <see cref="T:Lexical.FileSystem.Decoration.FileSystemDecoration"/> instances for equal filesystems in equal order.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Utility.FileSystemCompositionComparer.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Utility.FileSystemCompositionComparer.#ctor(System.Collections.Generic.IEqualityComparer{Lexical.FileSystem.IFileSystem})">
            <summary>
            
            </summary>
            <param name="componentComparer"></param>
        </member>
        <member name="M:Lexical.FileSystem.Utility.FileSystemCompositionComparer.Equals(Lexical.FileSystem.IFileSystem,Lexical.FileSystem.IFileSystem)">
            <summary>
            Compare for equal filesystems in equal order.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Utility.FileSystemCompositionComparer.GetHashCode(Lexical.FileSystem.IFileSystem)">
            <summary>
            Get hashcode
            </summary>
            <param name="filesystem"></param>
            <returns></returns>
        </member>
        <member name="T:Lexical.FileSystem.Utility.MemoryFile">
            <summary>
            Memory based file. File is based on blocks (1024 bytes with default settings).
            
            Multiple concurrent streams can be opened to the file. 
            
            Maximum length of the file is <see cref="F:System.Int32.MaxValue"/>*<see cref="F:Lexical.FileSystem.Utility.MemoryFile.BlockSize"/>.
            
            Disposing is optional and can be left to be garbage collected. Disposing, how ever, closes observers.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Utility.MemoryFile.blocks">
            <summary>
            Allocated blocks
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Utility.MemoryFile.blockLock">
            <summary>
            Lock for modifying <see cref="F:Lexical.FileSystem.Utility.MemoryFile.blocks"/>.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Utility.MemoryFile.m_stream_lock">
            <summary>
            Critical section lock for opening streams, checks read/write permission.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Utility.MemoryFile.observers">
            <summary>
            Observers
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Utility.MemoryFile.streams">
            <summary>
            Open streams
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Utility.MemoryFile.lastChangeEvent">
            <summary>
            Last time change event was sent.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Utility.MemoryFile.ChangeEventTolerance">
            <summary>
            Time to wait between forwarding change events to observers.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Utility.MemoryFile.isDisposed">
            <summary>
            Is object disposed.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Utility.MemoryFile.length">
            <summary>
            Total length.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Utility.MemoryFile.Length">
            <summary>
            File length
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Utility.MemoryFile.LastModified">
            <summary>
            Datetime when file was last modified
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Utility.MemoryFile.BlockSize">
            <summary>
            Block size
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Utility.MemoryFile.blockPool">
            <summary>
            Block pool that allocates memory blocks.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Utility.MemoryFile.Path">
            <summary>Path hint provided in construction. Used in exceptions and in ToString(). Readable as public property.</summary>
        </member>
        <member name="M:Lexical.FileSystem.Utility.MemoryFile.#ctor">
            <summary>
            Create memory based file.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Utility.MemoryFile.#ctor(System.Int32)">
            <summary>
            Create memory based file.
            </summary>
            <param name="blockSize"></param>
        </member>
        <member name="M:Lexical.FileSystem.Utility.MemoryFile.#ctor(Lexical.FileSystem.Utility.IBlockPool)">
            <summary>
            Create memory based file.
            </summary>
            <param name="blockPool"></param>
        </member>
        <member name="M:Lexical.FileSystem.Utility.MemoryFile.#ctor(Lexical.FileSystem.Utility.IBlockPool,System.String)">
            <summary>
            Create memory based file.
            </summary>
            <param name="blockPool"></param>
            <param name="pathHint">Path to use in ToString()</param>
        </member>
        <member name="T:Lexical.FileSystem.Utility.MemoryFile.ModifiedEvent">
            <summary>
            Event that notifies about modifying the file.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Utility.MemoryFile.ModifiedEvent.File">
            <summary>
            The file that was modified
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Utility.MemoryFile.ModifiedEvent.Time">
            <summary>
            Time of event
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Utility.MemoryFile.ModifiedEvent.#ctor(Lexical.FileSystem.Utility.MemoryFile,System.DateTimeOffset)">
            <summary>
            Create event
            </summary>
            <param name="file"></param>
            <param name="time"></param>
        </member>
        <member name="M:Lexical.FileSystem.Utility.MemoryFile.Subscribe(System.IObserver{Lexical.FileSystem.Utility.MemoryFile.ModifiedEvent})">
            <summary>
            Subscribe to memory file.
            </summary>
            <param name="observer"></param>
            <returns></returns>
        </member>
        <member name="T:Lexical.FileSystem.Utility.MemoryFile.ObserverHandle">
            <summary>
            Handle that removes <see cref="F:Lexical.FileSystem.Utility.MemoryFile.ObserverHandle.observer"/> from <see cref="F:Lexical.FileSystem.Utility.MemoryFile.ObserverHandle.observers"/> when disposed.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Utility.MemoryFile.Dispose">
            <summary>
            Dispose memory file.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Utility.MemoryFile.Dispose(System.Boolean)">
            <summary>
            Dispose memory file.
            </summary>
            <param name="disposing">if false, called from finalized and needs to dispose only unmanaged resources</param>
        </member>
        <member name="M:Lexical.FileSystem.Utility.MemoryFile.SendChangeEvent">
            <summary>
            Send change event, if needed.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Utility.MemoryFile.Open(System.IO.FileAccess,System.IO.FileShare)">
            <summary>
            Open a new stream to memory file.
            </summary>
            <param name="fileAccess"></param>
            <param name="fileShare"></param>
            <returns></returns>
            <exception cref="T:Lexical.FileSystem.FileSystemExceptionNoReadAccess">No read access</exception>
            <exception cref="T:Lexical.FileSystem.FileSystemExceptionNoWriteAccess">No write access</exception>
        </member>
        <member name="M:Lexical.FileSystem.Utility.MemoryFile.Clear">
            <summary>
            Clear file
            </summary>
        </member>
        <member name="T:Lexical.FileSystem.Utility.MemoryFile.Stream">
            <summary>
            Stream to <see cref="T:Lexical.FileSystem.Utility.MemoryFile"/>.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Utility.MemoryFile.Stream.parent">
            <summary>
            Parent
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Utility.MemoryFile.Stream.blocks">
            <summary>
            Blocks
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Utility.MemoryFile.Stream.blockLock">
            <summary>
            Block lock object for modifying <see cref="F:Lexical.FileSystem.Utility.MemoryFile.Stream.blocks"/>.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Utility.MemoryFile.Stream.blockSize">
            <summary>
            Block size
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Utility.MemoryFile.Stream.FileAccess">
            <summary>
            File access
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Utility.MemoryFile.Stream.FileShare">
            <summary>
            Share
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Utility.MemoryFile.Stream.position">
            <summary>
            Stream position.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Utility.MemoryFile.Stream.canRead">
            <summary>
            Permissions
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Utility.MemoryFile.Stream.canWrite">
            <summary>
            Permissions
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Utility.MemoryFile.Stream.CanRead">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Utility.MemoryFile.Stream.CanSeek">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Utility.MemoryFile.Stream.CanWrite">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Utility.MemoryFile.Stream.Length">
            <summary>File length</summary>
        </member>
        <member name="P:Lexical.FileSystem.Utility.MemoryFile.Stream.Position">
            <summary>
            Position of the stream.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Utility.MemoryFile.Stream.#ctor(Lexical.FileSystem.Utility.MemoryFile,System.IO.FileAccess,System.IO.FileShare)">
            <summary>
            Create stream.
            </summary>
            <param name="parent"></param>
            <param name="fileAccess"></param>
            <param name="fileShare"></param>
        </member>
        <member name="M:Lexical.FileSystem.Utility.MemoryFile.Stream.Flush">
            <summary>No action</summary>
        </member>
        <member name="M:Lexical.FileSystem.Utility.MemoryFile.Stream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads a sequence of bytes from the current stream and advances the position within the stream by the number of bytes read.
            </summary>
            <param name="buffer">An array of bytes. When this method returns, the buffer contains the specified byte array with the values between offset and (offset + count - 1) replaced by the bytes read from the current source.</param>
            <param name="offset">The zero-based byte offset in buffer at which to begin storing the data read from the current stream.</param>
            <param name="count">The maximum number of bytes to be read from the current stream.</param>
            <returns>The total number of bytes read into the buffer. This can be less than the number of bytes requested if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.</returns>
            <exception cref="T:System.ArgumentException">The sum of offset and count is larger than the buffer length.</exception>
            <exception cref="T:System.ArgumentNullException">buffer is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">offset or count is negative.</exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs</exception>
            <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed.</exception>
        </member>
        <member name="M:Lexical.FileSystem.Utility.MemoryFile.Stream.ReadByte">
            <summary>
            Reads a byte from the stream and advances the position within the stream by one byte, or returns -1 if at the end of the stream.
            </summary>
            <returns>The unsigned byte cast to an Int32, or -1 if at the end of the stream.</returns>
            <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed.</exception>
        </member>
        <member name="M:Lexical.FileSystem.Utility.MemoryFile.Stream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Sets the position within the current stream.
            </summary>
            <param name="offset">A byte offset relative to the origin parameter.</param>
            <param name="origin">A value of type System.IO.SeekOrigin indicating the reference point used to obtain the new position.</param>
            <returns>The new position within the current stream.</returns>
            <exception cref="T:System.IO.IOException">An I/O error occurs</exception>
            <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed.</exception>
        </member>
        <member name="M:Lexical.FileSystem.Utility.MemoryFile.Stream.SetLength(System.Int64)">
            <summary>
            Sets the length of the current stream.
            </summary>
            <param name="newLength">The desired length of the current stream in bytes.</param>
            <exception cref="T:System.IO.IOException">An I/O error occurs</exception>
            <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed.</exception>
        </member>
        <member name="M:Lexical.FileSystem.Utility.MemoryFile.Stream.WipeBlock(System.Byte[])">
            <summary>Zero <paramref name="block"/> contents.</summary>
            <param name="block"></param>
        </member>
        <member name="M:Lexical.FileSystem.Utility.MemoryFile.Stream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written.
            </summary>
            <param name="buffer">An array of bytes. This method copies count bytes from buffer to the current stream.</param>
            <param name="offset">The zero-based byte offset in buffer at which to begin copying bytes to the current stream.</param>
            <param name="count">The number of bytes to be written to the current stream.</param>
            <exception cref="T:System.ArgumentException">The sum of offset and count is greater than the buffer length.</exception>
            <exception cref="T:System.ArgumentNullException">buffer is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">offset or count is negative.</exception>
            <exception cref="T:System.IO.IOException">An I/O error occured, such as the specified file cannot be found.</exception>
            <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed.</exception>
        </member>
        <member name="M:Lexical.FileSystem.Utility.MemoryFile.Stream.WriteByte(System.Byte)">
            <summary>
            Writes a byte to the current position in the stream and advances the position within the stream by one byte.
            </summary>
            <param name="value">The byte to write to the stream.</param>
            <exception cref="T:System.IO.IOException">An I/O error occured, such as the specified file cannot be found.</exception>
            <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed.</exception>
        </member>
        <member name="M:Lexical.FileSystem.Utility.MemoryFile.Stream.InnerDispose(Lexical.FileSystem.Internal.StructList4{System.Exception}@)">
            <summary>
            Close stream, relase share protections in <see cref="T:Lexical.FileSystem.Utility.MemoryFile"/>.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Utility.MemoryFile.ToString">
            <summary>Print info</summary>
        </member>
        <member name="T:Lexical.FileSystem.Utility.StreamDecoration">
            <summary>
            Base implementation of <see cref="T:System.IO.Stream"/> decoration.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Utility.StreamDecoration.Source">
            <summary>
            Source stream.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Utility.StreamDecoration.#ctor(System.IO.Stream)">
            <summary>
            Create <see cref="T:System.IO.Stream"/> decoration.
            </summary>
            <param name="sourceStream">source stream that is to be decorated</param>
        </member>
        <member name="P:Lexical.FileSystem.Utility.StreamDecoration.CanRead">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Utility.StreamDecoration.CanSeek">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Utility.StreamDecoration.CanWrite">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Utility.StreamDecoration.Length">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Utility.StreamDecoration.Position">
            <inheritdoc/>
        </member>
        <member name="M:Lexical.FileSystem.Utility.StreamDecoration.Flush">
            <inheritdoc/>
        </member>
        <member name="M:Lexical.FileSystem.Utility.StreamDecoration.Read(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Lexical.FileSystem.Utility.StreamDecoration.Seek(System.Int64,System.IO.SeekOrigin)">
            <inheritdoc/>
        </member>
        <member name="M:Lexical.FileSystem.Utility.StreamDecoration.SetLength(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Lexical.FileSystem.Utility.StreamDecoration.Write(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Lexical.FileSystem.Utility.StreamDecoration.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Lexical.FileSystem.Utility.StreamDecoration.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Utility.StreamDecoration.CanTimeout">
            <inheritdoc/>
        </member>
        <member name="M:Lexical.FileSystem.Utility.StreamDecoration.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Lexical.FileSystem.Utility.StreamDecoration.EndRead(System.IAsyncResult)">
            <inheritdoc/>
        </member>
        <member name="M:Lexical.FileSystem.Utility.StreamDecoration.EndWrite(System.IAsyncResult)">
            <inheritdoc/>
        </member>
        <member name="M:Lexical.FileSystem.Utility.StreamDecoration.FlushAsync(System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Lexical.FileSystem.Utility.StreamDecoration.InitializeLifetimeService">
            <inheritdoc/>
        </member>
        <member name="M:Lexical.FileSystem.Utility.StreamDecoration.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Lexical.FileSystem.Utility.StreamDecoration.ReadByte">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Utility.StreamDecoration.ReadTimeout">
            <inheritdoc/>
        </member>
        <member name="M:Lexical.FileSystem.Utility.StreamDecoration.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Lexical.FileSystem.Utility.StreamDecoration.WriteByte(System.Byte)">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.Utility.StreamDecoration.WriteTimeout">
            <inheritdoc/>
        </member>
        <member name="M:Lexical.FileSystem.Utility.StreamDecoration.Close">
            <inheritdoc/>
        </member>
        <member name="M:Lexical.FileSystem.Utility.StreamDecoration.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Lexical.FileSystem.Utility.StreamDecoration.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Lexical.FileSystem.Utility.StreamDecoration.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Lexical.FileSystem.Utility.StreamDecoration.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Lexical.FileSystem.Utility.StreamDisposeList">
            <summary>
            Base implementation of <see cref="T:System.IO.Stream"/> that also implements <see cref="T:Lexical.FileSystem.Utility.IDisposeList"/> and <see cref="T:Lexical.FileSystem.Utility.IBelatableDispose"/>.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Utility.StreamDisposeList.m_disposelist_lock">
            <summary>
            Lock for modifying <see cref="T:Lexical.FileSystem.Utility.DisposeList"/>.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Utility.StreamDisposeList.disposeList">
            <summary>
            List of disposables that has been attached with this object.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Utility.StreamDisposeList.disposing">
            <summary>
            State that is set when disposing starts and finalizes.
            Is changed with Interlocked. 
             0 - not disposed
             1 - dispose called, but not started
             2 - disposing started
             3 - disposed
             
            When disposing starts, new objects cannot be added to the object, instead they are disposed right at away.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Utility.StreamDisposeList.IsDisposeCalled">
            <summary>
            Has Dispose() been called.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Utility.StreamDisposeList.IsDisposing">
            <summary>
            Has disposing has started or completed.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Utility.StreamDisposeList.IsDisposed">
            <summary>
            Is disposing completed
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Utility.StreamDisposeList.belateHandleCount">
            <summary>
            Number of belate handles
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Utility.StreamDisposeList.nonDisposable">
            <summary>
            Non disposable is a flag for objects that cannot be disposed, such as singleton instances.
            <see cref="F:Lexical.FileSystem.Utility.StreamDisposeList.nonDisposable"/> is set at construction.
            
            Use method <see cref="M:Lexical.FileSystem.Utility.StreamDisposeList.SetToNonDisposable"/> to modify the state at constructor.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Utility.StreamDisposeList.SetToNonDisposable">
            <summary>
            Non-disposable is a flag for objects that cannot be disposed, such as singleton instances.
            <see cref="F:Lexical.FileSystem.Utility.StreamDisposeList.nonDisposable"/> is set at construction.
            
            When <see cref="M:Lexical.FileSystem.Utility.StreamDisposeList.Dispose(System.Boolean)"/> is called for non-disposable object, the attached disposables
            are removed and disposed, but the object itself does not go into disposed state.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Utility.StreamDisposeList.BelateDispose">
            <summary>
            Delay dispose until belate handle is disposed.
            </summary>
            <returns></returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if object has already been disposed.</exception>
        </member>
        <member name="T:Lexical.FileSystem.Utility.StreamDisposeList.BelateHandle">
            <summary>
            A handle that postpones dispose of the <see cref="T:Lexical.FileSystem.Utility.DisposeList"/> object.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Utility.StreamDisposeList.Dispose(System.Boolean)">
            <summary>
            Dispose all attached diposables and call <see cref="M:Lexical.FileSystem.Utility.StreamDisposeList.InnerDispose(Lexical.FileSystem.Internal.StructList4{System.Exception}@)"/>.
            </summary>
            <param name="_disposing">dummy argument</param>
            <exception cref="T:System.AggregateException">thrown if disposing threw errors</exception>
        </member>
        <member name="M:Lexical.FileSystem.Utility.StreamDisposeList.ProcessDispose">
            <summary>
            Process the actual dispose. This may be called from <see cref="M:Lexical.FileSystem.Utility.StreamDisposeList.Dispose(System.Boolean)"/> or from the dispose of the last
            belate handle (After <see cref="M:Lexical.FileSystem.Utility.StreamDisposeList.Dispose(System.Boolean)"/> has been called aswell).
            
            Only one thread may process the dispose.
            Sets state to 2, and then 3.
            
            Unattaches all disposables, disposes them, and calls <see cref="M:Lexical.FileSystem.Utility.StreamDisposeList.InnerDispose(Lexical.FileSystem.Internal.StructList4{System.Exception}@)"/>.
            </summary>
            <exception cref="T:System.AggregateException">thrown if disposing threw errors</exception>
        </member>
        <member name="M:Lexical.FileSystem.Utility.StreamDisposeList.ProcessNonDispose">
            <summary>
            Process the non-dispose. Used when <see cref="F:Lexical.FileSystem.Utility.StreamDisposeList.nonDisposable"/> is true (singleton instances).
            
            This may be called from <see cref="M:Lexical.FileSystem.Utility.StreamDisposeList.Dispose(System.Boolean)"/> or from the dispose of the last
            belate handle (After <see cref="M:Lexical.FileSystem.Utility.StreamDisposeList.Dispose(System.Boolean)"/> has been called aswell).
            
            Only one thread may process the dispose. Returns state back to 0.
            
            Unattaches all disposables, disposes them, and calls <see cref="M:Lexical.FileSystem.Utility.StreamDisposeList.InnerDispose(Lexical.FileSystem.Internal.StructList4{System.Exception}@)"/>.
            Does not set state 
            </summary>
            <exception cref="T:System.AggregateException">thrown if disposing threw errors</exception>
        </member>
        <member name="M:Lexical.FileSystem.Utility.StreamDisposeList.InnerDispose(Lexical.FileSystem.Internal.StructList4{System.Exception}@)">
            <summary>
            Override this for dispose mechanism of the implementing class.
            </summary>
            <param name="disposeErrors">list that can be instantiated and where errors can be added</param>
            <exception cref="T:System.Exception">any exception is captured and aggregated with other errors</exception>
        </member>
        <member name="M:Lexical.FileSystem.Utility.StreamDisposeList.Lexical#FileSystem#Utility#IDisposeList#AddDisposable(System.Object)">
            <summary>
            Add <paramref name="disposableObject"/> to be disposed with the object.
            
            If parent object is disposed or being disposed, the disposable will be disposed immedialy.
            </summary>
            <param name="disposableObject"></param>
            <returns>true if was added to list, false if was disposed right away</returns>
        </member>
        <member name="M:Lexical.FileSystem.Utility.StreamDisposeList.Lexical#FileSystem#Utility#IDisposeList#AddDisposeAction(System.Action{System.Object},System.Object)">
            <summary>
            Invoke <paramref name="disposeAction"/> on the dispose of the object.
            
            If parent object is disposed or being disposed, the disposable will be disposed immedialy.
            </summary>
            <param name="disposeAction"></param>
            <param name="state"></param>
            <returns>true if was added to list, false if was disposed right away</returns>
        </member>
        <member name="M:Lexical.FileSystem.Utility.StreamDisposeList.Lexical#FileSystem#Utility#IDisposeList#AddDisposables(System.Collections.IEnumerable)">
            <summary>
            Add <paramref name="disposableObjects"/> to be disposed with the object.
            </summary>
            <param name="disposableObjects"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Utility.StreamDisposeList.Lexical#FileSystem#Utility#IDisposeList#RemoveDisposable(System.Object)">
            <summary>
            Remove <paramref name="disposableObject"/> from list of attached disposables.
            </summary>
            <param name="disposableObject"></param>
            <returns>true if an item of <paramref name="disposableObject"/> was removed, false if it wasn't there</returns>
        </member>
        <member name="M:Lexical.FileSystem.Utility.StreamDisposeList.Lexical#FileSystem#Utility#IDisposeList#RemoveDisposables(System.Collections.IEnumerable)">
            <summary>
            Remove <paramref name="disposableObjects"/> from the list. 
            </summary>
            <param name="disposableObjects"></param>
            <returns>true if was removed, false if it wasn't in the list.</returns>
        </member>
        <member name="T:Lexical.FileSystem.Utility.StreamDisposeListDecoration">
            <summary>
            Decoration of <see cref="T:System.IO.Stream"/> that also implements <see cref="T:Lexical.FileSystem.Utility.IDisposeList"/> and <see cref="T:Lexical.FileSystem.Utility.IBelatableDispose"/>.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Utility.StreamDisposeListDecoration.m_disposelist_lock">
            <summary>
            Lock for modifying <see cref="T:Lexical.FileSystem.Utility.DisposeList"/>.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Utility.StreamDisposeListDecoration.disposeList">
            <summary>
            List of disposables that has been attached with this object.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Utility.StreamDisposeListDecoration.disposing">
            <summary>
            State that is set when disposing starts and finalizes.
            Is changed with Interlocked. 
             0 - not disposed
             1 - dispose called, but not started
             2 - disposing started
             3 - disposed
             
            When disposing starts, new objects cannot be added to the object, instead they are disposed right at away.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Utility.StreamDisposeListDecoration.IsDisposeCalled">
            <summary>
            Has Dispose() been called.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Utility.StreamDisposeListDecoration.IsDisposing">
            <summary>
            Has disposing has started or completed.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Utility.StreamDisposeListDecoration.IsDisposed">
            <summary>
            Is disposing completed
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Utility.StreamDisposeListDecoration.belateHandleCount">
            <summary>
            Number of belate handles
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Utility.StreamDisposeListDecoration.nonDisposable">
            <summary>
            Non disposable is a flag for objects that cannot be disposed, such as singleton instances.
            <see cref="F:Lexical.FileSystem.Utility.StreamDisposeListDecoration.nonDisposable"/> is set at construction.
            
            Use method <see cref="M:Lexical.FileSystem.Utility.StreamDisposeListDecoration.SetToNonDisposable"/> to modify the state at constructor.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Utility.StreamDisposeListDecoration.#ctor(System.IO.Stream)">
            <summary>
            Create <see cref="T:System.IO.Stream"/> decoration.
            </summary>
            <param name="sourceStream">source stream that is to be decorated</param>
        </member>
        <member name="M:Lexical.FileSystem.Utility.StreamDisposeListDecoration.SetToNonDisposable">
            <summary>
            Non-disposable is a flag for objects that cannot be disposed, such as singleton instances.
            <see cref="F:Lexical.FileSystem.Utility.StreamDisposeListDecoration.nonDisposable"/> is set at construction.
            
            When <see cref="M:Lexical.FileSystem.Utility.StreamDisposeListDecoration.Dispose(System.Boolean)"/> is called for non-disposable object, the attached disposables
            are removed and disposed, but the object itself does not go into disposed state.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Utility.StreamDisposeListDecoration.BelateDispose">
            <summary>
            Delay dispose until belate handle is disposed.
            </summary>
            <returns></returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if object has already been disposed.</exception>
        </member>
        <member name="T:Lexical.FileSystem.Utility.StreamDisposeListDecoration.BelateHandle">
            <summary>
            A handle that postpones dispose of the <see cref="T:Lexical.FileSystem.Utility.DisposeList"/> object.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Utility.StreamDisposeListDecoration.Dispose(System.Boolean)">
            <summary>
            Dispose all attached diposables and call <see cref="M:Lexical.FileSystem.Utility.StreamDisposeListDecoration.InnerDispose(Lexical.FileSystem.Internal.StructList4{System.Exception}@)"/>.
            </summary>
            <param name="_disposing"></param>
            <exception cref="T:System.AggregateException">thrown if disposing threw errors</exception>
        </member>
        <member name="M:Lexical.FileSystem.Utility.StreamDisposeListDecoration.Close">
            <summary>
            Dispose all attached diposables and call <see cref="M:Lexical.FileSystem.Utility.StreamDisposeListDecoration.InnerDispose(Lexical.FileSystem.Internal.StructList4{System.Exception}@)"/>.
            </summary>
            <exception cref="T:System.AggregateException">thrown if disposing threw errors</exception>
        </member>
        <member name="M:Lexical.FileSystem.Utility.StreamDisposeListDecoration.ProcessDispose">
            <summary>
            Process the actual dispose. This may be called from <see cref="M:Lexical.FileSystem.Utility.StreamDisposeListDecoration.Dispose(System.Boolean)"/> or from the dispose of the last
            belate handle (After <see cref="M:Lexical.FileSystem.Utility.StreamDisposeListDecoration.Dispose(System.Boolean)"/> has been called aswell).
            
            Only one thread may process the dispose.
            Sets state to 2, and then 3.
            
            Unattaches all disposables, disposes them, and calls <see cref="M:Lexical.FileSystem.Utility.StreamDisposeListDecoration.InnerDispose(Lexical.FileSystem.Internal.StructList4{System.Exception}@)"/>.
            </summary>
            <exception cref="T:System.AggregateException">thrown if disposing threw errors</exception>
        </member>
        <member name="M:Lexical.FileSystem.Utility.StreamDisposeListDecoration.ProcessNonDispose">
            <summary>
            Process the non-dispose. Used when <see cref="F:Lexical.FileSystem.Utility.StreamDisposeListDecoration.nonDisposable"/> is true (singleton instances).
            
            This may be called from <see cref="M:Lexical.FileSystem.Utility.StreamDisposeListDecoration.Dispose(System.Boolean)"/> or from the dispose of the last
            belate handle (After <see cref="M:Lexical.FileSystem.Utility.StreamDisposeListDecoration.Dispose(System.Boolean)"/> has been called aswell).
            
            Only one thread may process the dispose. Returns state back to 0.
            
            Unattaches all disposables, disposes them, and calls <see cref="M:Lexical.FileSystem.Utility.StreamDisposeListDecoration.InnerDispose(Lexical.FileSystem.Internal.StructList4{System.Exception}@)"/>.
            Does not set state 
            </summary>
            <exception cref="T:System.AggregateException">thrown if disposing threw errors</exception>
        </member>
        <member name="M:Lexical.FileSystem.Utility.StreamDisposeListDecoration.InnerDispose(Lexical.FileSystem.Internal.StructList4{System.Exception}@)">
            <summary>
            Override this for dispose mechanism of the implementing class.
            </summary>
            <param name="disposeErrors">list that can be instantiated and where errors can be added</param>
            <exception cref="T:System.Exception">any exception is captured and aggregated with other errors</exception>
        </member>
        <member name="M:Lexical.FileSystem.Utility.StreamDisposeListDecoration.Lexical#FileSystem#Utility#IDisposeList#AddDisposable(System.Object)">
            <summary>
            Add <paramref name="disposableObject"/> to be disposed with the object.
            
            If parent object is disposed or being disposed, the disposable will be disposed immedialy.
            </summary>
            <param name="disposableObject"></param>
            <returns>true if was added to list, false if was disposed right away</returns>
        </member>
        <member name="M:Lexical.FileSystem.Utility.StreamDisposeListDecoration.Lexical#FileSystem#Utility#IDisposeList#AddDisposeAction(System.Action{System.Object},System.Object)">
            <summary>
            Invoke <paramref name="disposeAction"/> on the dispose of the object.
            
            If parent object is disposed or being disposed, the disposable will be disposed immedialy.
            </summary>
            <param name="disposeAction"></param>
            <param name="state"></param>
            <returns>true if was added to list, false if was disposed right away</returns>
        </member>
        <member name="M:Lexical.FileSystem.Utility.StreamDisposeListDecoration.Lexical#FileSystem#Utility#IDisposeList#AddDisposables(System.Collections.IEnumerable)">
            <summary>
            Add <paramref name="disposableObjects"/> to be disposed with the object.
            </summary>
            <param name="disposableObjects"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Utility.StreamDisposeListDecoration.Lexical#FileSystem#Utility#IDisposeList#RemoveDisposable(System.Object)">
            <summary>
            Remove <paramref name="disposableObject"/> from list of attached disposables.
            </summary>
            <param name="disposableObject"></param>
            <returns>true if an item of <paramref name="disposableObject"/> was removed, false if it wasn't there</returns>
        </member>
        <member name="M:Lexical.FileSystem.Utility.StreamDisposeListDecoration.Lexical#FileSystem#Utility#IDisposeList#RemoveDisposables(System.Collections.IEnumerable)">
            <summary>
            Remove <paramref name="disposableObjects"/> from the list. 
            </summary>
            <param name="disposableObjects"></param>
            <returns>true if was removed, false if it wasn't in the list.</returns>
        </member>
        <member name="T:Lexical.FileSystem.Utility.StreamUtils">
            <summary>
            Stream utils
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Utility.StreamUtils.ReadFully(System.IO.Stream)">
            <summary>
            Read bytes from <paramref name="s"/>.
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Utility.StreamUtils.ReadFullyAsync(System.IO.Stream)">
            <summary>
            Read bytes from <paramref name="s"/>.
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Utility.StreamUtils.ReadTextFullyAsync(System.IO.Stream)">
            <summary>
            Read text from <paramref name="s"/>.
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="T:Lexical.FileSystem.ObserverBase">
            <summary>
            Base implementation filesystem observer
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.ObserverBase.FileSystem">
            <summary>
            The file system where the observer was attached.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.ObserverBase.Filter">
            <summary>
            File glob-pattern filter.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.ObserverBase.Observer">
            <summary>
            Callback.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.ObserverBase.State">
            <summary>
            State object that was attached at construction.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.ObserverBase.Dispatcher">
            <summary>
            Event dispatcher.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.ObserverBase.#ctor(Lexical.FileSystem.IFileSystem,System.String,System.IObserver{Lexical.FileSystem.IEvent},System.Object,Lexical.FileSystem.IEventDispatcher)">
            <summary>
            Create observer.
            </summary>
            <param name="filesystem"></param>
            <param name="filter"></param>
            <param name="observer"></param>
            <param name="state"></param>
            <param name="eventDispatcher"></param>
        </member>
        <member name="M:Lexical.FileSystem.ObserverBase.InnerDispose(Lexical.FileSystem.Internal.StructList4{System.Exception}@)">
            <summary>
            Dispose observer
            </summary>
            <param name="disposeErrors"></param>
        </member>
        <member name="T:Lexical.FileSystem.FileSystemObserverDecoration">
            <summary>
            Base class for observer handle decoration.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemObserverDecoration.DecorateFileSystem(Lexical.FileSystem.IFileSystemObserver,Lexical.FileSystem.IFileSystem)">
            <summary>
            Decorate FileSystem value.
            </summary>
            <param name="original"></param>
            <param name="newFileSystem"></param>
            <returns>decoration</returns>
        </member>
        <member name="P:Lexical.FileSystem.FileSystemObserverDecoration.FileSystem">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.FileSystemObserverDecoration.Filter">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.FileSystemObserverDecoration.Observer">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.FileSystemObserverDecoration.State">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.FileSystemObserverDecoration.Dispatcher">
            <inheritdoc/>
        </member>
        <member name="F:Lexical.FileSystem.FileSystemObserverDecoration.original">
            <summary>
            Original observer handle
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemObserverDecoration.#ctor(Lexical.FileSystem.IFileSystemObserver)">
            <summary>
            Create filesystem observer handle decoration.
            </summary>
            <param name="original"></param>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemObserverDecoration.Dispose">
            <summary></summary>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemObserverDecoration.Dispose(System.Boolean)">
            <summary></summary>
        </member>
        <member name="T:Lexical.FileSystem.FileSystemObserverDecoration.NewFileSystem">
            <summary>Class with overridden filesystem.</summary>
        </member>
        <member name="F:Lexical.FileSystem.FileSystemObserverDecoration.NewFileSystem.newFilesystem">
            <summary>Overriding filesystem.</summary>
        </member>
        <member name="P:Lexical.FileSystem.FileSystemObserverDecoration.NewFileSystem.FileSystem">
            <summary>Return overridden filesystem.</summary>
        </member>
        <member name="M:Lexical.FileSystem.FileSystemObserverDecoration.NewFileSystem.#ctor(Lexical.FileSystem.IFileSystemObserver,Lexical.FileSystem.IFileSystem)">
            <summary>
            Create decoration with new filesystem.
            </summary>
            <param name="original"></param>
            <param name="newFilesystem"></param>
        </member>
        <member name="T:Lexical.FileSystem.Operation.Batch">
            <summary>Batch operation</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.Batch.Ops">
            <summary>Ops.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.Batch.Children">
            <summary>Child operations</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.Batch.FileSystem">
            <summary>Target filesystem if same for all ops, otherwise null</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.Batch.Path">
            <summary>Target path if same for all ops, otherwise null</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.Batch.SrcFileSystem">
            <summary>Source filesystem if same for all ops, otherwise null</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.Batch.SrcPath">
            <summary>Source path if same for all ops, otherwise null</summary>
        </member>
        <member name="M:Lexical.FileSystem.Operation.Batch.#ctor(Lexical.FileSystem.Operation.IOperationSession,Lexical.FileSystem.Operation.OperationPolicy,System.Collections.Generic.IEnumerable{Lexical.FileSystem.Operation.IOperation})">
            <summary>Create batch op.</summary>
        </member>
        <member name="M:Lexical.FileSystem.Operation.Batch.#ctor(Lexical.FileSystem.Operation.IOperationSession,Lexical.FileSystem.Operation.OperationPolicy,Lexical.FileSystem.Operation.IOperation[])">
            <summary>Create batch op.</summary>
        </member>
        <member name="M:Lexical.FileSystem.Operation.Batch.InnerEstimate">
            <summary>Estimate child ops</summary>
            <exception cref="T:System.Exception">On error</exception>
        </member>
        <member name="M:Lexical.FileSystem.Operation.Batch.InnerRun">
            <summary>Run child ops</summary>
        </member>
        <member name="M:Lexical.FileSystem.Operation.Batch.CreateRollback">
            <summary>Create rollback operation.</summary>
            <returns>rollback or null</returns>
        </member>
        <member name="M:Lexical.FileSystem.Operation.Batch.ToString">
            <summary>Print info</summary>
        </member>
        <member name="T:Lexical.FileSystem.Operation.CopyFile">
            <summary>Copy file</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.CopyFile.srcFileSystem">
            <summary>Source filesystem</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.CopyFile.dstFileSystem">
            <summary>Target filesystem</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.CopyFile.srcPath">
            <summary>Source path</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.CopyFile.dstPath">
            <summary>Target path</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.CopyFile.FileSystem">
            <summary>Target filesystem</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.CopyFile.Path">
            <summary>Target path</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.CopyFile.SrcFileSystem">
            <summary>Source filesystem</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.CopyFile.SrcPath">
            <summary>Source path</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.CopyFile.srcOption">
            <summary>Src filesystem option or token</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.CopyFile.Option">
            <summary>Target filesystem option or token</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.CopyFile.Overwritten">
            <summary>Was file overwritten</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.CopyFile.createdFile">
            <summary>Set to true if <see cref="M:Lexical.FileSystem.Operation.IOperation.Run(System.Boolean)"/> created file.</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.CopyFile.copied">
            <summary>Set to true if <see cref="M:Lexical.FileSystem.Operation.IOperation.Run(System.Boolean)"/> copied.</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.CopyFile.prevExisted">
            <summary>Set to true if <see cref="M:Lexical.FileSystem.Operation.IOperation.Run(System.Boolean)"/> previous entry existed.</summary>
        </member>
        <member name="M:Lexical.FileSystem.Operation.CopyFile.#ctor(Lexical.FileSystem.Operation.IOperationSession,Lexical.FileSystem.IFileSystem,System.String,Lexical.FileSystem.IFileSystem,System.String,Lexical.FileSystem.IOption,Lexical.FileSystem.IOption,Lexical.FileSystem.Operation.OperationPolicy)">
            <summary>Create copy file op.</summary>
        </member>
        <member name="M:Lexical.FileSystem.Operation.CopyFile.InnerEstimate">
            <summary>Estimate viability of operation.</summary>
            <exception cref="T:System.IO.FileNotFoundException">If <see cref="P:Lexical.FileSystem.Operation.CopyFile.SrcPath"/> is not found.</exception>
            <exception cref="T:Lexical.FileSystem.FileSystemExceptionEntryExists">If <see cref="P:Lexical.FileSystem.Operation.CopyFile.Path"/> already exists.</exception>
        </member>
        <member name="M:Lexical.FileSystem.Operation.CopyFile.InnerRun">
            <summary>Run operation</summary>
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:System.Exception">Unexpected error</exception>
        </member>
        <member name="M:Lexical.FileSystem.Operation.CopyFile.ReadFile(System.Collections.Concurrent.BlockingCollection{Lexical.FileSystem.Operation.CopyFile.Block})">
            <summary>
            Method that reads source file and places blocks into <paramref name="queue"/>. The receiver must return blocks to blockpool.
            
            This method is to be ran in a concurrent thread.
            
            If cancel is requested, aborts.
            
            If ioexception occurs, then sets op state to error.
            </summary>
            <param name="queue"></param>
        </member>
        <member name="M:Lexical.FileSystem.Operation.CopyFile.CreateRollback">
            <summary>Create rollback operation.</summary>
            <returns>null or rollback operation</returns>
        </member>
        <member name="M:Lexical.FileSystem.Operation.CopyFile.ToString">
            <summary>Print info</summary>
        </member>
        <member name="T:Lexical.FileSystem.Operation.CopyTree">
            <summary>Copy a file or directory tree</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.CopyTree.srcFileSystem">
            <summary>Source filesystem</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.CopyTree.dstFileSystem">
            <summary>Target filesystem</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.CopyTree.srcPath">
            <summary>Source path</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.CopyTree.dstPath">
            <summary>Target path</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.CopyTree.FileSystem">
            <summary>Target filesystem</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.CopyTree.Path">
            <summary>Target path</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.CopyTree.SrcFileSystem">
            <summary>Source filesystem</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.CopyTree.SrcPath">
            <summary>Source path</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.CopyTree.srcOption">
            <summary>Src filesystem option or token</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.CopyTree.Option">
            <summary>Target filesystem option or token</summary>
        </member>
        <member name="M:Lexical.FileSystem.Operation.CopyTree.#ctor(Lexical.FileSystem.Operation.IOperationSession,Lexical.FileSystem.IFileSystem,System.String,Lexical.FileSystem.IFileSystem,System.String,Lexical.FileSystem.IOption,Lexical.FileSystem.IOption,Lexical.FileSystem.Operation.OperationPolicy)">
            <summary>Create move op.</summary>
        </member>
        <member name="M:Lexical.FileSystem.Operation.CopyTree.InnerEstimate">
            <summary>Estimate viability of operation.</summary>
            <exception cref="T:System.IO.FileNotFoundException">If <see cref="P:Lexical.FileSystem.Operation.CopyTree.SrcPath"/> is not found.</exception>
            <exception cref="T:Lexical.FileSystem.FileSystemExceptionFileExists">If <see cref="P:Lexical.FileSystem.Operation.CopyTree.Path"/> already exists.</exception>
        </member>
        <member name="M:Lexical.FileSystem.Operation.CopyTree.ToString">
            <summary>Print info</summary>
        </member>
        <member name="T:Lexical.FileSystem.Operation.CreateDirectory">
            <summary>Create directory</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.CreateDirectory.fileSystem">
            <summary>Target filesystem</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.CreateDirectory.path">
            <summary>Target path</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.CreateDirectory.FileSystem">
            <summary>Target filesystem</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.CreateDirectory.Path">
            <summary>Target path</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.CreateDirectory.DirectoriesCreated">
            <summary>Directories created in Run().</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.CreateDirectory.Option">
            <summary>Target filesystem option or token</summary>
        </member>
        <member name="M:Lexical.FileSystem.Operation.CreateDirectory.#ctor(Lexical.FileSystem.Operation.IOperationSession,Lexical.FileSystem.IFileSystem,System.String,Lexical.FileSystem.IOption,Lexical.FileSystem.Operation.OperationPolicy)">
            <summary>
            Create create directory op.
            </summary>
            <param name="session"></param>
            <param name="filesystem"></param>
            <param name="path"></param>
            <param name="option"></param>
            <param name="policy">(optional) Responds to <see cref="F:Lexical.FileSystem.Operation.OperationPolicy.DstThrow"/>, <see cref="F:Lexical.FileSystem.Operation.OperationPolicy.DstSkip"/> and <see cref="F:Lexical.FileSystem.Operation.OperationPolicy.DstOverwrite"/> policies</param>
        </member>
        <member name="M:Lexical.FileSystem.Operation.CreateDirectory.InnerEstimate">
            <summary>Estimate viability of operation.</summary>
            <exception cref="T:System.IO.FileNotFoundException">If <see cref="P:Lexical.FileSystem.Operation.CreateDirectory.Path"/> is not found.</exception>
        </member>
        <member name="M:Lexical.FileSystem.Operation.CreateDirectory.InnerRun">
            <summary>Create direcotry</summary>
            <exception cref="T:System.IO.FileNotFoundException">If <see cref="P:Lexical.FileSystem.Operation.CreateDirectory.Path"/> is not found.</exception>
            <exception cref="T:Lexical.FileSystem.FileSystemExceptionEntryExists">If file or directory already existed at <see cref="P:Lexical.FileSystem.Operation.CreateDirectory.Path"/> and <see cref="F:Lexical.FileSystem.Operation.OperationPolicy.DstThrow"/> is true.</exception>
        </member>
        <member name="M:Lexical.FileSystem.Operation.CreateDirectory.CreateBlind">
            <summary>Create directory blind</summary>
        </member>
        <member name="M:Lexical.FileSystem.Operation.CreateDirectory.CreateRollback">
            <summary>Create rollback</summary>
            <returns>op or null</returns>
        </member>
        <member name="M:Lexical.FileSystem.Operation.CreateDirectory.ToString">
            <summary>Print info</summary>
        </member>
        <member name="T:Lexical.FileSystem.Operation.Delete">
            <summary>Delete file or directory</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.Delete.fileSystem">
            <summary>Target filesystem</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.Delete.path">
            <summary>Target path</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.Delete.FileSystem">
            <summary>Target filesystem</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.Delete.Path">
            <summary>Target path</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.Delete.Recurse">
            <summary>Delete tree recursively</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.Delete.rollback">
            <summary>Rollback operation.</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.Delete.Option">
            <summary>Target filesystem option or token</summary>
        </member>
        <member name="M:Lexical.FileSystem.Operation.Delete.#ctor(Lexical.FileSystem.Operation.IOperationSession,Lexical.FileSystem.IFileSystem,System.String,System.Boolean,Lexical.FileSystem.IOption,Lexical.FileSystem.Operation.OperationPolicy,Lexical.FileSystem.Operation.OperationBase)">
            <summary>
            Create delete directory op.
            </summary>
            <param name="session"></param>
            <param name="filesystem"></param>
            <param name="path"></param>
            <param name="recurse"></param>
            <param name="option">(optional) </param>
            <param name="policy">(optional) Responds to <see cref="F:Lexical.FileSystem.Operation.OperationPolicy.DstThrow"/> and <see cref="F:Lexical.FileSystem.Operation.OperationPolicy.DstSkip"/> policies.</param>
            <param name="rollback">(optional) Rollback operation</param>
        </member>
        <member name="M:Lexical.FileSystem.Operation.Delete.InnerEstimate">
            <summary>Estimate viability of operation.</summary>
            <exception cref="T:System.IO.FileNotFoundException">If <see cref="P:Lexical.FileSystem.Operation.Delete.Path"/> is not found.</exception>
        </member>
        <member name="M:Lexical.FileSystem.Operation.Delete.InnerRun">
            <summary>Run op</summary>
            <exception cref="T:System.IO.FileNotFoundException">If <see cref="P:Lexical.FileSystem.Operation.Delete.Path"/> is not found.</exception>
        </member>
        <member name="M:Lexical.FileSystem.Operation.Delete.CreateRollback">
            <summary>Create rollback op</summary>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.Operation.Delete.ToString">
            <summary>Print info</summary>
        </member>
        <member name="T:Lexical.FileSystem.Operation.DeleteTree">
            <summary>Delete a file or directory tree</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.DeleteTree.fileSystem">
            <summary>Target filesystem</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.DeleteTree.path">
            <summary>Target path</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.DeleteTree.FileSystem">
            <summary>Target filesystem</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.DeleteTree.Path">
            <summary>Target path</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.DeleteTree.srcOption">
            <summary>Src filesystem option or token</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.DeleteTree.Option">
            <summary>Target filesystem option or token</summary>
        </member>
        <member name="M:Lexical.FileSystem.Operation.DeleteTree.#ctor(Lexical.FileSystem.Operation.IOperationSession,Lexical.FileSystem.IFileSystem,System.String,Lexical.FileSystem.IOption,Lexical.FileSystem.IOption,Lexical.FileSystem.Operation.OperationPolicy)">
            <summary>Create move op.</summary>
        </member>
        <member name="M:Lexical.FileSystem.Operation.DeleteTree.InnerEstimate">
            <summary>Estimate viability of operation.</summary>
            <exception cref="T:System.IO.FileNotFoundException">If <see cref="P:Lexical.FileSystem.Operation.DeleteTree.Path"/> is not found.</exception>
            <exception cref="T:Lexical.FileSystem.FileSystemExceptionFileExists">If <see cref="P:Lexical.FileSystem.Operation.DeleteTree.Path"/> already exists.</exception>
        </member>
        <member name="M:Lexical.FileSystem.Operation.DeleteTree.ToString">
            <summary>Print info</summary>
        </member>
        <member name="T:Lexical.FileSystem.Operation.Move">
            <summary>Move/rename file or directory</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.Move.srcFileSystem">
            <summary>Source filesystem</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.Move.dstFileSystem">
            <summary>Target filesystem</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.Move.srcPath">
            <summary>Source path</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.Move.dstPath">
            <summary>Target path</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.Move.FileSystem">
            <summary>Target filesystem</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.Move.Path">
            <summary>Target path</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.Move.SrcFileSystem">
            <summary>Source filesystem</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.Move.SrcPath">
            <summary>Source path</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.Move.srcOption">
            <summary>Src filesystem option or token</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.Move.Option">
            <summary>Target filesystem option or token</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.Move.moved">
            <summary>Set to true if <see cref="M:Lexical.FileSystem.Operation.IOperation.Run(System.Boolean)"/> moved src.</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.Move.deletedPrev">
            <summary>Set to true if <see cref="M:Lexical.FileSystem.Operation.IOperation.Run(System.Boolean)"/> deleted previous dst.</summary>
        </member>
        <member name="M:Lexical.FileSystem.Operation.Move.#ctor(Lexical.FileSystem.Operation.IOperationSession,Lexical.FileSystem.IFileSystem,System.String,Lexical.FileSystem.IFileSystem,System.String,Lexical.FileSystem.IOption,Lexical.FileSystem.IOption,Lexical.FileSystem.Operation.OperationPolicy)">
            <summary>Create move op.</summary>
        </member>
        <member name="M:Lexical.FileSystem.Operation.Move.InnerEstimate">
            <summary>Estimate viability of operation.</summary>
            <exception cref="T:System.IO.FileNotFoundException">If <see cref="P:Lexical.FileSystem.Operation.Move.SrcPath"/> is not found.</exception>
            <exception cref="T:Lexical.FileSystem.FileSystemExceptionEntryExists">If entry at <see cref="P:Lexical.FileSystem.Operation.Move.Path"/> already exists.</exception>
        </member>
        <member name="M:Lexical.FileSystem.Operation.Move.InnerRun">
            <summary>Run operation</summary>
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:System.Exception">Unexpected error</exception>
        </member>
        <member name="M:Lexical.FileSystem.Operation.Move.CreateRollback">
            <summary>Create rollback</summary>
            <returns>rollback or null</returns>
        </member>
        <member name="M:Lexical.FileSystem.Operation.Move.ToString">
            <summary>Print info</summary>
        </member>
        <member name="T:Lexical.FileSystem.Operation.OperationBase">
            <summary>
            File operation base class.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.OperationBase.session">
            <summary>The session where the op is ran in.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.OperationBase.Session">
            <summary>The session where the op is ran in.</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.OperationBase.currentState">
            <summary>Current state of the operation</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.OperationBase.CurrentState">
            <summary>Current state of the operation</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.OperationBase.Errors">
            <summary>Error events that occured involving this op</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.OperationBase.Children">
            <summary>Child operations</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.OperationBase.FileSystem">
            <summary>Target filesystem, if applicable for the operation</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.OperationBase.Path">
            <summary>Target path, if applicable for the operation.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.OperationBase.SrcFileSystem">
            <summary>Source filesystem, if applicable for the operation. Copy, move and transfer operation use this.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.OperationBase.SrcPath">
            <summary>Source path, if applicable for the operation. Copy, move and transfer operations use this.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.OperationBase.Progress">
            <summary>Current progress of operation in bytes. -1 if unknown.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.OperationBase.TotalLength">
            <summary>Total length of operation in bytes. -1 if unknown.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.OperationBase.OpPolicy">
            <summary>Operation overriding policy. If set to <see cref="F:Lexical.FileSystem.Operation.OperationPolicy.Unset"/>, then uses policy from session.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.OperationBase.EffectivePolicy">
            <summary>
            Effective policy for the operation. 
            
            For source and destination file policies prioritizes the policy on the operation, then fallback to policy on session.
            For other flags uses union of the policy in operation and the policy on session.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.OperationBase.CanRollback">
            <summary>
            Is operation capable of rollback. Value may change after <see cref="M:Lexical.FileSystem.Operation.OperationBase.Estimate"/> and <see cref="M:Lexical.FileSystem.Operation.OperationBase.Run(System.Boolean)"/>.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Operation.OperationBase.#ctor(Lexical.FileSystem.Operation.IOperationSession,Lexical.FileSystem.Operation.OperationPolicy)">
            <summary>
            Create filesystem operation
            </summary>
            <param name="session">operation session</param>
            <param name="policy">operation specific policy</param>
        </member>
        <member name="M:Lexical.FileSystem.Operation.OperationBase.Estimate">
            <summary>
            Estimate viability and size of the operation.
            
            Creates an action plan, and adds them to <see cref="P:Lexical.FileSystem.Operation.OperationBase.Children"/>.
            
            May change <see cref="P:Lexical.FileSystem.Operation.OperationBase.CanRollback"/> value to true from default false.
            
            If caller needs rollback capability, the caller may call <see cref="M:Lexical.FileSystem.Operation.OperationExtensions.AssertCanRollback(Lexical.FileSystem.Operation.IOperation)"/> right after estimate.
            </summary>
            <exception cref="T:System.Exception">If operation is not viable</exception>
        </member>
        <member name="M:Lexical.FileSystem.Operation.OperationBase.InnerEstimate">
            <summary>
            Estimate viability and size of the operation.
            
            Creates an action plan, and adds them to <see cref="P:Lexical.FileSystem.Operation.OperationBase.Children"/>.
            
            May change <see cref="P:Lexical.FileSystem.Operation.OperationBase.CanRollback"/> value to true from default false.
            
            If caller needs rollback capability, the caller may call <see cref="M:Lexical.FileSystem.Operation.OperationExtensions.AssertCanRollback(Lexical.FileSystem.Operation.IOperation)"/> right after estimate.
            </summary>
            <exception cref="T:System.Exception">On any error, captured and processed by calling Run()</exception>
        </member>
        <member name="M:Lexical.FileSystem.Operation.OperationBase.Run(System.Boolean)">
            <summary>
            Run the operation.
            
            Throws exception on unexpected error.
            
            The caller should test <see cref="P:Lexical.FileSystem.Operation.OperationBase.CurrentState"/> to see how operation completed.
            <list type="bullet">
                <item>If canceltoken was canelled then state is set to <see cref="F:Lexical.FileSystem.Operation.OperationState.Cancelled"/>.</item>
                <item>If file already existed and policy has <see cref="F:Lexical.FileSystem.Operation.OperationPolicy.SrcSkip"/> or <see cref="F:Lexical.FileSystem.Operation.OperationPolicy.DstSkip"/>, then state is set to <see cref="F:Lexical.FileSystem.Operation.OperationState.Skipped"/>.</item>
                <item>If unexpected error was thrown, then state is set to <see cref="F:Lexical.FileSystem.Operation.OperationState.Error"/>.</item>
                <item>If operation was ran to end, then state is set to <see cref="F:Lexical.FileSystem.Operation.OperationState.Completed"/>.</item>
            </list>
            Or the caller may call <see cref="M:Lexical.FileSystem.Operation.OperationExtensions.AssertSuccessful(Lexical.FileSystem.Operation.IOperation)"/> to assert that operation ran into successful state.
            </summary>
            <param name="rollbackOnError"></param>
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:Lexical.FileSystem.Operation.OperationBase.InnerRun">
            <summary>
            Run the operation.
            
            Throws exception on unexpected error.
            
            The caller should test <see cref="P:Lexical.FileSystem.Operation.OperationBase.CurrentState"/> to see how operation completed.
            <list type="bullet">
                <item>If canceltoken was canelled then state is set to <see cref="F:Lexical.FileSystem.Operation.OperationState.Cancelled"/>.</item>
                <item>If file already existed and policy has <see cref="F:Lexical.FileSystem.Operation.OperationPolicy.SrcSkip"/> or <see cref="F:Lexical.FileSystem.Operation.OperationPolicy.DstSkip"/>, then state is set to <see cref="F:Lexical.FileSystem.Operation.OperationState.Skipped"/>.</item>
                <item>If unexpected error was thrown, then state is set to <see cref="F:Lexical.FileSystem.Operation.OperationState.Error"/>.</item>
                <item>If operation was ran to end, then state is set to <see cref="F:Lexical.FileSystem.Operation.OperationState.Completed"/>.</item>
            </list>
            Or the caller may call <see cref="M:Lexical.FileSystem.Operation.OperationExtensions.AssertSuccessful(Lexical.FileSystem.Operation.IOperation)"/> to assert that operation ran into successful state.
            </summary>
            <exception cref="T:System.Exception">On any error, captured and processed by calling Run()</exception>
        </member>
        <member name="M:Lexical.FileSystem.Operation.OperationBase.CreateRollback">
            <summary>
            Create rollback operation that reverts already executed operations.
            </summary>
            <returns>null, if rollback could not be created</returns>
        </member>
        <member name="M:Lexical.FileSystem.Operation.OperationBase.SetError(System.Exception)">
            <summary>
            Captures and handles exception.
            
            Sets state to <see cref="F:Lexical.FileSystem.Operation.OperationState.Error"/>.
            Adds event to event log.
            If <see cref="F:Lexical.FileSystem.Operation.OperationPolicy.CancelOnError"/> is set, then cancels the cancel token.
            </summary>
            <param name="error"></param>
            <returns>value of <see cref="F:Lexical.FileSystem.Operation.OperationPolicy.SuppressException"/></returns>
        </member>
        <member name="M:Lexical.FileSystem.Operation.OperationBase.TrySetState(Lexical.FileSystem.Operation.OperationState,Lexical.FileSystem.Operation.OperationState)">
            <summary>
            Try to set state to <paramref name="newState"/>, but only if previous state was <paramref name="expectedState"/>.
            
            Add event of state change to session.
            </summary>
            <param name="newState"></param>
            <param name="expectedState"></param>
            <returns>true if state was <paramref name="expectedState"/> and is now <paramref name="newState"/></returns>
        </member>
        <member name="M:Lexical.FileSystem.Operation.OperationBase.SetState(Lexical.FileSystem.Operation.OperationState)">
            <summary>
            Set state to <paramref name="newState"/> if previous state wasn't that already.
            
            Add event of state change to session.
            </summary>
            <param name="newState">true if previous state was other than <paramref name="newState"/></param>
        </member>
        <member name="T:Lexical.FileSystem.Operation.OperationEventBase">
            <summary>File operation event</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.OperationEventBase.Op">
            <summary>(optional) Involved operation</summary>
        </member>
        <member name="M:Lexical.FileSystem.Operation.OperationEventBase.#ctor(Lexical.FileSystem.Operation.IOperation)">
            <summary>Create event</summary>
        </member>
        <member name="T:Lexical.FileSystem.Operation.OperationStateEvent">
            <summary>State changed event</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.OperationStateEvent.OpState">
            <summary>New state</summary>
        </member>
        <member name="M:Lexical.FileSystem.Operation.OperationStateEvent.#ctor(Lexical.FileSystem.Operation.IOperation,Lexical.FileSystem.Operation.OperationState)">
            <summary>Create error event</summary>
        </member>
        <member name="M:Lexical.FileSystem.Operation.OperationStateEvent.ToString">
            <summary>Print info</summary>
        </member>
        <member name="T:Lexical.FileSystem.Operation.OperationErrorEvent">
            <summary>Error state event</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.OperationErrorEvent.Exception">
            <summary>Error</summary>
        </member>
        <member name="M:Lexical.FileSystem.Operation.OperationErrorEvent.#ctor(Lexical.FileSystem.Operation.IOperation,System.Exception)">
            <summary>Create error event</summary>
        </member>
        <member name="M:Lexical.FileSystem.Operation.OperationErrorEvent.ToString">
            <summary>Print info</summary>
        </member>
        <member name="T:Lexical.FileSystem.Operation.OperationProgressEvent">
            <summary>Progress event</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.OperationProgressEvent.Length">
            <summary>Current position of operation</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.OperationProgressEvent.TotalLength">
            <summary>Total length of operation</summary>
        </member>
        <member name="M:Lexical.FileSystem.Operation.OperationProgressEvent.#ctor(Lexical.FileSystem.Operation.IOperation,System.Int64,System.Int64)">
            <summary>Create IOperation event</summary>
        </member>
        <member name="M:Lexical.FileSystem.Operation.OperationProgressEvent.ToString">
            <summary>Print info</summary>
        </member>
        <member name="T:Lexical.FileSystem.Operation.OperationSession">
            <summary>File operation session</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.OperationSession.observers">
            <summary>Observers</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.OperationSession.CancelSrc">
            <summary>Shared cancellation token</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.OperationSession.Policy">
            <summary>Operation policies</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.OperationSession.Events">
            <summary>Accumulated events</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.OperationSession.Ops">
            <summary>Operations executed in this session</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.OperationSession.HasObservers">
            <summary>Tests if there are observers</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.OperationSession.BlockPool">
            <summary>Pool that allocates byte buffers</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.OperationSession.ProgressInterval">
            <summary>Interval of bytes interval to report progress on copying files.</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.OperationSession.Option">
            <summary>(optional) Option or token</summary>
        </member>
        <member name="M:Lexical.FileSystem.Operation.OperationSession.#ctor(Lexical.FileSystem.Operation.OperationPolicy,Lexical.FileSystem.Utility.IBlockPool,System.Threading.CancellationTokenSource,Lexical.FileSystem.IOption)">
            <summary>Create session</summary>
        </member>
        <member name="M:Lexical.FileSystem.Operation.OperationSession.SetPolicy(Lexical.FileSystem.Operation.OperationPolicy)">
            <summary>Set new policy</summary>
        </member>
        <member name="M:Lexical.FileSystem.Operation.OperationSession.SetProgressInterval(System.Int64)">
            <summary>Set new policy</summary>
        </member>
        <member name="M:Lexical.FileSystem.Operation.OperationSession.SetCancellationSource(System.Threading.CancellationTokenSource)">
            <summary>Set new policy</summary>
        </member>
        <member name="M:Lexical.FileSystem.Operation.OperationSession.Dispose">
            <summary>Dispose</summary>
        </member>
        <member name="M:Lexical.FileSystem.Operation.OperationSession.Dispose(System.Boolean)">
            <summary>Dispose called by finalizer or consumer (on Dispose())</summary>
        </member>
        <member name="M:Lexical.FileSystem.Operation.OperationSession.Subscribe(System.IObserver{Lexical.FileSystem.Operation.IOperationEvent})">
            <summary>Subscribe</summary>
            <returns>Handle to unsubscribe with</returns>
        </member>
        <member name="T:Lexical.FileSystem.Operation.OperationSession.ObserverHandle">
            <summary>Cancellable observer handle.</summary>
        </member>
        <member name="M:Lexical.FileSystem.Operation.OperationSession.LogAndDispatchEvent(Lexical.FileSystem.Operation.IOperationEvent)">
            <summary>Add event to session log and dispatch it. <see cref="T:Lexical.FileSystem.Operation.OperationProgressEvent"/> events are not added to event log.</summary>
        </member>
        <member name="M:Lexical.FileSystem.Operation.OperationSession.DispatchEvent(Lexical.FileSystem.Operation.IOperationEvent)">
            <summary>Dispatch event to observers (in current thread)</summary>
        </member>
        <member name="T:Lexical.FileSystem.Operation.TransferTree">
            <summary>
            Move/rename a file or directory tree by copying and deleting files.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.TransferTree.srcFileSystem">
            <summary>Source filesystem</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.TransferTree.dstFileSystem">
            <summary>Target filesystem</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.TransferTree.srcPath">
            <summary>Source path</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.TransferTree.dstPath">
            <summary>Target path</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.TransferTree.FileSystem">
            <summary>Target filesystem</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.TransferTree.Path">
            <summary>Target path</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.TransferTree.SrcFileSystem">
            <summary>Source filesystem</summary>
        </member>
        <member name="P:Lexical.FileSystem.Operation.TransferTree.SrcPath">
            <summary>Source path</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.TransferTree.srcOption">
            <summary>Src filesystem option or token</summary>
        </member>
        <member name="F:Lexical.FileSystem.Operation.TransferTree.Option">
            <summary>Target filesystem option or token</summary>
        </member>
        <member name="M:Lexical.FileSystem.Operation.TransferTree.#ctor(Lexical.FileSystem.Operation.OperationSession,Lexical.FileSystem.IFileSystem,System.String,Lexical.FileSystem.IFileSystem,System.String,Lexical.FileSystem.IOption,Lexical.FileSystem.IOption,Lexical.FileSystem.Operation.OperationPolicy)">
            <summary>Create move op.</summary>
        </member>
        <member name="M:Lexical.FileSystem.Operation.TransferTree.InnerEstimate">
            <summary>Scan tree, and add ops</summary>
        </member>
        <member name="M:Lexical.FileSystem.Operation.TransferTree.ToString">
            <summary>Print info</summary>
        </member>
        <member name="T:Lexical.FileSystem.Common.PackageFileSystemBase">
            <summary>
            Base implementation for package filesystems. 
            </summary>
        </member>
        <member name="T:Lexical.FileSystem.Package.TempFileProvider">
            <summary>
            Class that creates temp files.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Package.TempFileProvider._default">
            <summary>
            Default instance that uses the default temp folder.
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.Package.TempFileProvider.Default">
            <summary>
            Default instance that uses the default temp folder.
            
            Note, that singleton cannot be disposed, as it is shared.
            However, you can call .Clear() at shutdown of the application.
            </summary>
        </member>
        <member name="T:Lexical.FileSystem.Package.TempFileProvider.HandleDisposedFunc">
            <summary>
            Signature of dispose function.
            </summary>
            <param name="handle"></param>
            <param name="deleted"></param>
        </member>
        <member name="F:Lexical.FileSystem.Package.TempFileProvider.handles">
            <summary>
            Collection of handles that are not disposed.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Package.TempFileProvider.ToDelete">
            <summary>
            Collection of files that should be deleted.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Package.TempFileProvider.isDisposed">
            <summary>
            Dispose state
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Package.TempFileProvider.isDisposing">
            <summary>
            Dispose state
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Package.TempFileProvider.m_lock">
            <summary>
            Internal lock object
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Package.TempFileProvider.handleDisposedFunc">
            <summary>
            On disposed callback delegate.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Package.TempFileProvider.createTempFile">
            <summary>
            Delegate that creates a new the temp file of size 0.
            </summary>
            <returns>full path to file name</returns>
        </member>
        <member name="M:Lexical.FileSystem.Package.TempFileProvider.#ctor(Lexical.FileSystem.Package.TempFileProviderOptions)">
            <summary>
            Create temp file provider.
            </summary>
            <param name="options">(optional) options</param>
        </member>
        <member name="M:Lexical.FileSystem.Package.TempFileProvider.CreateTempFile">
            <summary>
            Create new random temp file.
            </summary>
            <returns></returns>
            <exception cref="T:System.IO.IOException">if file creation failed</exception>
            <exception cref="T:System.ObjectDisposedException">new files cannot be created after provider is disposed</exception>
            <returns>handle with a filename for the caller to use. Caller must dispose after use, that will delete the file if it exists.</returns>
        </member>
        <member name="M:Lexical.FileSystem.Package.TempFileProvider.HandleDisposed(Lexical.FileSystem.Package.ITempFileHandle,System.Boolean)">
            <summary>
            Handle callback from handle.
            </summary>
            <param name="handle"></param>
            <param name="deleted"></param>
        </member>
        <member name="M:Lexical.FileSystem.Package.TempFileProvider.Clear">
            <summary>
            Delete all handles, even non-disposed ones.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Package.TempFileProvider.DeleteMarked">
            <summary>
            Delete any disposed files that were locked when the handle was disposed.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Package.TempFileProvider.Dispose">
            <summary>
            Dispose temp files provider.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Package.TempFileProvider.Dispose(System.Boolean)">
            <summary>
            Dispose temp files provider.
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:Lexical.FileSystem.Package.TempFileProvider.ToString">
            <summary>
            Print info.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Lexical.FileSystem.Package.TempFileHandle.Filename">
            <summary>
            File path to temp file.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Package.TempFileHandle.disposed">
            <summary>
            is disposed
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.Package.TempFileHandle.deleteAction">
            <summary>
            Callback to parent that manages handles.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.Package.TempFileHandle.#ctor(System.String,Lexical.FileSystem.Package.TempFileProvider.HandleDisposedFunc)">
            <summary>
            Create new temp file handle.
            </summary>
            <param name="filename">full file path to temp file</param>
            <param name="deleteAction">on delete callback delegate</param>
        </member>
        <member name="T:Lexical.FileSystem.Package.ZipFileSystem">
            <summary>
            
            </summary>
        </member>
        <member name="T:Lexical.FileSystem.VirtualFileSystem">
            <summary>
            Virtual filesystem.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.VirtualFileSystem.url">
            <summary>URL mounts</summary>
        </member>
        <member name="P:Lexical.FileSystem.VirtualFileSystem.Url">
            <summary>URL mounts.</summary>
        </member>
        <member name="F:Lexical.FileSystem.VirtualFileSystem.vfsLock">
            <summary>
            Reader writer lock for modifying vfs directory structure. 
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.VirtualFileSystem.vfsRoot">
            <summary>
            Root node
            </summary>
        </member>
        <member name="P:Lexical.FileSystem.VirtualFileSystem.CaseSensitivity">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.VirtualFileSystem.EmptyDirectoryName">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.VirtualFileSystem.CanBrowse">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.VirtualFileSystem.CanGetEntry">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.VirtualFileSystem.CanCreateDirectory">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.VirtualFileSystem.CanDelete">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.VirtualFileSystem.CanObserve">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.VirtualFileSystem.CanMove">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.VirtualFileSystem.CanOpen">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.VirtualFileSystem.CanRead">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.VirtualFileSystem.CanWrite">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.VirtualFileSystem.CanCreateFile">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.VirtualFileSystem.CanMount">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.VirtualFileSystem.CanUnmount">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.VirtualFileSystem.CanListMountPoints">
            <inheritdoc/>
        </member>
        <member name="P:Lexical.FileSystem.VirtualFileSystem.CanSetFileAttribute">
            <inheritdoc/>
        </member>
        <member name="M:Lexical.FileSystem.VirtualFileSystem.#ctor">
            <summary>
            Create virtual filesystem.
            </summary>
        </member>
        <member name="T:Lexical.FileSystem.VirtualFileSystem.NonDisposable">
            <summary>
            Non-disposable <see cref="T:Lexical.FileSystem.VirtualFileSystem"/> disposes and cleans all attached <see cref="T:System.IDisposable"/> on dispose, but doesn't go into disposed state.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.VirtualFileSystem.NonDisposable.#ctor">
            <summary>Create non-disposable virtual filesystem.</summary>
        </member>
        <member name="M:Lexical.FileSystem.VirtualFileSystem.Browse(System.String,Lexical.FileSystem.IOption)">
            <inheritdoc/>
            <exception cref="T:System.IO.DirectoryNotFoundException">If <paramref name="path"/> goes beyond root with ".."</exception>
        </member>
        <member name="M:Lexical.FileSystem.VirtualFileSystem.GetEntry(System.String,Lexical.FileSystem.IOption)">
            <inheritdoc/>
        </member>
        <member name="M:Lexical.FileSystem.VirtualFileSystem.GetVfsDirectory(System.String,Lexical.FileSystem.VirtualFileSystem.Directory@,Lexical.FileSystem.Internal.StructList4{Lexical.FileSystem.Decoration.FileSystemDecoration}@,System.Boolean)">
            <summary>
            Traverse vfs directory tree along <paramref name="path"/>, and return the <see cref="T:Lexical.FileSystem.VirtualFileSystem.Directory"/> instance.
            
            If <paramref name="path"/> cannot be found, returns false and the last <see cref="T:Lexical.FileSystem.VirtualFileSystem.Directory"/> that was found.
            Adds each mountpoint along the way to <paramref name="mountpoints"/> collection.
            
            The caller must have <see cref="F:Lexical.FileSystem.VirtualFileSystem.vfsLock"/> read or write lock.
            </summary>
            <param name="path"></param>
            <param name="directory"></param>
            <param name="mountpoints">place all assigned filesystems that were found in the traversal of <paramref name="path"/>. Added in order from root towards <paramref name="path"/>.</param>
            <param name="throwOnError">if true and <paramref name="path"/> refers beyond root, then throw <see cref="T:System.IO.DirectoryNotFoundException"/></param>
            <returns>true if directory was found at <paramref name="path"/>, else false and the last directory that was found</returns>
            <exception cref="T:System.IO.DirectoryNotFoundException">If <paramref name="path"/> refers beyond root and <paramref name="throwOnError"/> is true</exception>
        </member>
        <member name="T:Lexical.FileSystem.VirtualFileSystem.Directory">
            <summary>
            Vfs directory. 
            They are points where other filesystems are mounted to.
            
            Virtual tree directories are created with Mount() and deleted with Unmount(). 
            Vfs doesn't allow creating mountpoints with CreateDirectory() and Delete().
            
            Vfs tree structure is read and written to under <see cref="F:Lexical.FileSystem.VirtualFileSystem.vfsLock"/>.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.VirtualFileSystem.Directory.path">
            <summary>Cached path.</summary>
        </member>
        <member name="F:Lexical.FileSystem.VirtualFileSystem.Directory.name">
            <summary>Name of the entry.</summary>
        </member>
        <member name="F:Lexical.FileSystem.VirtualFileSystem.Directory.isDeleted">
            <summary>Has node been deleted.</summary>
        </member>
        <member name="F:Lexical.FileSystem.VirtualFileSystem.Directory.lastModified">
            <summary>Last modified time.</summary>
        </member>
        <member name="F:Lexical.FileSystem.VirtualFileSystem.Directory.lastAccess">
            <summary>Last access time.</summary>
        </member>
        <member name="F:Lexical.FileSystem.VirtualFileSystem.Directory.vfs">
            <summary>Parent filesystem.</summary>
        </member>
        <member name="F:Lexical.FileSystem.VirtualFileSystem.Directory.parent">
            <summary>Parent node.</summary>
        </member>
        <member name="F:Lexical.FileSystem.VirtualFileSystem.Directory.entry">
            <summary>Cached entry</summary>
        </member>
        <member name="P:Lexical.FileSystem.VirtualFileSystem.Directory.Entry">
            <summary>Get or create entry.</summary>
        </member>
        <member name="F:Lexical.FileSystem.VirtualFileSystem.Directory.children">
            <summary>Files and directories. Lazy construction. Reads and modifications under parent's m_lock.</summary>
        </member>
        <member name="F:Lexical.FileSystem.VirtualFileSystem.Directory.childEntries">
            <summary>Cached child entries</summary>
        </member>
        <member name="F:Lexical.FileSystem.VirtualFileSystem.Directory.mount">
            <summary>The mounted filesystem.</summary>
        </member>
        <member name="P:Lexical.FileSystem.VirtualFileSystem.Directory.ChildEntries">
            <summary>Get or create child entries.</summary>
        </member>
        <member name="P:Lexical.FileSystem.VirtualFileSystem.Directory.Path">
            <summary>Path</summary>
        </member>
        <member name="M:Lexical.FileSystem.VirtualFileSystem.Directory.#ctor(Lexical.FileSystem.VirtualFileSystem,Lexical.FileSystem.VirtualFileSystem.Directory,System.String,System.DateTimeOffset)">
            <summary>
            Create entry
            </summary>
            <param name="filesystem"></param>
            <param name="parent"></param>
            <param name="name"></param>
            <param name="lastModified"></param>
        </member>
        <member name="M:Lexical.FileSystem.VirtualFileSystem.Directory.CreateEntry">
            <summary>
            Create entry snapshot.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.VirtualFileSystem.Directory.Visit(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Enumerate self and subtree.
            </summary>
            <param name="parents">visit parent nodes</param>
            <param name="self">visit this node</param>
            <param name="decendents">visit children and thier decendents</param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.VirtualFileSystem.Directory.IsParentOf(Lexical.FileSystem.VirtualFileSystem.Directory)">
            <summary>
            Tests this <paramref name="lowerDirectory"/> is child of this directory.
            </summary>
            <param name="lowerDirectory"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.VirtualFileSystem.Directory.Dispose">
            <summary>Delete node</summary>
        </member>
        <member name="M:Lexical.FileSystem.VirtualFileSystem.Directory.FlushEntry">
            <summary>Flush cached entry info.</summary>
        </member>
        <member name="M:Lexical.FileSystem.VirtualFileSystem.Directory.FlushChildEntries">
            <summary>Flush cached array of child entries.</summary>
        </member>
        <member name="M:Lexical.FileSystem.VirtualFileSystem.Directory.FlushPath">
            <summary>Flush cached path string and entry</summary>
        </member>
        <member name="M:Lexical.FileSystem.VirtualFileSystem.Directory.ToString">
            <summary>Print info</summary>
        </member>
        <member name="F:Lexical.FileSystem.VirtualFileSystem.observerLock">
            <summary>
            Reader writer lock for modifying observer tree.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.VirtualFileSystem.observerRoot">
            <summary>
            Observer tree root. Read and modified only under <see cref="F:Lexical.FileSystem.VirtualFileSystem.observerLock"/>.
            </summary>
        </member>
        <member name="M:Lexical.FileSystem.VirtualFileSystem.GetOrCreateObserverNode(System.String,Lexical.FileSystem.VirtualFileSystem.ObserverHandle)">
            <summary>
            Get or create observer node.
            </summary>
            <param name="observerPath">the stem part from glob pattern</param>
            <param name="handleToAdd">(optional) Observer handle to add while in lock</param>
            <returns>observer node</returns>
            <exception cref="T:System.IO.DirectoryNotFoundException">if refers beyond parent with ".."</exception>
        </member>
        <member name="M:Lexical.FileSystem.VirtualFileSystem.GetObserverNode(System.String,Lexical.FileSystem.VirtualFileSystem.ObserverNode@)">
            <summary>
            Get ObserverNode at <paramref name="path"/>.
            
            If ObserverNode is found at <paramref name="path"/>, then returns true and the the node in <paramref name="result"/>,
            if not then returns the closest found node in <paramref name="result"/> and false.
            
            The caller should have <see cref="F:Lexical.FileSystem.VirtualFileSystem.observerLock"/> before calling, in order to be able to use the result ObserverNode.
            </summary>
            <param name="path"></param>
            <param name="result"></param>
            <returns>true if observer node was found at <paramref name="path"/></returns>
        </member>
        <member name="M:Lexical.FileSystem.VirtualFileSystem.GetObserverHandles(System.String,System.Boolean,System.Boolean,System.Boolean,Lexical.FileSystem.Internal.StructList12{Lexical.FileSystem.VirtualFileSystem.ObserverHandle}@)">
            <summary>
            Get observer handles.
            
            If <paramref name="atThis"/> is true, then return observers at <paramref name="path"/>.
            If <paramref name="atParents"/> is true, then observers before <paramref name="path"/>,
            and if <paramref name="atDecendents"/> is true, then observers after <paramref name="path"/>.
            </summary>
            <param name="path">Path to search from</param>
            <param name="atParents">If true, then add handles that are parent to <paramref name="path"/></param>
            <param name="atThis">If true, then add handles at <paramref name="path"/></param>
            <param name="atDecendents">If true, then add handles that are decendents at <paramref name="path"/></param>
            <param name="observers">Record to place results</param>
        </member>
        <member name="M:Lexical.FileSystem.VirtualFileSystem.Observe(System.String,System.IObserver{Lexical.FileSystem.IEvent},System.Object,Lexical.FileSystem.IEventDispatcher,Lexical.FileSystem.IOption)">
            <summary>
            Add observer.
            </summary>
            <param name="filter"></param>
            <param name="observer"></param>
            <param name="state"></param>
            <param name="eventDispatcher">(optional) </param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns></returns>
        </member>
        <member name="T:Lexical.FileSystem.VirtualFileSystem.ObserverHandle">
            <summary>
            Observer
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.VirtualFileSystem.ObserverHandle.filterPattern">
            <summary>Filter pattern that is used for filtering events by path.</summary>
        </member>
        <member name="F:Lexical.FileSystem.VirtualFileSystem.ObserverHandle.acceptAll">
            <summary>Accept all pattern "**".</summary>
        </member>
        <member name="F:Lexical.FileSystem.VirtualFileSystem.ObserverHandle.startTime">
            <summary>Time when observing started.</summary>
        </member>
        <member name="F:Lexical.FileSystem.VirtualFileSystem.ObserverHandle.observerNode">
            <summary>Place where observer is held in observer tree.</summary>
        </member>
        <member name="F:Lexical.FileSystem.VirtualFileSystem.ObserverHandle.vfs">
            <summary>Parent object.</summary>
        </member>
        <member name="M:Lexical.FileSystem.VirtualFileSystem.ObserverHandle.#ctor(Lexical.FileSystem.VirtualFileSystem,Lexical.FileSystem.VirtualFileSystem.ObserverNode,Lexical.FileSystem.IFileSystem,System.String,System.IObserver{Lexical.FileSystem.IEvent},System.Object,Lexical.FileSystem.IEventDispatcher)">
            <summary>
            Create adapter observer.
            </summary>
            <param name="vfs">parent object</param>
            <param name="observerNode">(optional) node where handle is placed in the tree. Can be assigned later</param>
            <param name="sourceFileSystem">File system to show as the source of forwarded events (in <see cref="P:Lexical.FileSystem.IEvent.Observer"/>)</param>
            <param name="filter"></param>
            <param name="observer">The observer were decorated events are forwarded to</param>
            <param name="state"></param>
            <param name="eventDispatcher">(optional) </param>
        </member>
        <member name="M:Lexical.FileSystem.VirtualFileSystem.ObserverHandle.Qualify(System.String)">
            <summary>
            Tests whether <paramref name="path"/> qualifies the filter.
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.VirtualFileSystem.ObserverHandle.InnerDispose(Lexical.FileSystem.Internal.StructList4{System.Exception}@)">
            <summary>
            Remove this handle from collection of observers.
            </summary>
            <param name="errors"></param>
        </member>
        <member name="M:Lexical.FileSystem.VirtualFileSystem.ObserverHandle.ToString">
            <summary>Print info</summary>
        </member>
        <member name="T:Lexical.FileSystem.VirtualFileSystem.ObserverNode">
            <summary>
            Observer tree node. Node represents all the observers placed in a path. Path represents the stem part of <see cref="T:Lexical.FileSystem.Internal.GlobPatternInfo"/>.
            Root node represents "" path. 
            
            Observers can be placed before mounting, or after mounting. 
            
            Observer tree is read and modified under <see cref="F:Lexical.FileSystem.VirtualFileSystem.observerLock"/>.
            </summary>
        </member>
        <member name="F:Lexical.FileSystem.VirtualFileSystem.ObserverNode.path">
            <summary>Cached path.</summary>
        </member>
        <member name="F:Lexical.FileSystem.VirtualFileSystem.ObserverNode.name">
            <summary>Name of the node.</summary>
        </member>
        <member name="F:Lexical.FileSystem.VirtualFileSystem.ObserverNode.parent">
            <summary>Parent node</summary>
        </member>
        <member name="F:Lexical.FileSystem.VirtualFileSystem.ObserverNode.children">
            <summary>Files and directories. Lazy construction. Reads and modifications under parent's m_lock.</summary>
        </member>
        <member name="F:Lexical.FileSystem.VirtualFileSystem.ObserverNode.observers">
            <summary>Observers that are on this node.</summary>
        </member>
        <member name="P:Lexical.FileSystem.VirtualFileSystem.ObserverNode.Path">
            <summary>Path</summary>
        </member>
        <member name="M:Lexical.FileSystem.VirtualFileSystem.ObserverNode.#ctor(Lexical.FileSystem.VirtualFileSystem.ObserverNode,System.String)">
            <summary>
            Crate observer node.
            </summary>
            <param name="parent"></param>
            <param name="name"></param>
        </member>
        <member name="M:Lexical.FileSystem.VirtualFileSystem.ObserverNode.Visit(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Enumerate self and subtree.
            </summary>
            <param name="parents">visit parent nodes</param>
            <param name="self">visit this node</param>
            <param name="decendents">visit children and thier decendents</param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.VirtualFileSystem.Mount(System.String,Lexical.FileSystem.IFileSystem,Lexical.FileSystem.IOption,Lexical.FileSystem.IOption)">
            <summary>
            Mount <paramref name="filesystem"/> at <paramref name="path"/> in the parent filesystem.
            
            If <paramref name="path"/> is already mounted, then replaces previous mount.
            If there is an open stream to previously mounted filesystem, that stream is unlinked from the filesystem.
            </summary>
            <param name="path"></param>
            <param name="filesystem"></param>
            <param name="mountOption">(optional)</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns>this (parent filesystem)</returns>
            <exception cref="T:System.NotSupportedException">If operation is not supported</exception>
        </member>
        <member name="M:Lexical.FileSystem.VirtualFileSystem.Mount(System.String,System.ValueTuple{Lexical.FileSystem.IFileSystem,Lexical.FileSystem.IOption}[])">
            <summary>
            Mount <paramref name="filesystems"/> at <paramref name="path"/> in the parent filesystem.
            
            If <paramref name="path"/> is already mounted, then replaces previous mount.
            If there is an open stream to previously mounted filesystem, that stream is unlinked from the filesystem.
            </summary>
            <param name="path"></param>
            <param name="filesystems"></param>
            <returns>this (parent filesystem)</returns>
            <exception cref="T:System.NotSupportedException">If operation is not supported</exception>
        </member>
        <member name="M:Lexical.FileSystem.VirtualFileSystem.Mount(System.String,Lexical.FileSystem.FileSystemAssignment[],Lexical.FileSystem.IOption)">
            <summary>
            Mount <paramref name="mounts"/> at <paramref name="path"/> in the parent filesystem.
            
            If <paramref name="path"/> is already mounted, then replaces previous mount.
            If there is an open stream to previously mounted filesystem, that stream is unlinked from the filesystem.
            </summary>
            <param name="path">path to the directory where to mount <paramref name="mounts"/></param>
            <param name="mounts">(optional)filesystems and options</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns>this (parent filesystem)</returns>
            <exception cref="T:System.NotSupportedException">If operation is not supported</exception>
            <exception cref="T:System.IO.DirectoryNotFoundException">If <paramref name="path"/> refers beyond root with ".."</exception>
        </member>
        <member name="M:Lexical.FileSystem.VirtualFileSystem.Unmount(System.String,Lexical.FileSystem.IOption)">
            <summary>
            Unmount a filesystem at <paramref name="path"/>.
            
            If there is no mount at <paramref name="path"/>, then does nothing.
            If there is an open stream to previously mounted filesystem, that stream is unlinked from the filesystem.
            </summary>
            <param name="path"></param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns>this (parent filesystem)</returns>
            <exception cref="T:System.NotSupportedException">If operation is not supported</exception>
        </member>
        <member name="M:Lexical.FileSystem.VirtualFileSystem.ProcessMountEvents(System.String,Lexical.FileSystem.Internal.StructList12{Lexical.FileSystem.VirtualFileSystem.ObserverHandle}@,Lexical.FileSystem.Internal.StructList4{System.String}@,Lexical.FileSystem.Internal.StructList4{System.String}@,Lexical.FileSystem.Internal.StructList2{Lexical.FileSystem.Decoration.FileSystemDecoration.Component}@,Lexical.FileSystem.Internal.StructList2{Lexical.FileSystem.Decoration.FileSystemDecoration.Component}@)">
            <summary>
            Helper function for Mount and Unmount, processes changes to events, and dispatches them.
            </summary>
            <param name="path">Mount path</param>
            <param name="observers">Observers without decendents, may mess up the list</param>
            <param name="vfsDirectoriesCreated"></param>
            <param name="vfsDirectoriesRemoved"></param>
            <param name="componentsAdded"></param>
            <param name="componentsRemoved"></param>
        </member>
        <member name="M:Lexical.FileSystem.VirtualFileSystem.ListMountPoints(Lexical.FileSystem.IOption)">
            <summary>
            List all mounts
            </summary>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.VirtualFileSystem.Open(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,Lexical.FileSystem.IOption)">
            <summary>
            Open a file for reading and/or writing. File can be created when <paramref name="fileMode"/> is <see cref="F:System.IO.FileMode.Create"/> or <see cref="F:System.IO.FileMode.CreateNew"/>.
            </summary>
            <param name="path">Relative path to file. Directory separator is "/". Root is without preceding "/", e.g. "dir/file.xml"</param>
            <param name="fileMode">determines whether to open or to create the file</param>
            <param name="fileAccess">how to access the file, read, write or read and write</param>
            <param name="fileShare">how the file will be shared by processes</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns>open file stream</returns>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> is an empty string (""), contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support opening files</exception>
            <exception cref="T:System.IO.FileNotFoundException">The file cannot be found, such as when mode is FileMode.Truncate or FileMode.Open, and and the file specified by path does not exist. The file must already exist in these modes.</exception>
            <exception cref="T:System.IO.DirectoryNotFoundException">The specified path is invalid, such as being on an unmapped drive.</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="fileMode"/>, <paramref name="fileAccess"/> or <paramref name="fileShare"/> contains an invalid value.</exception>
            <exception cref="T:System.InvalidOperationException">If <paramref name="path"/> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc.</exception>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="M:Lexical.FileSystem.VirtualFileSystem.CreateDirectory(System.String,Lexical.FileSystem.IOption)">
            <summary>
            Create a directory, or multiple cascading directories.
            
            If directory at <paramref name="path"/> already exists, then returns without exception.
            <paramref name="path"/> should end with directory separator character '/'.
            </summary>
            <param name="path">Relative path to file. Directory separator is "/". The root is without preceding slash "", e.g. "dir/dir2"</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <returns>true if directory exists after the method, false if directory doesn't exist</returns>
            <exception cref="T:System.IO.DirectoryNotFoundException">The specified path is invalid, such as being on an unmapped drive.</exception>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> is an empty string (""), contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support create directory</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters.</exception>
            <exception cref="T:System.InvalidOperationException">If <paramref name="path"/> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc.</exception>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="M:Lexical.FileSystem.VirtualFileSystem.Delete(System.String,System.Boolean,Lexical.FileSystem.IOption)">
            <summary>
            Delete a file or directory.
            
            If <paramref name="path"/> is directory, then it should end with directory separator character '/', for example "dir/".
            
            If <paramref name="recurse"/> is false and <paramref name="path"/> is a directory that is not empty, then <see cref="T:System.IO.IOException"/> is thrown.
            If <paramref name="recurse"/> is true, then any file or directory in <paramref name="path"/> is deleted as well.
            </summary>
            <param name="path">path to a file or directory</param>
            <param name="recurse">if path refers to directory, recurse into sub directories</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <exception cref="T:System.IO.FileNotFoundException">The specified path is invalid.</exception>
            <exception cref="T:System.IO.IOException">On unexpected IO error, or if <paramref name="path"/> refered to a directory that wasn't empty and <paramref name="recurse"/> is false, or trying to delete root when not allowed</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> contains invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support deleting files</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters.</exception>
            <exception cref="T:System.InvalidOperationException"><paramref name="path"/> refers to non-file device</exception>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="M:Lexical.FileSystem.VirtualFileSystem.SetFileAttribute(System.String,System.IO.FileAttributes,Lexical.FileSystem.IOption)">
            <summary>
            Set <paramref name="fileAttribute"/> on <paramref name="path"/>.
            </summary>
            <param name="path"></param>
            <param name="fileAttribute"></param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <exception cref="T:System.IO.FileNotFoundException"><paramref name="path"/> is not found</exception>
            <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path"/> is invalid. For example, it's on an unmapped drive. Only thrown when setting the property value.</exception>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support browse</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters.</exception>
            <exception cref="T:System.InvalidOperationException">If <paramref name="path"/> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc.</exception>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:Lexical.FileSystem.VirtualFileSystem.Move(System.String,System.String,Lexical.FileSystem.IOption)">
            <summary>
            Move/rename a file or directory. 
            
            If <paramref name="srcPath"/> and <paramref name="dstPath"/> refers to a directory, then the path names 
            should end with directory separator character '/'.
            </summary>
            <param name="srcPath">old path of a file or directory</param>
            <param name="dstPath">new path of a file or directory</param>
            <param name="option">(optional) operation specific option; capability constraint, a session, security token or credential. Used for authenticating, authorizing or restricting the operation.</param>
            <exception cref="T:System.IO.FileNotFoundException">The specified <paramref name="srcPath"/> is invalid.</exception>
            <exception cref="T:System.IO.IOException">On unexpected IO error</exception>
            <exception cref="T:System.Security.SecurityException">If caller did not have permission</exception>
            <exception cref="T:System.ArgumentNullException">path is null</exception>
            <exception cref="T:System.ArgumentException">path is an empty string (""), contains only white space, or contains one or more invalid characters</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:Lexical.FileSystem.IFileSystem"/> doesn't support renaming/moving files</exception>
            <exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path, such as when access is Write or ReadWrite and the file or directory is set for read-only access.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters.</exception>
            <exception cref="T:System.InvalidOperationException">path refers to non-file device, or an entry already exists at <paramref name="dstPath"/></exception>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="M:Lexical.FileSystem.VirtualFileSystem.InnerDispose(Lexical.FileSystem.Internal.StructList4{System.Exception}@)">
            <summary>
            Handle dispose
            </summary>
            <param name="disposeErrors"></param>
        </member>
        <member name="M:Lexical.FileSystem.VirtualFileSystem.AddDisposeAction(System.Action{Lexical.FileSystem.VirtualFileSystem})">
            <summary>
            Invoke <paramref name="disposeAction"/> on the dispose of the object.
            
            If parent object is disposed or being disposed, the disposable will be disposed immedialy.
            </summary>
            <param name="disposeAction"></param>
            <returns>self</returns>
        </member>
        <member name="M:Lexical.FileSystem.VirtualFileSystem.AddDisposeAction(System.Action{System.Object},System.Object)">
            <summary>
            Invoke <paramref name="disposeAction"/> on the dispose of the object.
            
            If parent object is disposed or being disposed, the disposable will be disposed immedialy.
            </summary>
            <param name="disposeAction"></param>
            <param name="state"></param>
            <returns>self</returns>
        </member>
        <member name="M:Lexical.FileSystem.VirtualFileSystem.AddDisposable(System.Object)">
            <summary>
            Add <paramref name="disposable"/> to list of objects to be disposed along with the system.
            </summary>
            <param name="disposable"></param>
            <returns>filesystem</returns>
        </member>
        <member name="M:Lexical.FileSystem.VirtualFileSystem.AddDisposables(System.Collections.IEnumerable)">
            <summary>
            Add <paramref name="disposables"/> to list of objects to be disposed along with the system.
            </summary>
            <param name="disposables"></param>
            <returns>filesystem</returns>
        </member>
        <member name="M:Lexical.FileSystem.VirtualFileSystem.AddMountsToBeDisposed">
            <summary>
            Add mounted <see cref="T:Lexical.FileSystem.IFileSystem"/>s to be disposed along with this decoration.
            
            Disposes only those filesystems that were mounted at the time of vfs's dispose.
            </summary>
            <returns>self</returns>
        </member>
        <member name="M:Lexical.FileSystem.VirtualFileSystem.RemoveDisposable(System.Object)">
            <summary>
            Remove <paramref name="disposable"/> from dispose list.
            </summary>
            <param name="disposable"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.VirtualFileSystem.RemoveDisposables(System.Collections.IEnumerable)">
            <summary>
            Remove <paramref name="disposables"/> from dispose list.
            </summary>
            <param name="disposables"></param>
            <returns></returns>
        </member>
        <member name="M:Lexical.FileSystem.VirtualFileSystem.ToString">
            <summary>
            Print info
            </summary>
            <returns></returns>
        </member>
    </members>
</doc>
